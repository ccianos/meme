	TITLE	M:\src\Meme\mds\Forth.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_lnamebuf
_DATA	SEGMENT
COMM	_tempvoc:BYTE:0cH
COMM	_num_buf:BYTE:028H
COMM	_astrbuf:BYTE:0101H
_digits	DB	'0123456789abcdefghijklmnopqrstuvwxyz', 00H
	ORG $+3
_lnamebuf DD	0f4H
$SG58102 DB	'Tried to execute a null token at 0x%x', 0aH, 00H
	ORG $+1
$SG58271 DB	'Out of dictionary space', 0aH, 00H
	ORG $+3
$SG58582 DB	'Undefined word encountered', 0aH, 00H
$SG58690 DB	'rb', 00H
	ORG $+1
$SG58693 DB	'wb', 00H
	ORG $+1
$SG58696 DB	'rb+', 00H
$SG58740 DB	0dH, 0aH, 00H
	ORG $+1
$SG58842 DB	'%.*f', 00H
	ORG $+3
$SG58848 DB	'%.*e', 00H
	ORG $+3
$SG59038 DB	'Couldn''t read URL ', 00H
	ORG $+1
$SG59041 DB	0aH, 00H
	ORG $+2
$SG59049 DB	'NewAudible: Unimplemented Meme operation', 0aH, 00H
	ORG $+2
$SG59163 DB	'Couldn''t read texture file ', 00H
$SG59166 DB	0aH, 00H
	ORG $+2
$SG59298 DB	'CyberMan support is unimplemented in this version.', 0aH
	DB	00H
$SG59454 DB	'%f', 00H
	ORG $+1
$SG59790 DB	04H, 'main', 00H
	ORG $+2
$SG59819 DB	09H, '..\init.x', 00H
	ORG $+1
$SG59842 DB	'Unknown command while initializing the dictionary: ', 00H
$SG59844 DB	0aH, 00H
	ORG $+2
$SG59846 DB	'Fatal error', 00H
$SG59865 DB	'rb', 00H
	ORG $+1
$SG59866 DB	'Can''t open dictionary file', 0aH, 00H
$SG59869 DB	'Can''t read header', 0aH, 00H
	ORG $+1
$SG59871 DB	'Bad magic number in dictionary file', 0aH, 00H
	ORG $+3
$SG59875 DB	'Can''t read dictionary image.  File position: %lu', 0aH, 00H
	ORG $+2
$SG59882 DB	'Can''t read user area image', 0aH, 00H
$SG59894 DB	'Can''t read dictionary relocation map', 0aH, 00H
	ORG $+2
$SG59905 DB	'Can''t read data relocation map', 0aH, 00H
$SG60050 DB	'%s isn''t unique', 0aH, 00H
	ORG $+3
$SG60092 DB	' ', 00H
	ORG $+2
$SG60198 DB	'Warning: reference outside the module and std library', 0aH
	DB	00H
	ORG $+1
$SG60211 DB	' ?', 00H
	ORG $+1
$SG60213 DB	'   Last: ', 00H
	ORG $+2
$SG60215 DB	'   File: ', 00H
	ORG $+2
$SG60216 DB	0aH, 00H
	ORG $+2
$SG60244 DB	'Integer stack underflow', 0aH, 00H
	ORG $+3
$SG60248 DB	'Floating-point stack underflow', 0aH, 00H
$SG60366 DB	'Conditionals not paired', 0aH, 00H
	ORG $+3
$SG60417 DB	'%s ?', 00H
	ORG $+3
$SG60419 DB	'   Last: ', 00H
	ORG $+2
$SG60421 DB	'   File: ', 00H
	ORG $+2
$SG60422 DB	0aH, 'Warning: reference outside the module and std libra'
	DB	'ry.', 0aH, 00H
_DATA	ENDS
PUBLIC	__real@8@c01e8000000000000000
PUBLIC	__real@8@401dfffffffe00000000
PUBLIC	__real@8@00000000000000000000
PUBLIC	_inner_interpreter
PUBLIC	_quote_create
PUBLIC	_blword
PUBLIC	_number
PUBLIC	_tokstore
PUBLIC	_doccall
EXTRN	_time:NEAR
EXTRN	_pfgets:NEAR
EXTRN	_pfgetline:NEAR
EXTRN	_itoa:NEAR
EXTRN	_NumberObjects:NEAR
EXTRN	_Orphan:NEAR
EXTRN	_Adopts:NEAR
EXTRN	_DestroyObject:NEAR
EXTRN	_NewImaginaryObject:NEAR
EXTRN	_NewCompoundObject:NEAR
EXTRN	_NewModule:NEAR
EXTRN	_DestroyModule:NEAR
EXTRN	_Float2IFloat:NEAR
EXTRN	_IFloat2Float:NEAR
EXTRN	_MemeJoystickX:NEAR
EXTRN	_MemeJoystickY:NEAR
EXTRN	_MemeJoystickB:NEAR
EXTRN	_NewMat:NEAR
EXTRN	_DestroyMat:NEAR
EXTRN	_MatColor:NEAR
EXTRN	_MatOpacity:NEAR
EXTRN	_MatSurface:NEAR
EXTRN	_MatGeometry:NEAR
EXTRN	_MatShading:NEAR
EXTRN	_MatTexture:NEAR
EXTRN	_MatWrap:NEAR
EXTRN	_MemeMouseX:NEAR
EXTRN	_MemeMouseY:NEAR
EXTRN	_MemeMouseB:NEAR
EXTRN	_NetConnect:NEAR
EXTRN	_NetListen:NEAR
EXTRN	_NetConnected:NEAR
EXTRN	_NetAccepted:NEAR
EXTRN	_NetStatus:NEAR
EXTRN	_NetRead:NEAR
EXTRN	_NetWrite:NEAR
EXTRN	_NetDisconnect:NEAR
EXTRN	_NetDisconnected:NEAR
EXTRN	_NetName2HostID:NEAR
EXTRN	_IsMyHostID:NEAR
EXTRN	_SendMemeMessage:NEAR
EXTRN	_NetDispatch:NEAR
EXTRN	__flsbuf:NEAR
EXTRN	_fclose:NEAR
EXTRN	_NewCameraObject:NEAR
EXTRN	_fflush:NEAR
EXTRN	_fgetc:NEAR
EXTRN	_NewLightObject:NEAR
EXTRN	_NewVisibleObject:NEAR
EXTRN	_fopen:NEAR
EXTRN	_NewSpriteObject:NEAR
EXTRN	_fputs:NEAR
EXTRN	_fseek:NEAR
EXTRN	_ftell:NEAR
EXTRN	_Transform:NEAR
EXTRN	_Render:NEAR
EXTRN	_MemeCurrentCamera:NEAR
EXTRN	_MemeSetCameraBackColor:NEAR
EXTRN	_MemeSetCameraBackdrop:NEAR
EXTRN	_MemeSetCameraBackdropOffset:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__CIfmod:NEAR
EXTRN	__CIasin:NEAR
EXTRN	_MemeSetCameraViewWindow:NEAR
EXTRN	__CIacos:NEAR
EXTRN	__CIcosh:NEAR
EXTRN	_MemeScreenHeight:NEAR
EXTRN	__CIsinh:NEAR
EXTRN	__CItanh:NEAR
EXTRN	_MemeScreenWidth:NEAR
EXTRN	_ungetc:NEAR
EXTRN	__CIpow:NEAR
EXTRN	__ftol:NEAR
EXTRN	_MemeWindowHeight:NEAR
EXTRN	_MemeWindowWidth:NEAR
EXTRN	_MemePickObject:NEAR
EXTRN	_SerialOpen:NEAR
EXTRN	_SerialClose:NEAR
EXTRN	_MemeSetVertex:NEAR
EXTRN	_MemePolygonCount:NEAR
EXTRN	_MemeNewTexture:NEAR
EXTRN	_SerialRead:NEAR
EXTRN	_MemeNewMaskedTexture:NEAR
EXTRN	_SerialWrite:NEAR
EXTRN	_MemeTextureFrameStep:NEAR
EXTRN	_MemeTextureNextFrame:NEAR
EXTRN	_MemeSetTextureFrame:NEAR
EXTRN	_MemePolygonMaterial:NEAR
EXTRN	_MemeShapeMaterial:NEAR
EXTRN	_longjmp:NEAR
EXTRN	_MemeGetPolygonMaterial:NEAR
EXTRN	_MemeWriteShape:NEAR
EXTRN	_comp_level:DWORD
EXTRN	_saved_dp:DWORD
EXTRN	_MemeDestroyTexture:NEAR
EXTRN	_errMsg:BYTE
EXTRN	_MemeGetVertexCount:NEAR
EXTRN	_DebuggerData:BYTE
EXTRN	_comp_buffer:BYTE
EXTRN	_tibbuf:BYTE
EXTRN	_xsp:DWORD
EXTRN	_xrp:DWORD
EXTRN	_MemeGetVertex:NEAR
EXTRN	_xfsp:DWORD
EXTRN	_xup:DWORD
EXTRN	_MemeWhichObject:NEAR
EXTRN	_xfrp:DWORD
EXTRN	_multitasking:DWORD
EXTRN	_nlocnames:DWORD
EXTRN	_locnames:BYTE
EXTRN	_locnum:DWORD
EXTRN	_env:BYTE
EXTRN	_MemeLightColor:NEAR
EXTRN	_relmap:DWORD
EXTRN	_urelmap:DWORD
EXTRN	_bit:BYTE
EXTRN	_nullrelmap:BYTE
EXTRN	_origin:DWORD
EXTRN	_dict_end:DWORD
EXTRN	_main_task:BYTE
EXTRN	_MemeLightConeAngle:NEAR
EXTRN	_wordbuf:BYTE
EXTRN	_MemeGetPolygon:NEAR
EXTRN	_input_name:DWORD
EXTRN	_MemeEmptyShape:NEAR
EXTRN	_Objects:BYTE
EXTRN	__fltused:NEAR
EXTRN	_floatstr:BYTE
EXTRN	_fbits:QWORD
EXTRN	_MemeAddVertex:NEAR
EXTRN	_MemeAddPolygon:NEAR
EXTRN	_maintaskReceiver:DWORD
EXTRN	_MemeAddShape:NEAR
EXTRN	_MemeReversePolygonNormal:NEAR
EXTRN	_MemeReverseShapeNormals:NEAR
EXTRN	_MemeTextureCamera:NEAR
EXTRN	_ceil:NEAR
EXTRN	_floor:NEAR
EXTRN	_MemeOften:NEAR
EXTRN	_strdup:NEAR
EXTRN	_OpenURL:NEAR
EXTRN	_WaitURL:NEAR
EXTRN	_key:NEAR
EXTRN	_emit:NEAR
EXTRN	_key_avail:NEAR
EXTRN	_DestroyRegion:NEAR
EXTRN	_dosyscall:NEAR
EXTRN	_PointInRegion:NEAR
EXTRN	_myrand:NEAR
EXTRN	_myrandomize:NEAR
EXTRN	_PointInPrism:NEAR
EXTRN	_chdir:NEAR
EXTRN	_getcwd:NEAR
EXTRN	_OverlappingPrisms:NEAR
EXTRN	_OverlappingRegions:NEAR
EXTRN	_AddToRegion:NEAR
EXTRN	_RegisterDBRegion:NEAR
EXTRN	_NumberFrames:DWORD
EXTRN	_UnregisterDBRegion:NEAR
EXTRN	_EnclosingDBRegion:NEAR
EXTRN	_FirstOverlappingDBRegion:NEAR
EXTRN	_NextOverlappingDBRegion:NEAR
EXTRN	_RegisterDeckModule:NEAR
EXTRN	_errno:DWORD
EXTRN	__sys_errlist:BYTE
EXTRN	_atof:NEAR
EXTRN	_atoi:NEAR
EXTRN	_free:NEAR
EXTRN	_malloc:NEAR
EXTRN	_realloc:NEAR
EXTRN	_system:NEAR
EXTRN	_ExitMeme:NEAR
EXTRN	_pop_all:NEAR
EXTRN	_ftime:NEAR
EXTRN	_cprint:NEAR
EXTRN	_error:NEAR
EXTRN	_cexpect:NEAR
EXTRN	_load:NEAR
EXTRN	_localtime:NEAR
EXTRN	_prompt:NEAR
EXTRN	_load_pop:NEAR
;	COMDAT __real@8@c01e8000000000000000
; File M:\src\Meme\mds\Forth.c
CONST	SEGMENT
__real@8@c01e8000000000000000 DQ 0c1e0000000000000r ; -2.14748e+009
CONST	ENDS
;	COMDAT __real@8@401dfffffffe00000000
CONST	SEGMENT
__real@8@401dfffffffe00000000 DQ 041dfffffffc00000r ; 2.14748e+009
CONST	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
_TEXT	SEGMENT
_x$59416 = -224
_y$59417 = -240
_z$59418 = -168
_tp$61469 = -260
_i$61475 = -212
_filename$59486 = -240
_destname$59487 = -256
_rq$59488 = -260
_filename$59508 = -240
_rq$59509 = -260
$T61563 = -184
_r$59537 = -224
_g$59538 = -240
_b$59539 = -160
_temp$58517 = -260
_umbra$59543 = -240
_penumbra$59544 = -144
_n$61616 = -252
_texname$59569 = -240
_maskname$59570 = -260
_i$61619 = -248
_texlocalname$59571 = -256
_rq$59573 = -252
$T61627 = -260
$T61628 = -212
_len$61641 = -248
$T61665 = -240
$T61666 = -224
_bh$58603 = -240
_ah$58607 = -240
_scr1$58624 = -76
_obj$59665 = -256
_filename$59666 = -240
_rq$59667 = -260
_x$59705 = -240
_x$59721 = -224
_y$59722 = -240
_z$59723 = -128
_vindexaddr$59730 = -240
_CFABuff$60759 = -64
_s$60830 = -256
_p$60831 = -252
_length$60832 = -260
_s$60847 = -260
_p$60848 = -256
_length$60849 = -240
_dictp$60851 = -252
_voc$60863 = -212
_last_voc$60864 = -260
_s$60888 = -260
_p$60889 = -248
_length$60890 = -192
_dictp$60892 = -212
_mantissa$58981 = -240
_parent$58998 = -212
_linktype$58999 = -248
_subtype$59000 = -192
_x$59003 = -224
_y$59004 = -240
_parent$59009 = -240
_parent$59017 = -256
_filename$59018 = -256
_linktype$59019 = -240
_rq$59021 = -260
_r$59077 = -224
_g$59078 = -240
_b$59079 = -152
_w$59083 = -240
_h$59084 = -104
_t$59087 = -12
_ip$ = 8
_tos$ = -292
_rp$ = -276
_fsp$ = -268
_ftos$ = -288
_scr$ = -256
_ascr$ = -252
_frp$ = -272
_up$ = -264
_entrycontext$ = -180
_file$ = -260
_ascr1$ = -244
_scr2$ = -196
_lscr$ = -224
_lscr1$ = -240
_ftemp$ = -208
_opacity$59113 = -136
_mrecp$59127 = -248
_vindex$59137 = -240
_x$59138 = -192
_y$59139 = -224
_z$59140 = -88
_quot$58122 = -260
$T61196 = -248
_filename$59149 = -256
_rq$59150 = -260
_r$59187 = -224
_g$59188 = -240
_b$59189 = -120
_a$59192 = -192
_d$59193 = -224
_i$61242 = -212
_s$59194 = -240
_power$59195 = -72
_theTime$59217 = -108
_x$59228 = -32
_y$59229 = -24
_z$59230 = -56
_timeout$59253 = -260
_timeout$59273 = -260
$T61330 = -240
_comport$59302 = -192
_baudrate$59303 = -224
_parity$59304 = -240
_portdesc$59312 = -240
_portdesc$59317 = -240
_ipnumber$59322 = -240
_x$59372 = -224
_y$59373 = -240
_z$59374 = -176
_x$59380 = -224
_y$59381 = -240
_z$59382 = -96
_inner_interpreter PROC NEAR

; 113  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H

; 114  :     register cell tos = *xsp++;		/* Top of int stack		*/
; 115  :     register cell *sp = xsp;		/* The inner interpreter's sp	*/
; 116  :     register token_t *token;		/* Equivalent to the W register	*/
; 117  :     register token_t **rp = xrp;	/* Inner interpreter's r stk ptr */

  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  00012	53		 push	 ebx
  00013	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  00019	89 4c 24 14	 mov	 DWORD PTR _rp$[esp+296], ecx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00021	83 c3 04	 add	 ebx, 4
  00024	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 118  :     register double *fsp = xfsp;	/* The float stack pointer	*/

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfsp
  0002d	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx

; 119  :     register double ftos = *fsp++;	/* Top of float stack		*/

  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	83 c0 08	 add	 eax, 8
  0003b	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx

; 120  :     register cell scr;				/* Scratch register for ints	*/
; 121  :     register u_char *ascr;			/* Scratch reg for addresses	*/
; 122  : 	register cell *frp = xfrp;		/* Frame pointer for local variables */

  0003f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  00045	89 44 24 24	 mov	 DWORD PTR _fsp$[esp+304], eax

; 123  :     register cell *up = xup;		/* The user pointer		*/

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0004e	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  00052	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  00056	89 44 24 28	 mov	 DWORD PTR _up$[esp+304], eax

; 124  : 	cell *entrycontext = xup;		/* Checked in FINISHED */

  0005a	89 44 24 7c	 mov	 DWORD PTR _entrycontext$[esp+304], eax
$L61881:

; 1467 : 		} else {

  0005e	8b 74 24 24	 mov	 esi, DWORD PTR _fsp$[esp+304]
$L61884:

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  00062	8b 7c 24 28	 mov	 edi, DWORD PTR _up$[esp+304]
$L58091:

; 125  :     FILE *file;						/* Scratch file pointer		*/
; 126  :     u_char *ascr1;					/* Yet another scratch addr reg	*/
; 127  :     cell scr2;						/* auto var, can take addr of it */
; 128  :     long lscr, lscr1;				/* Double-prec scratch (archaic) */
; 129  :     double ftemp;					/* Floating scratch		*/
; 130  :     unsigned long *ulongp;			/* Pointer scratch		*/
; 131  : 
; 132  : 	for (;;) {
; 133  : 	    token = *(token_t **)ip++;		/* W = (IP)++			*/

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _ip$[ebp]
  00069	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006b	83 c1 04	 add	 ecx, 4
  0006e	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx
$doprim$58094:

; 134  : doprim:
; 135  :  		switch ((token_t)token) {		/* Jmp W			*/

  00071	3d 88 01 00 00	 cmp	 eax, 392		; 00000188H
  00076	77 44		 ja	 SHORT $L59754
  00078	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L61987[eax*4]
$L58236:

; 285  : 			case EXECUTE:      token = (token_t *)pop;

  0007f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00081	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00085	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  00089	83 c3 04	 add	 ebx, 4
  0008c	eb 4b		 jmp	 SHORT $execute$58238
$L58277:

; 351  : 			case EXPECT: 
; 352  : 				token = (token_t *)(V_TICK_EXPECT);

  0008e	8b 47 58	 mov	 eax, DWORD PTR [edi+88]

; 353  : 				goto execute;

  00091	eb 46		 jmp	 SHORT $execute$58238
$L58928:

; 1165 :     		case DOLOCNAME:
; 1166 : 				push (locnames[locnum].data);

  00093	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00097	83 eb 04	 sub	 ebx, 4
  0009a	89 13		 mov	 DWORD PTR [ebx], edx
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _locnum
  000a1	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000a4	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000a7	c1 e0 02	 shl	 eax, 2
  000aa	8b 90 28 00 00
	00		 mov	 edx, DWORD PTR _locnames[eax+40]

; 1167 : 	        	token = (token_t *)locnames[locnum].code;

  000b0	8b 80 24 00 00
	00		 mov	 eax, DWORD PTR _locnames[eax+36]
  000b6	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 1168 : 				goto execute;

  000ba	eb 1d		 jmp	 SHORT $execute$58238
$L59754:

; 2616 : 			}
; 2617 : 
; 2618 : 			default:	/* Defining memes */ 
; 2619 : 				switch (*token++) {

  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	83 c0 04	 add	 eax, 4
  000c1	81 e9 91 01 00
	00		 sub	 ecx, 401		; 00000191H
  000c7	83 f9 06	 cmp	 ecx, 6
  000ca	0f 87 14 77 00
	00		 ja	 $L59773
  000d0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L61988[ecx*4]
$L59769:

; 2624 : 					case DODEFER:	token = (token_t *)*token; goto execute;

  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
$execute$58238:

; 286  : execute:
; 287  : 				if ((token_t)token > MAXPRIM  &&  *token < MAXPRIM)

  000d9	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  000de	76 91		 jbe	 SHORT $doprim$58094
  000e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e2	81 f9 90 01 00
	00		 cmp	 ecx, 400		; 00000190H
  000e8	73 87		 jae	 SHORT $doprim$58094

; 288  : 					token = (token_t *)*token;

  000ea	8b c1		 mov	 eax, ecx

; 289  : 				goto doprim;

  000ec	eb 83		 jmp	 SHORT $doprim$58094
$L58100:

; 136  : 			case 0:
; 137  : 				sprintf(errMsg, "Tried to execute a null token at 0x%x\n", (u_cell)ip);

  000ee	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:$SG58102
  000f7	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  000fc	e8 00 00 00 00	 call	 _sprintf

; 138  : 				error(errMsg);

  00101	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  00106	e8 00 00 00 00	 call	 _error
  0010b	83 c4 10	 add	 esp, 16			; 00000010H

; 139  : 				goto abort;

  0010e	e9 e5 2f 00 00	 jmp	 $abort$58103
$L58104:

; 140  : 			case NOT:	 unop (~);     next;

  00113	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00117	f7 d1		 not	 ecx
  00119	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0011d	e9 44 ff ff ff	 jmp	 $L58091
$L58105:

; 141  : 			case AND:	 binop (&);    next;

  00122	8b 13		 mov	 edx, DWORD PTR [ebx]
  00124	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00128	23 ca		 and	 ecx, edx

; 2553 : 				RESTORE_XCONTEXT

  0012a	83 c3 04	 add	 ebx, 4
  0012d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2554 : 			} next;

  00131	e9 30 ff ff ff	 jmp	 $L58091
$L58106:

; 142  : 			case OR:	 binop (|);    next;

  00136	8b 03		 mov	 eax, DWORD PTR [ebx]
  00138	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0013c	0b c8		 or	 ecx, eax

; 2553 : 				RESTORE_XCONTEXT

  0013e	83 c3 04	 add	 ebx, 4
  00141	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2554 : 			} next;

  00145	e9 1c ff ff ff	 jmp	 $L58091
$L58107:

; 143  : 			case XOR:	 binop (^);    next;

  0014a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0014c	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00150	33 d1		 xor	 edx, ecx

; 2553 : 				RESTORE_XCONTEXT

  00152	83 c3 04	 add	 ebx, 4
  00155	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2554 : 			} next;

  00159	e9 08 ff ff ff	 jmp	 $L58091
$L58108:

; 144  : 			case PLUS:	 binop (+);    next;

  0015e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00160	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00164	03 ca		 add	 ecx, edx

; 2553 : 				RESTORE_XCONTEXT

  00166	83 c3 04	 add	 ebx, 4
  00169	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2554 : 			} next;

  0016d	e9 f4 fe ff ff	 jmp	 $L58091
$L58109:

; 145  : 			case MINUS:	 binop (-);    next;

  00172	8b 03		 mov	 eax, DWORD PTR [ebx]
  00174	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00178	2b c1		 sub	 eax, ecx

; 2553 : 				RESTORE_XCONTEXT

  0017a	83 c3 04	 add	 ebx, 4
  0017d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  00181	e9 e0 fe ff ff	 jmp	 $L58091
$L58110:

; 146  : 			case TIMES:	 binop (*);    next;

  00186	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00188	0f af 4c 24 0c	 imul	 ecx, DWORD PTR _tos$[esp+304]
  0018d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2553 : 				RESTORE_XCONTEXT

  00191	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  00194	e9 cd fe ff ff	 jmp	 $L58091
$L58111:

; 147  : #define FLOORFIX(dividend, divisor, remainder)  ((dividend < 0) ^ (divisor < 0))  &&  (remainder != 0)
; 148  : 			case DIVIDE:{
; 149  : 		    	register cell quot, rem;
; 150  : 
; 151  : 		    	scr = *sp++;

  00199	8b 33		 mov	 esi, DWORD PTR [ebx]

; 152  : 		    	quot = scr/tos;
; 153  : 		    	rem  = scr - tos*quot;
; 154  : 		    	if (FLOORFIX(tos,scr,rem))

  0019b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0019f	8b c6		 mov	 eax, esi
  001a1	83 c3 04	 add	 ebx, 4
  001a4	99		 cdq
  001a5	f7 7c 24 0c	 idiv	 DWORD PTR _tos$[esp+304]
  001a9	33 d2		 xor	 edx, edx
  001ab	85 f6		 test	 esi, esi
  001ad	0f 9c c2	 setl	 dl
  001b0	8b f8		 mov	 edi, eax
  001b2	33 c0		 xor	 eax, eax
  001b4	85 c9		 test	 ecx, ecx
  001b6	0f 9c c0	 setl	 al
  001b9	33 d0		 xor	 edx, eax
  001bb	74 0c		 je	 SHORT $L58114
  001bd	8b cf		 mov	 ecx, edi
  001bf	0f af 4c 24 0c	 imul	 ecx, DWORD PTR _tos$[esp+304]
  001c4	2b f1		 sub	 esi, ecx
  001c6	74 01		 je	 SHORT $L58114

; 155  : 					tos = quot - 1;

  001c8	4f		 dec	 edi
$L58114:
  001c9	89 7c 24 0c	 mov	 DWORD PTR _tos$[esp+304], edi

; 156  : 		    	else

  001cd	e9 8c fe ff ff	 jmp	 $L61881
$L58116:

; 157  : 					tos = quot;
; 158  : 			} next;
; 159  :     		case MOD: {
; 160  : 		    	register cell rem;
; 161  : 
; 162  : 		    	scr = *sp++;  rem = scr%tos;

  001d2	8b 33		 mov	 esi, DWORD PTR [ebx]
  001d4	83 c3 04	 add	 ebx, 4
  001d7	8b c6		 mov	 eax, esi
  001d9	99		 cdq
  001da	f7 7c 24 0c	 idiv	 DWORD PTR _tos$[esp+304]
  001de	8b fa		 mov	 edi, edx

; 163  : 		    	if (FLOORFIX(tos,scr,rem))

  001e0	33 d2		 xor	 edx, edx
  001e2	85 f6		 test	 esi, esi
  001e4	8b 74 24 0c	 mov	 esi, DWORD PTR _tos$[esp+304]
  001e8	0f 9c c2	 setl	 dl
  001eb	33 c0		 xor	 eax, eax
  001ed	85 f6		 test	 esi, esi
  001ef	0f 9c c0	 setl	 al
  001f2	33 d0		 xor	 edx, eax
  001f4	74 d3		 je	 SHORT $L58114
  001f6	85 ff		 test	 edi, edi
  001f8	74 cf		 je	 SHORT $L58114

; 164  : 					tos = tos + rem;

  001fa	8b c6		 mov	 eax, esi
  001fc	03 c7		 add	 eax, edi
  001fe	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 165  : 		    	else

  00202	e9 57 fe ff ff	 jmp	 $L61881
$L58120:

; 166  : 					tos = rem;
; 167  : 			} next;
; 168  :     		case TIM_DIV_MOD: {
; 169  : 		    	register long dividend;
; 170  : 		    	register cell quot, rem;
; 171  : 
; 172  : 		    	dividend = *sp++;

  00207	8b 03		 mov	 eax, DWORD PTR [ebx]

; 173  : 		    	dividend *= *sp++;

  00209	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0020c	83 c3 04	 add	 ebx, 4
  0020f	0f af f0	 imul	 esi, eax

; 174  : 		    	quot = dividend/tos;

  00212	8b c6		 mov	 eax, esi

; 175  : 		    	rem  = dividend - tos*quot;

  00214	8b fe		 mov	 edi, esi
  00216	99		 cdq
  00217	f7 7c 24 0c	 idiv	 DWORD PTR _tos$[esp+304]
  0021b	83 c3 04	 add	 ebx, 4

; 176  : 		    	if (FLOORFIX(dividend,tos,rem)) {

  0021e	33 d2		 xor	 edx, edx
  00220	89 44 24 2c	 mov	 DWORD PTR _quot$58122[esp+304], eax
  00224	8b c8		 mov	 ecx, eax
  00226	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0022a	0f af c8	 imul	 ecx, eax
  0022d	2b f9		 sub	 edi, ecx
  0022f	85 f6		 test	 esi, esi
  00231	0f 9c c2	 setl	 dl
  00234	33 c9		 xor	 ecx, ecx
  00236	85 c0		 test	 eax, eax
  00238	0f 9c c1	 setl	 cl
  0023b	33 d1		 xor	 edx, ecx
  0023d	74 1b		 je	 SHORT $L58124
  0023f	85 ff		 test	 edi, edi
  00241	74 17		 je	 SHORT $L58124

; 177  : 					*--sp = rem  + tos; 

  00243	8b d0		 mov	 edx, eax

; 178  : 					tos = quot - 1;

  00245	8b 44 24 2c	 mov	 eax, DWORD PTR _quot$58122[esp+304]
  00249	83 eb 04	 sub	 ebx, 4
  0024c	03 fa		 add	 edi, edx
  0024e	48		 dec	 eax
  0024f	89 3b		 mov	 DWORD PTR [ebx], edi
  00251	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 179  : 		    	} else {

  00255	e9 04 fe ff ff	 jmp	 $L61881
$L58124:

; 180  : 		        	*--sp = rem ;
; 181  : 					tos = quot;

  0025a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _quot$58122[esp+304]
  0025e	83 eb 04	 sub	 ebx, 4
  00261	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  00265	89 3b		 mov	 DWORD PTR [ebx], edi

; 182  : 		    	}
; 183  : 			} next;

  00267	e9 f2 fd ff ff	 jmp	 $L61881
$L58126:

; 184  : 			case SHIFT:
; 185  : 				if ( tos < 0 ) {

  0026c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00270	85 c9		 test	 ecx, ecx
  00272	7d 12		 jge	 SHORT $L58127

; 186  :     		 	    tos = -tos;
; 187  : 			    	tos = (unsigned cell) *sp++ >> (unsigned cell)tos;

  00274	8b 13		 mov	 edx, DWORD PTR [ebx]
  00276	f7 d9		 neg	 ecx
  00278	d3 ea		 shr	 edx, cl
  0027a	83 c3 04	 add	 ebx, 4
  0027d	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 188  : 				} else {

  00281	e9 e0 fd ff ff	 jmp	 $L58091
$L58127:

; 189  : 					binop(<<);

  00286	8b 03		 mov	 eax, DWORD PTR [ebx]
  00288	d3 e0		 shl	 eax, cl

; 2553 : 				RESTORE_XCONTEXT

  0028a	83 c3 04	 add	 ebx, 4
  0028d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  00291	e9 d0 fd ff ff	 jmp	 $L58091
$L58131:

; 190  : 				}
; 191  : 			next;
; 192  : 			case SHIFTA:	binop(>>); next;

  00296	8b 13		 mov	 edx, DWORD PTR [ebx]
  00298	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0029c	d3 fa		 sar	 edx, cl

; 2553 : 				RESTORE_XCONTEXT

  0029e	83 c3 04	 add	 ebx, 4
  002a1	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2554 : 			} next;

  002a5	e9 bc fd ff ff	 jmp	 $L58091
$L58132:

; 193  :     		case DUP:		*--sp = tos;  next;

  002aa	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  002ae	83 eb 04	 sub	 ebx, 4
  002b1	89 03		 mov	 DWORD PTR [ebx], eax
  002b3	e9 ae fd ff ff	 jmp	 $L58091
$L58134:

; 194  :     		case DROP:		tos = *sp++;  next;
; 195  :     		case SWAP:		scr = *sp;    *sp = tos;      tos = scr;      next;

  002b8	8b 03		 mov	 eax, DWORD PTR [ebx]
  002ba	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  002be	89 13		 mov	 DWORD PTR [ebx], edx

; 2298 : 				push(scr);

  002c0	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  002c4	e9 9d fd ff ff	 jmp	 $L58091
$L58135:

; 196  :     		case OVER:		push (sp[1]); next;

  002c9	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  002cd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  002cf	83 eb 04	 sub	 ebx, 4
  002d2	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  002d6	89 03		 mov	 DWORD PTR [ebx], eax
  002d8	e9 89 fd ff ff	 jmp	 $L58091
$L58137:

; 197  :     		case ROT:		scr = tos;    tos = sp[1];    sp[1] = *sp;    *sp = scr;

  002dd	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  002e1	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  002e4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  002e6	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  002ea	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  002ed	89 03		 mov	 DWORD PTR [ebx], eax

; 198  : 			next;

  002ef	e9 72 fd ff ff	 jmp	 $L58091
$L58138:

; 199  :     		case PICK:		tos = sp[tos]; next;

  002f4	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  002f8	8b 04 93	 mov	 eax, DWORD PTR [ebx+edx*4]

; 2298 : 				push(scr);

  002fb	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  002ff	e9 62 fd ff ff	 jmp	 $L58091
$L58139:

; 200  :     		case QUES_DUP: if (tos) { *--sp = tos; }    next;

  00304	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00308	85 c0		 test	 eax, eax
  0030a	0f 84 56 fd ff
	ff		 je	 $L58091
  00310	83 eb 04	 sub	 ebx, 4
  00313	89 03		 mov	 DWORD PTR [ebx], eax
  00315	e9 4c fd ff ff	 jmp	 $L58091
$L58141:

; 201  :     		case TO_R:		*(cell *)--rp = pop;	    next;

  0031a	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  0031e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00322	83 e8 04	 sub	 eax, 4
  00325	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  00329	89 08		 mov	 DWORD PTR [eax], ecx
$L58288:
  0032b	8b 13		 mov	 edx, DWORD PTR [ebx]

; 2553 : 				RESTORE_XCONTEXT

  0032d	83 c3 04	 add	 ebx, 4
  00330	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2554 : 			} next;

  00334	e9 2d fd ff ff	 jmp	 $L58091
$L58143:

; 202  :     		case R_FROM:	push ( *(cell *)rp++ );    next;

  00339	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0033d	83 eb 04	 sub	 ebx, 4
  00340	89 03		 mov	 DWORD PTR [ebx], eax
  00342	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00346	8b 08		 mov	 ecx, DWORD PTR [eax]
  00348	83 c0 04	 add	 eax, 4
  0034b	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0034f	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  00353	e9 0e fd ff ff	 jmp	 $L58091
$L58146:

; 203  :     		case R_FETCH:	push ( *(cell *)rp );	    next;

  00358	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0035c	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00360	83 eb 04	 sub	 ebx, 4
  00363	89 13		 mov	 DWORD PTR [ebx], edx
  00365	8b 08		 mov	 ecx, DWORD PTR [eax]
  00367	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0036b	e9 f6 fc ff ff	 jmp	 $L58091
$L58149:

; 204  :     		/* We don't have to account for the tos in a register, because
; 205  :     		 * push has already pushed tos onto the stack before
; 206  :     		 * V_SPZERO - sp  is computed.
; 207  :     		 */
; 208  :     		case DEPTH:		push ( (cell *)V_SPZERO - sp ) ; next;

  00370	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00374	83 eb 04	 sub	 ebx, 4
  00377	89 13		 mov	 DWORD PTR [ebx], edx
  00379	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0037c	2b c3		 sub	 eax, ebx
  0037e	c1 f8 02	 sar	 eax, 2

; 2298 : 				push(scr);

  00381	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00385	e9 dc fc ff ff	 jmp	 $L58091
$L58152:

; 209  :     		case LESS:		bincmp (<);     next;

  0038a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0038c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00390	83 c3 04	 add	 ebx, 4
  00393	3b c8		 cmp	 ecx, eax
  00395	0f 8d fa 4e 00
	00		 jge	 $L58621
  0039b	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  003a3	e9 be fc ff ff	 jmp	 $L58091
$L58153:

; 210  : 			case EQUAL:		bincmp (==);    next;

  003a8	8b 13		 mov	 edx, DWORD PTR [ebx]
  003aa	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  003ae	83 c3 04	 add	 ebx, 4
  003b1	3b d0		 cmp	 edx, eax
  003b3	0f 85 dc 4e 00
	00		 jne	 $L58621
  003b9	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  003c1	e9 a0 fc ff ff	 jmp	 $L58091
$L58154:

; 211  :     		case GREATER:	bincmp (>);     next;

  003c6	8b 03		 mov	 eax, DWORD PTR [ebx]
  003c8	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  003cc	83 c3 04	 add	 ebx, 4
  003cf	3b c1		 cmp	 eax, ecx
  003d1	0f 8e be 4e 00
	00		 jle	 $L58621
  003d7	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  003df	e9 82 fc ff ff	 jmp	 $L58091
$L58155:

; 212  :     		case ZERO_LESS:	uncmp (<);      next;

  003e4	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  003e8	33 c9		 xor	 ecx, ecx
  003ea	85 d2		 test	 edx, edx
  003ec	0f 9d c1	 setge	 cl
  003ef	49		 dec	 ecx
  003f0	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  003f4	e9 6d fc ff ff	 jmp	 $L58091
$L58156:

; 213  :     		case ZERO_EQUAL:	uncmp (==);     next;

  003f9	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  003fd	f7 da		 neg	 edx
  003ff	1b d2		 sbb	 edx, edx
  00401	f7 da		 neg	 edx
  00403	4a		 dec	 edx
  00404	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  00408	e9 59 fc ff ff	 jmp	 $L58091
$L58157:

; 214  : 			case ZERO_GREATER:	uncmp (>);      next;

  0040d	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00411	33 c0		 xor	 eax, eax
  00413	85 d2		 test	 edx, edx
  00415	0f 9e c0	 setle	 al
  00418	48		 dec	 eax

; 2298 : 				push(scr);

  00419	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0041d	e9 44 fc ff ff	 jmp	 $L58091
$L58158:

; 215  :     		case U_LESS:	tos = ((u_cell) * sp++ < (u_cell) tos) ? -1 : 0; next;

  00422	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00424	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00428	83 c3 04	 add	 ebx, 4
  0042b	3b c8		 cmp	 ecx, eax
  0042d	0f 83 62 4e 00
	00		 jae	 $L58621
  00433	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  0043b	e9 26 fc ff ff	 jmp	 $L58091
$L58161:

; 216  :     		case ONE_PLUS:	tos++;	     next;

  00440	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00444	40		 inc	 eax

; 2298 : 				push(scr);

  00445	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00449	e9 18 fc ff ff	 jmp	 $L58091
$L58162:

; 217  :     		case TWO_PLUS:	tos += 2;     next;

  0044e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00452	83 c0 02	 add	 eax, 2

; 2298 : 				push(scr);

  00455	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00459	e9 08 fc ff ff	 jmp	 $L58091
$L58163:

; 218  :     		case TWO_MINUS:	tos -= 2;     next;

  0045e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00462	83 e8 02	 sub	 eax, 2

; 2298 : 				push(scr);

  00465	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00469	e9 f8 fb ff ff	 jmp	 $L58091
$L58164:

; 219  :     		case U_M_TIMES:
; 220  : 				lscr = (u_cell) *sp * (u_cell) tos;

  0046e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 221  : 				*sp = lscr;
; 222  : 				tos = (lscr < 0) ? -1 : 0 ;

  00470	33 d2		 xor	 edx, edx
  00472	0f af 44 24 0c	 imul	 eax, DWORD PTR _tos$[esp+304]
  00477	85 c0		 test	 eax, eax
  00479	0f 9d c2	 setge	 dl
  0047c	4a		 dec	 edx
  0047d	89 03		 mov	 DWORD PTR [ebx], eax
  0047f	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 223  : 			next;

  00483	e9 de fb ff ff	 jmp	 $L58091
$L58167:

; 224  : 			case TWO_DIVIDE:   tos >>= 1;    next;	   /* Should be signed */

  00488	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0048c	d1 f8		 sar	 eax, 1

; 2298 : 				push(scr);

  0048e	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00492	e9 cf fb ff ff	 jmp	 $L58091
$L58168:

; 225  :     		case PMAX:  scr = *sp++; if (tos < scr) { tos = scr; }    next;

  00497	8b 03		 mov	 eax, DWORD PTR [ebx]
  00499	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0049d	83 c3 04	 add	 ebx, 4
  004a0	3b c8		 cmp	 ecx, eax
  004a2	0f 8d be fb ff
	ff		 jge	 $L58091

; 2298 : 				push(scr);

  004a8	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  004ac	e9 b5 fb ff ff	 jmp	 $L58091
$L58170:

; 226  :     		case PMIN:  scr = *sp++; if (tos > scr) { tos = scr; }    next;

  004b1	8b 03		 mov	 eax, DWORD PTR [ebx]
  004b3	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  004b7	83 c3 04	 add	 ebx, 4
  004ba	3b c8		 cmp	 ecx, eax
  004bc	0f 8e a4 fb ff
	ff		 jle	 $L58091

; 2298 : 				push(scr);

  004c2	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  004c6	e9 9b fb ff ff	 jmp	 $L58091
$L58172:

; 227  :     		case ABS:			if (tos < 0)   { tos = -tos; }   next;

  004cb	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  004cf	85 c0		 test	 eax, eax
  004d1	0f 8d 8f fb ff
	ff		 jge	 $L58091
  004d7	f7 d8		 neg	 eax

; 2298 : 				push(scr);

  004d9	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  004dd	e9 84 fb ff ff	 jmp	 $L58091
$L58174:

; 228  :     		case NEGATE:  unop (-);		 next;

  004e2	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  004e6	f7 d8		 neg	 eax

; 2298 : 				push(scr);

  004e8	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  004ec	e9 75 fb ff ff	 jmp	 $L58091
$L58175:

; 229  :     		case FETCH:	  tos = *(cell *)tos;	 next;

  004f1	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  004f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  004f7	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  004fb	e9 66 fb ff ff	 jmp	 $L58091
$L58177:

; 230  :     		case C_FETCH: tos = *(u_char *)tos;	 next;

  00500	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00504	33 c0		 xor	 eax, eax
  00506	8a 01		 mov	 al, BYTE PTR [ecx]

; 2298 : 				push(scr);

  00508	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0050c	e9 55 fb ff ff	 jmp	 $L58091
$L58179:

; 231  :     		case W_FETCH: tos = *(unsigned short *)tos; next;

  00511	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00515	33 d2		 xor	 edx, edx
  00517	66 8b 10	 mov	 dx, WORD PTR [eax]
  0051a	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  0051e	e9 43 fb ff ff	 jmp	 $L58091
$L58181:

; 232  :     		case STORE:			*(cell *)  tos = *sp++; tos = *sp++;    next;

  00523	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00525	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00529	83 c3 04	 add	 ebx, 4
  0052c	89 0a		 mov	 DWORD PTR [edx], ecx

; 2553 : 				RESTORE_XCONTEXT

  0052e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00530	83 c3 04	 add	 ebx, 4
  00533	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  00537	e9 2a fb ff ff	 jmp	 $L58091
$L58183:

; 233  :     		case C_STORE:		*(u_char *)  tos = (u_char)*sp++; tos = *sp++;    next;

  0053c	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0053e	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00542	83 c3 04	 add	 ebx, 4
  00545	88 0a		 mov	 BYTE PTR [edx], cl

; 2553 : 				RESTORE_XCONTEXT

  00547	8b 03		 mov	 eax, DWORD PTR [ebx]
  00549	83 c3 04	 add	 ebx, 4
  0054c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  00550	e9 11 fb ff ff	 jmp	 $L58091
$L58186:

; 234  :     		case W_STORE:		*(unsigned short *) tos = (unsigned short)*sp++; tos = *sp++;    next;

  00555	66 8b 0b	 mov	 cx, WORD PTR [ebx]
  00558	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0055c	83 c3 04	 add	 ebx, 4
  0055f	66 89 0a	 mov	 WORD PTR [edx], cx

; 2553 : 				RESTORE_XCONTEXT

  00562	8b 03		 mov	 eax, DWORD PTR [ebx]
  00564	83 c3 04	 add	 ebx, 4
  00567	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  0056b	e9 f6 fa ff ff	 jmp	 $L58091
$L58189:

; 235  :     		case PLUS_STORE: *(cell *) tos += *sp++; tos = *sp++;    next;

  00570	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00574	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00576	83 c3 04	 add	 ebx, 4
  00579	8b 10		 mov	 edx, DWORD PTR [eax]
  0057b	03 d1		 add	 edx, ecx

; 2553 : 				RESTORE_XCONTEXT

  0057d	83 c3 04	 add	 ebx, 4
  00580	89 10		 mov	 DWORD PTR [eax], edx
  00582	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]
  00585	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2554 : 			} next;

  00589	e9 d8 fa ff ff	 jmp	 $L58091
$L58191:

; 236  :     		case CMOVE:
; 237  : 				ascr = (u_char *)*sp++;

  0058e	8b 03		 mov	 eax, DWORD PTR [ebx]

; 238  : 				ascr1 = (u_char *)*sp++;

  00590	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 239  : 				cmove(ascr1, ascr, (u_cell)tos);

  00593	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00597	83 c3 04	 add	 ebx, 4
  0059a	83 c3 04	 add	 ebx, 4
  0059d	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx
  005a1	85 d2		 test	 edx, edx
  005a3	0f 84 38 70 00
	00		 je	 $L58231

; 236  :     		case CMOVE:
; 237  : 				ascr = (u_char *)*sp++;

  005a9	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx

; 239  : 				cmove(ascr1, ascr, (u_cell)tos);

$L60696:
  005ad	8a 11		 mov	 dl, BYTE PTR [ecx]
  005af	88 10		 mov	 BYTE PTR [eax], dl
  005b1	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  005b5	40		 inc	 eax
  005b6	41		 inc	 ecx
  005b7	4a		 dec	 edx
  005b8	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  005bc	75 ef		 jne	 SHORT $L60696

; 2553 : 				RESTORE_XCONTEXT

  005be	8b 03		 mov	 eax, DWORD PTR [ebx]
  005c0	83 c3 04	 add	 ebx, 4
  005c3	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  005c7	e9 9a fa ff ff	 jmp	 $L58091
$L58195:

; 240  : 				tos = *sp++;
; 241  : 			next;
; 242  :     		case CMOVE_UP:
; 243  : 				ascr = (u_char *)*sp++;

  005cc	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 244  : 				ascr1 = (u_char *)*sp++;

  005ce	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 245  : 				cmove_up(ascr1, ascr, (u_cell)tos);

  005d1	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  005d5	83 c3 04	 add	 ebx, 4
  005d8	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  005dc	83 c3 04	 add	 ebx, 4
  005df	03 c2		 add	 eax, edx
  005e1	03 ca		 add	 ecx, edx
  005e3	85 d2		 test	 edx, edx
  005e5	0f 84 f6 6f 00
	00		 je	 $L58231

; 240  : 				tos = *sp++;
; 241  : 			next;
; 242  :     		case CMOVE_UP:
; 243  : 				ascr = (u_char *)*sp++;

  005eb	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx

; 245  : 				cmove_up(ascr1, ascr, (u_cell)tos);

$L60704:
  005ef	8a 50 ff	 mov	 dl, BYTE PTR [eax-1]
  005f2	48		 dec	 eax
  005f3	49		 dec	 ecx
  005f4	88 11		 mov	 BYTE PTR [ecx], dl
  005f6	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  005fa	4a		 dec	 edx
  005fb	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  005ff	75 ee		 jne	 SHORT $L60704

; 2553 : 				RESTORE_XCONTEXT

  00601	8b 03		 mov	 eax, DWORD PTR [ebx]
  00603	83 c3 04	 add	 ebx, 4
  00606	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  0060a	e9 57 fa ff ff	 jmp	 $L58091
$L58199:

; 246  : 				tos = *sp++;
; 247  : 			next;
; 248  :     		case FILL: 
; 249  : 				scr = *sp++;

  0060f	8b 03		 mov	 eax, DWORD PTR [ebx]

; 250  : 				ascr = (u_char *)*sp++;

  00611	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00614	83 c3 04	 add	 ebx, 4
  00617	83 c3 04	 add	 ebx, 4

; 251  : 				fill((u_char *)ascr, (u_cell)scr, (u_char)tos);

  0061a	85 c0		 test	 eax, eax
  0061c	0f 84 bf 6f 00
	00		 je	 $L58231
  00622	8d 08		 lea	 ecx, DWORD PTR [eax]
  00624	8a 44 24 0c	 mov	 al, BYTE PTR _tos$[esp+304]
  00628	8b fa		 mov	 edi, edx
  0062a	8a d0		 mov	 dl, al
  0062c	8a f2		 mov	 dh, dl
  0062e	8b f1		 mov	 esi, ecx
  00630	8b c2		 mov	 eax, edx
  00632	c1 e0 10	 shl	 eax, 16			; 00000010H
  00635	66 8b c2	 mov	 ax, dx
  00638	c1 e9 02	 shr	 ecx, 2
  0063b	f3 ab		 rep stosd
  0063d	8b ce		 mov	 ecx, esi
  0063f	8b 74 24 24	 mov	 esi, DWORD PTR _fsp$[esp+304]
  00643	83 e1 03	 and	 ecx, 3

; 2553 : 				RESTORE_XCONTEXT

  00646	83 c3 04	 add	 ebx, 4
  00649	f3 aa		 rep stosb
  0064b	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  0064e	8b 7c 24 28	 mov	 edi, DWORD PTR _up$[esp+304]
  00652	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  00656	e9 0b fa ff ff	 jmp	 $L58091
$L58204:

; 252  : 				tos = *sp++;
; 253  : 			next;
; 254  : 			case COUNT: 
; 255  : 				*--sp = (cell)(tos + 1);

  0065b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0065f	83 eb 04	 sub	 ebx, 4

; 256  : 				ascr = (u_char *) tos;
; 257  : 				tos = (cell)(*ascr);

  00662	33 d2		 xor	 edx, edx
  00664	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00667	89 0b		 mov	 DWORD PTR [ebx], ecx
  00669	8a 10		 mov	 dl, BYTE PTR [eax]
  0066b	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 258  : 			next;

  0066f	e9 f2 f9 ff ff	 jmp	 $L58091
$L58208:

; 259  : 			case DASH_TRAILING: 
; 260  : 				ascr = (u_char *) (*sp + tos);

  00674	8b 03		 mov	 eax, DWORD PTR [ebx]
  00676	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0067a	03 c1		 add	 eax, ecx

; 261  : 				tos++;
; 262  : 				while ((--tos != 0) && (*--ascr == ' ')) {}

  0067c	85 c9		 test	 ecx, ecx
  0067e	0f 84 e2 f9 ff
	ff		 je	 $L58091
$L58211:
  00684	8a 50 ff	 mov	 dl, BYTE PTR [eax-1]
  00687	48		 dec	 eax
  00688	80 fa 20	 cmp	 dl, 32			; 00000020H
  0068b	0f 85 d5 f9 ff
	ff		 jne	 $L58091
  00691	49		 dec	 ecx
  00692	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  00696	75 ec		 jne	 SHORT $L58211

; 263  : 				next;

  00698	e9 c9 f9 ff ff	 jmp	 $L58091
$L58213:

; 264  : 			case PAREN:	SAVE_XCONTEXT

  0069d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  006a1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  006a5	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  006a9	83 eb 04	 sub	 ebx, 4
  006ac	83 ee 08	 sub	 esi, 8
  006af	89 03		 mov	 DWORD PTR [ebx], eax
  006b1	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  006b5	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  006bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  006c1	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  006c5	89 16		 mov	 DWORD PTR [esi], edx
  006c7	89 46 04	 mov	 DWORD PTR [esi+4], eax
  006ca	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  006d0	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  006d6	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 265  : 				(void)word(')');

  006dc	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  006e2	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  006e5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  006e8	03 f1		 add	 esi, ecx
  006ea	03 c1		 add	 eax, ecx
  006ec	b9 01 00 00 00	 mov	 ecx, 1
  006f1	3b c6		 cmp	 eax, esi
  006f3	73 1d		 jae	 SHORT $L61775
$L60724:
  006f5	33 d2		 xor	 edx, edx
  006f7	8a 10		 mov	 dl, BYTE PTR [eax]
  006f9	40		 inc	 eax
  006fa	83 fa 29	 cmp	 edx, 41			; 00000029H
  006fd	74 1c		 je	 SHORT $L61776
  006ff	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00705	7d 07		 jge	 SHORT $L60729
  00707	88 91 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], dl
  0070d	41		 inc	 ecx
$L60729:
  0070e	3b c6		 cmp	 eax, esi
  00710	72 e3		 jb	 SHORT $L60724
$L61775:
  00712	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1
  00719	eb 03		 jmp	 SHORT $finish$60727
$L61776:
  0071b	89 57 20	 mov	 DWORD PTR [edi+32], edx
$finish$60727:
  0071e	8a d1		 mov	 dl, cl
  00720	fe ca		 dec	 dl
  00722	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  00728	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  0072f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  00735	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  0073b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 338  : 				type( (u_char *) scr, scr1);

$L60780:
  0073e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  00744	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  00749	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0074f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  00755	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00757	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0075a	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  0075e	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  00763	83 c6 08	 add	 esi, 8
  00766	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  0076a	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  0076e	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  00772	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  00776	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
$L58133:
  0077a	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2553 : 				RESTORE_XCONTEXT

  0077c	83 c3 04	 add	 ebx, 4
  0077f	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2554 : 			} next;

  00783	e9 de f8 ff ff	 jmp	 $L58091
$L58215:

; 266  : 				RESTORE_XCONTEXT
; 267  : 				next;
; 268  : 			case BACKSLASH:  if (V_DELIMITER != '\n') { 

  00788	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0078b	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  0078e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00791	0f 84 cf f8 ff
	ff		 je	 $L58091

; 269  : 				SAVE_XCONTEXT (void)word('\n'); RESTORE_XCONTEXT }	 next;

  00797	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0079b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  0079f	83 eb 04	 sub	 ebx, 4
  007a2	83 ee 08	 sub	 esi, 8
  007a5	89 03		 mov	 DWORD PTR [ebx], eax
  007a7	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  007ab	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  007b1	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  007b7	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  007bb	89 06		 mov	 DWORD PTR [esi], eax
  007bd	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  007c1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  007c4	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  007ca	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  007d0	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  007d5	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  007db	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  007de	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  007e1	03 c8		 add	 ecx, eax
  007e3	03 f8		 add	 edi, eax
  007e5	3b f9		 cmp	 edi, ecx
  007e7	b8 01 00 00 00	 mov	 eax, 1
  007ec	73 1c		 jae	 SHORT $L61777
$L60738:
  007ee	33 db		 xor	 ebx, ebx
  007f0	8a 1f		 mov	 bl, BYTE PTR [edi]
  007f2	47		 inc	 edi
  007f3	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  007f6	74 1a		 je	 SHORT $L61778
  007f8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007fd	7d 07		 jge	 SHORT $L60743
  007ff	88 98 00 00 00
	00		 mov	 BYTE PTR _wordbuf[eax], bl
  00805	40		 inc	 eax
$L60743:
  00806	3b f9		 cmp	 edi, ecx
  00808	72 e4		 jb	 SHORT $L60738
$L61777:
  0080a	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  00810	eb 02		 jmp	 SHORT $finish$60741
$L61778:
  00812	89 1a		 mov	 DWORD PTR [edx], ebx
$finish$60741:
  00814	8a c8		 mov	 cl, al
  00816	fe c9		 dec	 cl
  00818	88 0d 00 00 00
	00		 mov	 BYTE PTR _wordbuf, cl
  0081e	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[eax], 0
  00825	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0082a	2b b8 8c 00 00
	00		 sub	 edi, DWORD PTR [eax+140]
  00830	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00833	e9 6b 6d 00 00	 jmp	 $L60948
$L58218:

; 270  : 			case I:    push ( ((cell *)rp)[0] + ((cell *)rp)[1] );	next;

  00838	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0083c	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00840	83 eb 04	 sub	 ebx, 4
  00843	89 0b		 mov	 DWORD PTR [ebx], ecx
  00845	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00848	03 10		 add	 edx, DWORD PTR [eax]
  0084a	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  0084e	e9 13 f8 ff ff	 jmp	 $L58091
$L58222:

; 271  : 			case J:    push ( ((cell *)rp)[3] + ((cell *)rp)[4] );	next;

  00853	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00857	83 eb 04	 sub	 ebx, 4
  0085a	89 03		 mov	 DWORD PTR [ebx], eax
  0085c	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00860	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00863	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00866	03 ca		 add	 ecx, edx
  00868	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0086c	e9 f5 f7 ff ff	 jmp	 $L58091
$L58226:

; 272  : 			case BRANCH:       branch;	     next;

  00871	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  00874	8b 10		 mov	 edx, DWORD PTR [eax]
  00876	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00879	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  0087c	e9 e5 f7 ff ff	 jmp	 $L58091
$L58228:

; 273  : /* The speedup achievable by storing byte branch offsets is insignificant */
; 274  : 			case QUES_BRANCH:
; 275  : 				if (tos == 0) {

  00881	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00885	85 c0		 test	 eax, eax

; 276  : 					branch;

  00887	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  0088a	75 17		 jne	 SHORT $L58229
  0088c	8b 08		 mov	 ecx, DWORD PTR [eax]

; 2553 : 				RESTORE_XCONTEXT

  0088e	83 c3 04	 add	 ebx, 4
  00891	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00894	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  00897	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  0089a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  0089e	e9 c3 f7 ff ff	 jmp	 $L58091
$L58229:

; 277  : 				} else {
; 278  : 					/* Pointer alignment */
; 279  : 					ip = (token_t *)(((char *)ip) + sizeof(cell));

  008a3	83 c0 04	 add	 eax, 4

; 2553 : 				RESTORE_XCONTEXT

  008a6	83 c3 04	 add	 ebx, 4
  008a9	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  008ac	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  008af	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  008b3	e9 ae f7 ff ff	 jmp	 $L58091
$L58235:

; 280  : 				}
; 281  : 				tos = *sp++;
; 282  : 				next;
; 283  : 			case UNNEST:
; 284  : 			case EXIT:	       ip = *rp++;     next;

  008b8	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  008bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  008be	83 c0 04	 add	 eax, 4
  008c1	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx
  008c4	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  008c8	e9 99 f7 ff ff	 jmp	 $L58091
$L58242:

; 290  : 
; 291  : 			case INTERPLINE:
; 292  : 				SAVE_XCONTEXT

  008cd	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  008d1	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  008d5	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  008d9	83 eb 04	 sub	 ebx, 4
  008dc	83 ee 08	 sub	 esi, 8
  008df	89 13		 mov	 DWORD PTR [ebx], edx
  008e1	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  008e5	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  008eb	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  008f0	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  008f4	89 0e		 mov	 DWORD PTR [esi], ecx
  008f6	89 56 04	 mov	 DWORD PTR [esi+4], edx
  008f9	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  008ff	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00905	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax

; 293  : 				interpret_line();

  0090a	e8 00 00 00 00	 call	 _prompt
  0090f	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  00914	8d 8c 24 f0 00
	00 00		 lea	 ecx, DWORD PTR _CFABuff$60759[esp+304]
  0091b	83 e8 04	 sub	 eax, 4
  0091e	51		 push	 ecx
  0091f	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  00924	c7 84 24 f4 00
	00 00 3c 00 00
	00		 mov	 DWORD PTR _CFABuff$60759[esp+308], 60 ; 0000003cH
  0092f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_tibbuf
  00935	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  0093a	83 e8 04	 sub	 eax, 4
  0093d	c7 84 24 f8 00
	00 00 69 00 00
	00		 mov	 DWORD PTR _CFABuff$60759[esp+312], 105 ; 00000069H
  00948	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  0094d	c7 00 00 01 00
	00		 mov	 DWORD PTR [eax], 256	; 00000100H
  00953	e8 00 00 00 00	 call	 _inner_interpreter
  00958	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0095d	83 c4 04	 add	 esp, 4
  00960	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00963	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00966	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0096b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 554  : 	/* Yes, it is correct that there is no "next" here */
; 555  :     case BRAC_COMPILE: 
; 556  : 	SAVE_XCONTEXT scompile(canonical(blword ())); RESTORE_XCONTEXT next;

$L61519:
  00972	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  00978	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  0097e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  00984	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0098a	8b 16		 mov	 edx, DWORD PTR [esi]
  0098c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0098f	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  00993	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  00999	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  0099d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0099f	83 c6 08	 add	 esi, 8
  009a2	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  009a6	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  009aa	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  009ae	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  009b2	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2553 : 				RESTORE_XCONTEXT

  009b6	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  009b9	e9 a8 f6 ff ff	 jmp	 $L58091
$L58243:

; 294  : 				RESTORE_XCONTEXT
; 295  : 				next;
; 296  : 
; 297  : 			case KEY:
; 298  : #if 1
; 299  : 				if (multitasking && !key_avail()) {

  009be	a1 00 00 00 00	 mov	 eax, DWORD PTR _multitasking
  009c3	85 c0		 test	 eax, eax
  009c5	74 31		 je	 SHORT $L58244
  009c7	e8 00 00 00 00	 call	 _key_avail
  009cc	85 c0		 test	 eax, eax
  009ce	75 28		 jne	 SHORT $L58244

; 300  : 					--ip;

  009d0	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  009d3	83 e8 04	 sub	 eax, 4
  009d6	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 301  : 					if (*ip == EXECUTE) {

  009d9	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  009dc	0f 85 51 68 00
	00		 jne	 $pause$58247

; 302  : 						push(KEY);	/* Don't delete braces; push is a macro */

  009e2	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  009e6	83 eb 04	 sub	 ebx, 4
  009e9	c7 44 24 0c 35
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 53 ; 00000035H
  009f1	89 03		 mov	 DWORD PTR [ebx], eax

; 303  : 					}
; 304  : 					goto pause;

  009f3	e9 3b 68 00 00	 jmp	 $pause$58247
$L58244:

; 305  : 				}
; 306  : 				push (key());

  009f8	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  009fc	83 eb 04	 sub	 ebx, 4
  009ff	89 0b		 mov	 DWORD PTR [ebx], ecx
  00a01	e8 00 00 00 00	 call	 _key

; 2298 : 				push(scr);

  00a06	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00a0a	e9 57 f6 ff ff	 jmp	 $L58091
$L58249:

; 307  : 				next;
; 308  : #else
; 309  : 				if (key_avail()) { push (key()); next; }
; 310  : 				if (multitasking) {
; 311  : 					--ip;
; 312  : 					if (*ip == EXECUTE) {
; 313  : 						push(KEY);	/* Don't delete braces; push is a macro */
; 314  : 					}
; 315  : 					goto pause;
; 316  : 				}
; 317  : #endif
; 318  : 			case KEY_QUESTION:
; 319  : 				SAVE_XCONTEXT

  00a0f	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00a13	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00a17	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  00a1b	83 eb 04	 sub	 ebx, 4
  00a1e	83 ee 08	 sub	 esi, 8
  00a21	89 13		 mov	 DWORD PTR [ebx], edx
  00a23	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  00a27	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00a2d	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  00a32	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  00a36	89 0e		 mov	 DWORD PTR [esi], ecx
  00a38	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00a3b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  00a41	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00a47	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax

; 320  : 				MemeOften();

  00a4c	e8 00 00 00 00	 call	 _MemeOften

; 321  : 				RESTORE_XCONTEXT

  00a51	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  00a57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  00a5d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  00a63	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  00a69	8b 16		 mov	 edx, DWORD PTR [esi]
  00a6b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00a6e	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  00a72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  00a78	83 c6 08	 add	 esi, 8
  00a7b	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  00a7f	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  00a83	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  00a87	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  00a8b	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx

; 322  : 				push ( key_avail() );

  00a8f	e8 00 00 00 00	 call	 _key_avail

; 2298 : 				push(scr);

  00a94	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00a98	e9 c9 f5 ff ff	 jmp	 $L58091
$L58251:

; 323  : 				next;
; 324  : 			case EMIT:		scr = pop; SAVE_XCONTEXT emit ((u_char)scr);     

  00a9d	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  00aa1	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  00aa5	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  00aa9	83 ee 08	 sub	 esi, 8
  00aac	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00ab2	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  00ab8	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  00abc	89 06		 mov	 DWORD PTR [esi], eax
  00abe	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00ac2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00ac5	50		 push	 eax
  00ac6	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  00acc	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00ad2	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  00ad8	e8 00 00 00 00	 call	 _emit
  00add	83 c4 04	 add	 esp, 4

; 325  : 							RESTORE_XCONTEXT next;

  00ae0	e9 8d fe ff ff	 jmp	 $L61519
$L58253:

; 326  : 			case CR: SAVE_XCONTEXT emit ('\n'); RESTORE_XCONTEXT next;

  00ae5	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00ae9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  00aed	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  00af1	83 eb 04	 sub	 ebx, 4
  00af4	83 ee 08	 sub	 esi, 8
  00af7	6a 0a		 push	 10			; 0000000aH
  00af9	89 03		 mov	 DWORD PTR [ebx], eax
  00afb	8b 44 24 18	 mov	 eax, DWORD PTR _ftos$[esp+312]
  00aff	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00b05	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  00b0b	8b 4c 24 24	 mov	 ecx, DWORD PTR _frp$[esp+308]
  00b0f	89 16		 mov	 DWORD PTR [esi], edx
  00b11	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00b14	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  00b1a	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00b20	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  00b26	e8 00 00 00 00	 call	 _emit
  00b2b	83 c4 04	 add	 esp, 4
  00b2e	e9 70 6a 00 00	 jmp	 $L60948
$L58254:

; 327  : 			case DOT_PAREN: 
; 328  : 				SAVE_XCONTEXT

  00b33	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00b37	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  00b3b	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  00b3f	83 eb 04	 sub	 ebx, 4
  00b42	83 ee 08	 sub	 esi, 8
  00b45	89 0b		 mov	 DWORD PTR [ebx], ecx
  00b47	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  00b4b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00b51	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  00b57	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  00b5b	89 06		 mov	 DWORD PTR [esi], eax
  00b5d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00b60	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  00b66	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00b6c	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx

; 329  : 				ascr = word (')');

  00b72	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  00b78	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  00b7b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00b7e	03 f1		 add	 esi, ecx
  00b80	03 c1		 add	 eax, ecx
  00b82	b9 01 00 00 00	 mov	 ecx, 1
  00b87	3b c6		 cmp	 eax, esi
  00b89	73 1d		 jae	 SHORT $L61779
$L60770:
  00b8b	33 d2		 xor	 edx, edx
  00b8d	8a 10		 mov	 dl, BYTE PTR [eax]
  00b8f	40		 inc	 eax
  00b90	83 fa 29	 cmp	 edx, 41			; 00000029H
  00b93	74 1c		 je	 SHORT $L61780
  00b95	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00b9b	7d 07		 jge	 SHORT $L60775
  00b9d	88 91 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], dl
  00ba3	41		 inc	 ecx
$L60775:
  00ba4	3b c6		 cmp	 eax, esi
  00ba6	72 e3		 jb	 SHORT $L60770
$L61779:
  00ba8	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1
  00baf	eb 03		 jmp	 SHORT $finish$60773
$L61780:
  00bb1	89 57 20	 mov	 DWORD PTR [edi+32], edx
$finish$60773:
  00bb4	8a d1		 mov	 dl, cl
  00bb6	fe ca		 dec	 dl
  00bb8	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  00bbe	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  00bc5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  00bcb	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  00bd1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 330  : 				RESTORE_XCONTEXT

  00bd4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  00bda	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  00be0	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  00be5	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00be8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00bea	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup

; 331  : 				push( &ascr[1] );
; 332  : 				push( *ascr );

  00bf0	83 eb 04	 sub	 ebx, 4
  00bf3	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  00bf7	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  00bfb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  00c01	83 c6 08	 add	 esi, 8
  00c04	33 c0		 xor	 eax, eax
  00c06	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:_wordbuf+1
  00c0c	a0 00 00 00 00	 mov	 al, BYTE PTR _wordbuf
  00c11	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  00c15	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  00c19	eb 04		 jmp	 SHORT $L58257
$L61904:
  00c1b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
$L58257:

; 333  : 				/* Fall through */
; 334  : 			case TYPE: {
; 335  : 				cell scr1;
; 336  : 				scr1 = pop; scr = pop;

  00c1f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00c21	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00c25	83 c3 04	 add	 ebx, 4

; 337  : 				SAVE_XCONTEXT

  00c28	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  00c2e	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  00c32	83 ee 08	 sub	 esi, 8
  00c35	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00c3b	8b 5c 24 14	 mov	 ebx, DWORD PTR _ftos$[esp+308]
  00c3f	89 16		 mov	 DWORD PTR [esi], edx
  00c41	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  00c45	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00c48	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi

; 338  : 				type( (u_char *) scr, scr1);

  00c4e	85 c0		 test	 eax, eax
  00c50	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00c56	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  00c5c	8b f1		 mov	 esi, ecx
  00c5e	0f 84 da fa ff
	ff		 je	 $L60780

; 333  : 				/* Fall through */
; 334  : 			case TYPE: {
; 335  : 				cell scr1;
; 336  : 				scr1 = pop; scr = pop;

  00c64	8d 38		 lea	 edi, DWORD PTR [eax]

; 338  : 				type( (u_char *) scr, scr1);

$L60779:
  00c66	8a 06		 mov	 al, BYTE PTR [esi]
  00c68	46		 inc	 esi
  00c69	50		 push	 eax
  00c6a	e8 00 00 00 00	 call	 _emit
  00c6f	83 c4 04	 add	 esp, 4
  00c72	4f		 dec	 edi
  00c73	75 f1		 jne	 SHORT $L60779

; 339  : 				RESTORE_XCONTEXT
; 340  : 			} next;

  00c75	e9 c4 fa ff ff	 jmp	 $L60780
$L58260:

; 341  : 			case TO_BODY:      tos += sizeof (cell);   next;

  00c7a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  00c7e	83 c0 04	 add	 eax, 4

; 2298 : 				push(scr);

  00c81	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  00c85	e9 dc f3 ff ff	 jmp	 $L58091
$L58262:

; 342  : 			case ALLOT:
; 343  : 				V_DP = (cell)((cell *)((char *)DP + tos));	/* Ptr alignment */

  00c8a	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00c8e	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  00c91	03 c2		 add	 eax, edx

; 344  : 				tos = *sp++;

  00c93	83 c3 04	 add	 ebx, 4
  00c96	89 47 70	 mov	 DWORD PTR [edi+112], eax
  00c99	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 345  : 				/* The following cast is necessary for Turbo C in huge model */
; 346  : 				if ((u_cell)DP > (u_cell)dict_end && V_MOD_COMP == 0)

  00c9c	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00c9f	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  00ca3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _dict_end
  00ca9	0f 86 af f3 ff
	ff		 jbe	 $L61881
  00caf	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00cb5	85 c0		 test	 eax, eax
  00cb7	0f 85 a1 f3 ff
	ff		 jne	 $L61881

; 347  : 					error( "Out of dictionary space\n" );

  00cbd	68 00 00 00 00	 push	 OFFSET FLAT:$SG58271
  00cc2	e8 00 00 00 00	 call	 _error
  00cc7	83 c4 04	 add	 esp, 4

; 348  : 				next;

  00cca	e9 97 f3 ff ff	 jmp	 $L58091
$L58272:

; 349  : 			case FIND:	push ( find (sp) );	   next;

  00ccf	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00cd3	83 eb 04	 sub	 ebx, 4
  00cd6	33 c0		 xor	 eax, eax
  00cd8	89 13		 mov	 DWORD PTR [ebx], edx
  00cda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
  00ce0	85 c9		 test	 ecx, ecx
  00ce2	a3 00 00 00 00	 mov	 DWORD PTR _locnum, eax
  00ce7	7e 72		 jle	 SHORT $L60835
$L60834:
  00ce9	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00cec	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00cef	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR _locnames[edx*4]
  00cf6	33 d2		 xor	 edx, edx
  00cf8	8a 11		 mov	 dl, BYTE PTR [ecx]
  00cfa	41		 inc	 ecx
  00cfb	89 4c 24 30	 mov	 DWORD PTR _s$60830[esp+304], ecx
  00cff	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00d03	89 54 24 2c	 mov	 DWORD PTR _length$60832[esp+304], edx
  00d07	33 d2		 xor	 edx, edx
  00d09	8a 11		 mov	 dl, BYTE PTR [ecx]
  00d0b	41		 inc	 ecx
  00d0c	89 4c 24 34	 mov	 DWORD PTR _p$60831[esp+304], ecx
  00d10	8b 4c 24 2c	 mov	 ecx, DWORD PTR _length$60832[esp+304]
  00d14	3b d1		 cmp	 edx, ecx
  00d16	75 33		 jne	 SHORT $nextword$60837
$L60838:
  00d18	8b 44 24 2c	 mov	 eax, DWORD PTR _length$60832[esp+304]
  00d1c	8b c8		 mov	 ecx, eax
  00d1e	48		 dec	 eax
  00d1f	85 c9		 test	 ecx, ecx
  00d21	89 44 24 2c	 mov	 DWORD PTR _length$60832[esp+304], eax
  00d25	74 38		 je	 SHORT $L60839
  00d27	8b 54 24 30	 mov	 edx, DWORD PTR _s$60830[esp+304]
  00d2b	8b 44 24 34	 mov	 eax, DWORD PTR _p$60831[esp+304]
  00d2f	40		 inc	 eax
  00d30	8a 0a		 mov	 cl, BYTE PTR [edx]
  00d32	8a 50 ff	 mov	 dl, BYTE PTR [eax-1]
  00d35	89 44 24 34	 mov	 DWORD PTR _p$60831[esp+304], eax
  00d39	8b 44 24 30	 mov	 eax, DWORD PTR _s$60830[esp+304]
  00d3d	40		 inc	 eax
  00d3e	3a ca		 cmp	 cl, dl
  00d40	89 44 24 30	 mov	 DWORD PTR _s$60830[esp+304], eax
  00d44	74 d2		 je	 SHORT $L60838
  00d46	a1 00 00 00 00	 mov	 eax, DWORD PTR _locnum
$nextword$60837:
  00d4b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
  00d51	40		 inc	 eax
  00d52	3b c1		 cmp	 eax, ecx
  00d54	a3 00 00 00 00	 mov	 DWORD PTR _locnum, eax
  00d59	7c 8e		 jl	 SHORT $L60834
$L60835:
  00d5b	33 d2		 xor	 edx, edx
  00d5d	eb 13		 jmp	 SHORT $L60865
$L60839:
  00d5f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:_lnamebuf
  00d65	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 1
  00d6d	e9 f4 f2 ff ff	 jmp	 $L58091
$L60865:
  00d72	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00d77	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _last_voc$60864[esp+304], 0
  00d7f	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
$L60866:
  00d83	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  00d88	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00d8b	85 c0		 test	 eax, eax
  00d8d	89 44 24 5c	 mov	 DWORD PTR _voc$60863[esp+304], eax
  00d91	0f 84 c9 00 00
	00		 je	 $L60867
  00d97	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _origin
  00d9d	0f 84 bd 00 00
	00		 je	 $L60867
  00da3	3b 44 24 2c	 cmp	 eax, DWORD PTR _last_voc$60864[esp+304]
  00da7	0f 84 a7 00 00
	00		 je	 $L60871
  00dad	8b c8		 mov	 ecx, eax
  00daf	8b 13		 mov	 edx, DWORD PTR [ebx]
  00db1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00db4	89 44 24 34	 mov	 DWORD PTR _dictp$60851[esp+304], eax
  00db8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00dba	85 c9		 test	 ecx, ecx
  00dbc	89 4c 24 0c	 mov	 DWORD PTR -292+[esp+304], ecx
  00dc0	74 6e		 je	 SHORT $L60854
  00dc2	33 c9		 xor	 ecx, ecx
  00dc4	8a 0a		 mov	 cl, BYTE PTR [edx]
  00dc6	42		 inc	 edx
  00dc7	89 4c 24 50	 mov	 DWORD PTR -224+[esp+304], ecx
  00dcb	89 54 24 70	 mov	 DWORD PTR -192+[esp+304], edx
$L60853:
  00dcf	8d 50 05	 lea	 edx, DWORD PTR [eax+5]
  00dd2	33 c9		 xor	 ecx, ecx
  00dd4	8a 0a		 mov	 cl, BYTE PTR [edx]
  00dd6	42		 inc	 edx
  00dd7	89 54 24 2c	 mov	 DWORD PTR _s$60847[esp+304], edx
  00ddb	8b 54 24 70	 mov	 edx, DWORD PTR -192+[esp+304]
  00ddf	89 54 24 30	 mov	 DWORD PTR _p$60848[esp+304], edx
  00de3	8b 54 24 50	 mov	 edx, DWORD PTR -224+[esp+304]
  00de7	3b d1		 cmp	 edx, ecx
  00de9	75 33		 jne	 SHORT $nextword$60856
  00deb	eb 08		 jmp	 SHORT $L60857
$L61906:
  00ded	8b 4c 24 40	 mov	 ecx, DWORD PTR _length$60849[esp+304]
  00df1	8b 44 24 34	 mov	 eax, DWORD PTR _dictp$60851[esp+304]
$L60857:
  00df5	8b d1		 mov	 edx, ecx
  00df7	49		 dec	 ecx
  00df8	85 d2		 test	 edx, edx
  00dfa	89 4c 24 40	 mov	 DWORD PTR _length$60849[esp+304], ecx
  00dfe	74 34		 je	 SHORT $L60858
  00e00	8b 44 24 2c	 mov	 eax, DWORD PTR _s$60847[esp+304]
  00e04	8a 08		 mov	 cl, BYTE PTR [eax]
  00e06	8b 44 24 30	 mov	 eax, DWORD PTR _p$60848[esp+304]
  00e0a	8a 10		 mov	 dl, BYTE PTR [eax]
  00e0c	40		 inc	 eax
  00e0d	89 44 24 30	 mov	 DWORD PTR _p$60848[esp+304], eax
  00e11	8b 44 24 2c	 mov	 eax, DWORD PTR _s$60847[esp+304]
  00e15	40		 inc	 eax
  00e16	3a ca		 cmp	 cl, dl
  00e18	89 44 24 2c	 mov	 DWORD PTR _s$60847[esp+304], eax
  00e1c	74 cf		 je	 SHORT $L61906
$nextword$60856:
  00e1e	8b 44 24 0c	 mov	 eax, DWORD PTR -292+[esp+304]
  00e22	89 44 24 34	 mov	 DWORD PTR _dictp$60851[esp+304], eax
  00e26	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e28	85 c9		 test	 ecx, ecx
  00e2a	89 4c 24 0c	 mov	 DWORD PTR -292+[esp+304], ecx
  00e2e	75 9f		 jne	 SHORT $L60853
$L60854:
  00e30	33 d2		 xor	 edx, edx
  00e32	eb 20		 jmp	 SHORT $L60871
$L60858:
  00e34	33 c9		 xor	 ecx, ecx
  00e36	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00e39	8d 54 01 09	 lea	 edx, DWORD PTR [ecx+eax+9]
  00e3d	83 e2 fc	 and	 edx, -4			; fffffffcH
  00e40	89 13		 mov	 DWORD PTR [ebx], edx
  00e42	8a 50 04	 mov	 dl, BYTE PTR [eax+4]
  00e45	80 e2 01	 and	 dl, 1
  00e48	f6 da		 neg	 dl
  00e4a	1b d2		 sbb	 edx, edx
  00e4c	83 e2 02	 and	 edx, 2
  00e4f	4a		 dec	 edx
  00e50	85 d2		 test	 edx, edx
  00e52	75 1f		 jne	 SHORT $L61783
$L60871:
  00e54	8b 44 24 5c	 mov	 eax, DWORD PTR _voc$60863[esp+304]
  00e58	8b 4c 24 38	 mov	 ecx, DWORD PTR -248+[esp+304]
  00e5c	89 44 24 2c	 mov	 DWORD PTR _last_voc$60864[esp+304], eax
$L60867:
  00e60	83 c1 04	 add	 ecx, 4
  00e63	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00e69	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
  00e6d	0f 8c 10 ff ff
	ff		 jl	 $L60866
$L61783:
  00e73	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  00e77	e9 ea f1 ff ff	 jmp	 $L58091
$L58274:

; 350  : 			case VFIND: tos = vfind ((u_char **)sp, (vocabulary_t *)tos); next;

  00e7c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  00e80	8b 13		 mov	 edx, DWORD PTR [ebx]
  00e82	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00e85	89 44 24 5c	 mov	 DWORD PTR _dictp$60892[esp+304], eax
  00e89	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e8b	85 c9		 test	 ecx, ecx
  00e8d	89 4c 24 30	 mov	 DWORD PTR -256+[esp+304], ecx
  00e91	0f 84 fe 43 00
	00		 je	 $L58621
  00e97	33 c9		 xor	 ecx, ecx
  00e99	8a 0a		 mov	 cl, BYTE PTR [edx]
  00e9b	42		 inc	 edx
  00e9c	89 4c 24 50	 mov	 DWORD PTR -224+[esp+304], ecx
  00ea0	89 54 24 40	 mov	 DWORD PTR -240+[esp+304], edx
$L60894:
  00ea4	8d 50 05	 lea	 edx, DWORD PTR [eax+5]
  00ea7	33 c9		 xor	 ecx, ecx
  00ea9	8a 0a		 mov	 cl, BYTE PTR [edx]
  00eab	42		 inc	 edx
  00eac	89 54 24 2c	 mov	 DWORD PTR _s$60888[esp+304], edx
  00eb0	8b 54 24 40	 mov	 edx, DWORD PTR -240+[esp+304]
  00eb4	89 54 24 38	 mov	 DWORD PTR _p$60889[esp+304], edx
  00eb8	8b 54 24 50	 mov	 edx, DWORD PTR -224+[esp+304]
  00ebc	3b d1		 cmp	 edx, ecx
  00ebe	75 33		 jne	 SHORT $nextword$60897
  00ec0	eb 08		 jmp	 SHORT $L60898
$L61907:
  00ec2	8b 4c 24 70	 mov	 ecx, DWORD PTR _length$60890[esp+304]
  00ec6	8b 44 24 5c	 mov	 eax, DWORD PTR _dictp$60892[esp+304]
$L60898:
  00eca	8b d1		 mov	 edx, ecx
  00ecc	49		 dec	 ecx
  00ecd	85 d2		 test	 edx, edx
  00ecf	89 4c 24 70	 mov	 DWORD PTR _length$60890[esp+304], ecx
  00ed3	74 39		 je	 SHORT $L60899
  00ed5	8b 44 24 2c	 mov	 eax, DWORD PTR _s$60888[esp+304]
  00ed9	8a 08		 mov	 cl, BYTE PTR [eax]
  00edb	8b 44 24 38	 mov	 eax, DWORD PTR _p$60889[esp+304]
  00edf	8a 10		 mov	 dl, BYTE PTR [eax]
  00ee1	40		 inc	 eax
  00ee2	89 44 24 38	 mov	 DWORD PTR _p$60889[esp+304], eax
  00ee6	8b 44 24 2c	 mov	 eax, DWORD PTR _s$60888[esp+304]
  00eea	40		 inc	 eax
  00eeb	3a ca		 cmp	 cl, dl
  00eed	89 44 24 2c	 mov	 DWORD PTR _s$60888[esp+304], eax
  00ef1	74 cf		 je	 SHORT $L61907
$nextword$60897:
  00ef3	8b 44 24 30	 mov	 eax, DWORD PTR -256+[esp+304]
  00ef7	89 44 24 5c	 mov	 DWORD PTR _dictp$60892[esp+304], eax
  00efb	8b 08		 mov	 ecx, DWORD PTR [eax]
  00efd	85 c9		 test	 ecx, ecx
  00eff	89 4c 24 30	 mov	 DWORD PTR -256+[esp+304], ecx
  00f03	75 9f		 jne	 SHORT $L60894

; 1466 : 			push(0);

  00f05	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 1467 : 		} else {

  00f09	e9 58 f1 ff ff	 jmp	 $L58091

; 350  : 			case VFIND: tos = vfind ((u_char **)sp, (vocabulary_t *)tos); next;

$L60899:
  00f0e	33 c9		 xor	 ecx, ecx
  00f10	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00f13	8d 54 01 09	 lea	 edx, DWORD PTR [ecx+eax+9]
  00f17	83 e2 fc	 and	 edx, -4			; fffffffcH
  00f1a	89 13		 mov	 DWORD PTR [ebx], edx
  00f1c	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00f1f	24 01		 and	 al, 1
  00f21	f6 d8		 neg	 al
  00f23	1b c0		 sbb	 eax, eax
  00f25	83 e0 02	 and	 eax, 2
  00f28	48		 dec	 eax
  00f29	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  00f2d	e9 34 f1 ff ff	 jmp	 $L58091
$L58279:

; 354  : 			case SYS_EXPECT:
; 355  : #ifdef REMOVE
; 356  : 				cexpect ((u_char *)*sp++, (cell)tos);
; 357  : 				tos = *sp++;
; 358  : 				next;
; 359  : #else
; 360  : 				scr = pop;

  00f32	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 361  : 				ascr = apop;

  00f34	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00f37	83 c3 04	 add	 ebx, 4
  00f3a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 362  : 				SAVE_XCONTEXT

  00f3e	83 ee 08	 sub	 esi, 8

; 363  : 				cexpect ((u_char *)ascr, (cell)scr);

  00f41	50		 push	 eax
  00f42	89 13		 mov	 DWORD PTR [ebx], edx
  00f44	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  00f48	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  00f4e	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  00f52	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  00f58	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  00f5c	89 16		 mov	 DWORD PTR [esi], edx
  00f5e	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  00f62	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00f65	51		 push	 ecx
  00f66	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  00f6c	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  00f72	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  00f78	e8 00 00 00 00	 call	 _cexpect
  00f7d	83 c4 08	 add	 esp, 8

; 364  : 				RESTORE_XCONTEXT
; 365  : 				next;

  00f80	e9 b9 f7 ff ff	 jmp	 $L60780
$L58306:

; 423  : 				return(1);
; 424  : 			case FINISHED:
; 425  : 				/* Don't let the inner interpreter exit unless we have
; 426  : 				 * the same task context as we had on entry.
; 427  : 				 */
; 428  : 				if (entrycontext != up) {

  00f85	8b 4c 24 7c	 mov	 ecx, DWORD PTR _entrycontext$[esp+304]
  00f89	3b cf		 cmp	 ecx, edi
  00f8b	0f 84 7d 68 00
	00		 je	 $L58322

; 429  : 					--ip;		/* FIX: doesn't work with EXECUTE */

  00f91	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]

; 430  : 					SAVE_TASKCONTEXT

  00f94	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  00f98	83 eb 04	 sub	 ebx, 4
  00f9b	83 e8 04	 sub	 eax, 4
  00f9e	83 ee 08	 sub	 esi, 8
  00fa1	89 13		 mov	 DWORD PTR [ebx], edx
  00fa3	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  00fa7	89 47 64	 mov	 DWORD PTR [edi+100], eax
  00faa	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  00fae	89 47 68	 mov	 DWORD PTR [edi+104], eax
  00fb1	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  00fb5	89 5f 6c	 mov	 DWORD PTR [edi+108], ebx
  00fb8	89 16		 mov	 DWORD PTR [esi], edx
  00fba	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  00fbe	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00fc1	89 b7 94 00 00
	00		 mov	 DWORD PTR [edi+148], esi
  00fc7	89 97 a8 00 00
	00		 mov	 DWORD PTR [edi+168], edx
$L58313:

; 431  : 					do {
; 432  : 						up = (cell *)V_LINK;

  00fcd	8b 7f 5c	 mov	 edi, DWORD PTR [edi+92]

; 433  : 					} while (up != entrycontext);

  00fd0	3b f9		 cmp	 edi, ecx
  00fd2	75 f9		 jne	 SHORT $L58313

; 434  : 					RESTORE_TASKCONTEXT

  00fd4	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00fda	8b 5f 6c	 mov	 ebx, DWORD PTR [edi+108]
  00fdd	8b b7 94 00 00
	00		 mov	 esi, DWORD PTR [edi+148]
  00fe3	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  00fe7	8b 03		 mov	 eax, DWORD PTR [ebx]
  00fe9	83 c3 04	 add	 ebx, 4
  00fec	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00fee	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00ff1	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 435  : 					if (!V_TASK_ACTIVE) {

  00ff5	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00ff8	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  00ffc	8b 4f 68	 mov	 ecx, DWORD PTR [edi+104]
  00fff	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  01003	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  01006	83 c6 08	 add	 esi, 8
  01009	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  0100d	85 c0		 test	 eax, eax
  0100f	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  01012	0f 85 f6 67 00
	00		 jne	 $L58322

; 436  : 						goto pause;

  01018	e9 16 62 00 00	 jmp	 $pause$58247
$L58323:

; 445  : 			case DECIMAL:      V_BASE = 10;	  next;

  0101d	c7 47 0c 0a 00
	00 00		 mov	 DWORD PTR [edi+12], 10	; 0000000aH
  01024	e9 3d f0 ff ff	 jmp	 $L58091
$L58324:

; 446  : 			case HEX:	       V_BASE = 16;	  next;

  01029	c7 47 0c 10 00
	00 00		 mov	 DWORD PTR [edi+12], 16	; 00000010H
  01030	e9 31 f0 ff ff	 jmp	 $L58091
$L58326:

; 448  : 			case HERE:	       push ( DP );		 next;

  01035	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01039	83 eb 04	 sub	 ebx, 4
  0103c	89 03		 mov	 DWORD PTR [ebx], eax
  0103e	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01041	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  01045	e9 1c f0 ff ff	 jmp	 $L58091
$L58329:

; 449  : 			case TIB:	       push ( V_TICK_TIB );	 next;

  0104a	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0104e	83 eb 04	 sub	 ebx, 4
  01051	89 13		 mov	 DWORD PTR [ebx], edx
  01053	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]

; 2298 : 				push(scr);

  01059	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0105d	e9 04 f0 ff ff	 jmp	 $L58091
$L58331:

; 450  : 			case DOT: scr = pop; SAVE_XCONTEXT dot( scr ); RESTORE_XCONTEXT next;

  01062	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01064	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  01068	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0106c	89 0b		 mov	 DWORD PTR [ebx], ecx
  0106e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  01072	83 ee 08	 sub	 esi, 8
  01075	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0107b	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01081	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  01085	89 16		 mov	 DWORD PTR [esi], edx
  01087	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  0108b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0108e	85 c0		 test	 eax, eax
  01090	89 44 24 30	 mov	 DWORD PTR _scr$[esp+304], eax
  01094	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0109a	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  010a0	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  010a6	7d 10		 jge	 SHORT $L60934
  010a8	6a 2d		 push	 45			; 0000002dH
  010aa	e8 00 00 00 00	 call	 _emit
  010af	8b 44 24 34	 mov	 eax, DWORD PTR _scr$[esp+308]
  010b3	83 c4 04	 add	 esp, 4
  010b6	f7 d8		 neg	 eax
$L60934:
  010b8	8b c8		 mov	 ecx, eax
  010ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  010bf	c6 05 27 00 00
	00 20		 mov	 BYTE PTR _num_buf+39, 32 ; 00000020H
  010c6	bf 27 00 00 00	 mov	 edi, OFFSET FLAT:_num_buf+39
  010cb	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  010ce	8b d8		 mov	 ebx, eax
$L60930:
  010d0	8b c1		 mov	 eax, ecx
  010d2	33 d2		 xor	 edx, edx
  010d4	f7 f6		 div	 esi
  010d6	4f		 dec	 edi
  010d7	8b c1		 mov	 eax, ecx
  010d9	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _digits[edx]
  010df	88 17		 mov	 BYTE PTR [edi], dl
  010e1	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  010e4	33 d2		 xor	 edx, edx
  010e6	f7 f6		 div	 esi
  010e8	8b c8		 mov	 ecx, eax
  010ea	85 c9		 test	 ecx, ecx
  010ec	75 e2		 jne	 SHORT $L60930
  010ee	b8 28 00 00 00	 mov	 eax, OFFSET FLAT:_num_buf+40
  010f3	2b c7		 sub	 eax, edi
  010f5	8b c8		 mov	 ecx, eax
  010f7	48		 dec	 eax
  010f8	85 c9		 test	 ecx, ecx
  010fa	0f 84 a3 64 00
	00		 je	 $L60948
  01100	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L60925:
  01103	8a 07		 mov	 al, BYTE PTR [edi]
  01105	47		 inc	 edi
  01106	50		 push	 eax
  01107	e8 00 00 00 00	 call	 _emit
  0110c	83 c4 04	 add	 esp, 4
  0110f	4e		 dec	 esi
  01110	75 f1		 jne	 SHORT $L60925
  01112	e9 8c 64 00 00	 jmp	 $L60948
$L58332:

; 451  : 			case U_DOT: scr = pop;

  01117	8b 03		 mov	 eax, DWORD PTR [ebx]

; 452  : 				SAVE_XCONTEXT udot((u_cell)scr ); RESTORE_XCONTEXT 

  01119	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0111d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  01121	89 03		 mov	 DWORD PTR [ebx], eax
  01123	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  01127	83 ee 08	 sub	 esi, 8
  0112a	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01130	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01136	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0113a	89 06		 mov	 DWORD PTR [esi], eax
  0113c	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  01140	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01143	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01149	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0114f	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  01154	c6 05 27 00 00
	00 20		 mov	 BYTE PTR _num_buf+39, 32 ; 00000020H
  0115b	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0115e	bb 27 00 00 00	 mov	 ebx, OFFSET FLAT:_num_buf+39
$L60952:
  01163	8b c1		 mov	 eax, ecx
  01165	33 d2		 xor	 edx, edx
  01167	f7 f6		 div	 esi
  01169	4b		 dec	 ebx
  0116a	8b c1		 mov	 eax, ecx
  0116c	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _digits[edx]
  01172	88 13		 mov	 BYTE PTR [ebx], dl
  01174	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  01177	33 d2		 xor	 edx, edx
  01179	f7 f6		 div	 esi
  0117b	8b c8		 mov	 ecx, eax
  0117d	85 c9		 test	 ecx, ecx
  0117f	75 e2		 jne	 SHORT $L60952
  01181	b8 28 00 00 00	 mov	 eax, OFFSET FLAT:_num_buf+40
  01186	2b c3		 sub	 eax, ebx
  01188	8b c8		 mov	 ecx, eax
  0118a	48		 dec	 eax
  0118b	85 c9		 test	 ecx, ecx
  0118d	0f 84 10 64 00
	00		 je	 $L60948
  01193	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L60947:
  01196	8a 03		 mov	 al, BYTE PTR [ebx]
  01198	43		 inc	 ebx
  01199	50		 push	 eax
  0119a	e8 00 00 00 00	 call	 _emit
  0119f	83 c4 04	 add	 esp, 4
  011a2	4e		 dec	 esi
  011a3	75 f1		 jne	 SHORT $L60947

; 453  : 				next;

  011a5	e9 f9 63 00 00	 jmp	 $L60948
$L58334:

; 454  : 			case PWORD:
; 455  : 				scr = pop;

  011aa	8b 03		 mov	 eax, DWORD PTR [ebx]

; 456  : 				SAVE_XCONTEXT 	

  011ac	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  011b0	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  011b4	89 03		 mov	 DWORD PTR [ebx], eax
  011b6	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  011ba	83 ee 08	 sub	 esi, 8
  011bd	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  011c3	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  011c9	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  011cd	89 06		 mov	 DWORD PTR [esi], eax
  011cf	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  011d3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  011d6	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  011dc	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  011e2	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax

; 457  : 				scr = (cell) word((u_char)scr);

  011e7	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  011ed	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  011f0	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  011f3	03 f1		 add	 esi, ecx
  011f5	03 c1		 add	 eax, ecx
  011f7	80 fa 20	 cmp	 dl, 32			; 00000020H
  011fa	b9 01 00 00 00	 mov	 ecx, 1
  011ff	75 07		 jne	 SHORT $L61728
  01201	e8 00 00 00 00	 call	 _blword
  01206	eb 57		 jmp	 SHORT $L60957
$L61728:
  01208	3b c6		 cmp	 eax, esi
  0120a	73 22		 jae	 SHORT $L61785
  0120c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
$L60963:
  01212	33 db		 xor	 ebx, ebx
  01214	8a 18		 mov	 bl, BYTE PTR [eax]
  01216	40		 inc	 eax
  01217	3b da		 cmp	 ebx, edx
  01219	74 1c		 je	 SHORT $L61786
  0121b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01221	7d 07		 jge	 SHORT $L60968
  01223	88 99 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], bl
  01229	41		 inc	 ecx
$L60968:
  0122a	3b c6		 cmp	 eax, esi
  0122c	72 e4		 jb	 SHORT $L60963
$L61785:
  0122e	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1
  01235	eb 03		 jmp	 SHORT $finish$60966
$L61786:
  01237	89 5f 20	 mov	 DWORD PTR [edi+32], ebx
$finish$60966:
  0123a	8a d1		 mov	 dl, cl
  0123c	fe ca		 dec	 dl
  0123e	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  01244	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  0124b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  01251	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  01257	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0125a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wordbuf
$L60957:

; 458  : 				RESTORE_XCONTEXT

  0125f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01265	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  0126b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01271	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01277	8b 16		 mov	 edx, DWORD PTR [esi]
  01279	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  0127d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01280	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  01284	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  0128a	83 c6 08	 add	 esi, 8
  0128d	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01291	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  01295	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01299	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx

; 2298 : 				push(scr);

  0129d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  012a1	e9 c0 ed ff ff	 jmp	 $L58091
$L58338:

; 459  : 				push(scr);
; 460  : 				next;
; 461  : 			case COMMA:	       comma;			 next;

  012a6	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  012a9	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  012ad	89 08		 mov	 DWORD PTR [eax], ecx

; 511  : 			case LITERAL: 
; 512  : 				SAVE_XCONTEXT xcompile(PAREN_LIT); RESTORE_XCONTEXT comma; next;

  012af	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  012b2	83 c1 04	 add	 ecx, 4

; 2553 : 				RESTORE_XCONTEXT

  012b5	83 c3 04	 add	 ebx, 4
  012b8	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  012bb	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]
  012be	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2554 : 			} next;

  012c2	e9 9f ed ff ff	 jmp	 $L58091
$L58341:

; 462  : 			case DOT_QUOTE:
; 463  : 				SAVE_XCONTEXT 

  012c7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  012cb	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  012cf	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  012d3	83 eb 04	 sub	 ebx, 4
  012d6	83 ee 08	 sub	 esi, 8
  012d9	89 03		 mov	 DWORD PTR [ebx], eax
  012db	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  012df	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  012e5	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  012eb	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  012ef	89 16		 mov	 DWORD PTR [esi], edx
  012f1	89 46 04	 mov	 DWORD PTR [esi+4], eax
  012f4	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  012fa	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01300	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 464  : 				xcompile(P_DOT_QUOTE); comma_string( word('"') ); 

  01306	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01309	50		 push	 eax
  0130a	6a 74		 push	 116			; 00000074H
  0130c	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0130f	89 57 70	 mov	 DWORD PTR [edi+112], edx
  01312	e8 00 00 00 00	 call	 _tokstore
  01317	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0131d	83 c4 08	 add	 esp, 8
  01320	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  01326	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  01329	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0132c	03 f1		 add	 esi, ecx
  0132e	03 c1		 add	 eax, ecx
  01330	b9 01 00 00 00	 mov	 ecx, 1
  01335	3b c6		 cmp	 eax, esi
  01337	73 1d		 jae	 SHORT $L61787
$L60977:
  01339	33 d2		 xor	 edx, edx
  0133b	8a 10		 mov	 dl, BYTE PTR [eax]
  0133d	40		 inc	 eax
  0133e	83 fa 22	 cmp	 edx, 34			; 00000022H
  01341	74 1c		 je	 SHORT $L61788
  01343	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01349	7d 07		 jge	 SHORT $L60982
  0134b	88 91 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], dl
  01351	41		 inc	 ecx
$L60982:
  01352	3b c6		 cmp	 eax, esi
  01354	72 e3		 jb	 SHORT $L60977
$L61787:
  01356	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1
  0135d	eb 03		 jmp	 SHORT $finish$60980
$L61788:
  0135f	89 57 20	 mov	 DWORD PTR [edi+32], edx
$finish$60980:
  01362	8a d1		 mov	 dl, cl
  01364	fe ca		 dec	 dl
  01366	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  0136c	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  01373	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  01379	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_wordbuf
  0137e	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  01384	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  01387	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0138c	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0138f	33 c0		 xor	 eax, eax
  01391	a0 00 00 00 00	 mov	 al, BYTE PTR _wordbuf
  01396	40		 inc	 eax
  01397	8b f0		 mov	 esi, eax
  01399	48		 dec	 eax
  0139a	85 f6		 test	 esi, esi
  0139c	74 0c		 je	 SHORT $L61011
  0139e	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L61010:
  013a1	8a 02		 mov	 al, BYTE PTR [edx]
  013a3	88 01		 mov	 BYTE PTR [ecx], al
  013a5	41		 inc	 ecx
  013a6	42		 inc	 edx
  013a7	4e		 dec	 esi
  013a8	75 f7		 jne	 SHORT $L61010
$L61011:
  013aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  013b0	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
  013b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  013b8	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  013bb	8d 42 03	 lea	 eax, DWORD PTR [edx+3]
  013be	24 fc		 and	 al, -4			; fffffffcH
  013c0	2b c2		 sub	 eax, edx
  013c2	8b c8		 mov	 ecx, eax
  013c4	48		 dec	 eax
  013c5	85 c9		 test	 ecx, ecx
  013c7	74 19		 je	 SHORT $L61067
  013c9	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  013cc	33 c0		 xor	 eax, eax
  013ce	8b ce		 mov	 ecx, esi
  013d0	8b fa		 mov	 edi, edx
  013d2	8b d9		 mov	 ebx, ecx
  013d4	c1 e9 02	 shr	 ecx, 2
  013d7	f3 ab		 rep stosd
  013d9	8b cb		 mov	 ecx, ebx
  013db	83 e1 03	 and	 ecx, 3
  013de	03 d6		 add	 edx, esi
  013e0	f3 aa		 rep stosb

; 479  : 				xcompile(PAREN_ABORT_QUOTE);    comma_string(word('"'));	   

$L61067:
  013e2	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  013e7	89 50 70	 mov	 DWORD PTR [eax+112], edx
  013ea	e9 83 f5 ff ff	 jmp	 $L61519
$L58344:

; 465  : 				RESTORE_XCONTEXT next;
; 466  : 			case COLON:
; 467  : 				SAVE_XCONTEXT

  013ef	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  013f3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  013f7	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  013fb	83 eb 04	 sub	 ebx, 4
  013fe	83 ee 08	 sub	 esi, 8
  01401	89 03		 mov	 DWORD PTR [ebx], eax
  01403	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  01407	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0140d	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01413	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  01417	89 16		 mov	 DWORD PTR [esi], edx
  01419	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0141c	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01422	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01428	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 468  : 				create (DOCOLON); hide();   

  0142e	e8 00 00 00 00	 call	 _blword
  01433	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  01439	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  0143c	85 c9		 test	 ecx, ecx
  0143e	74 26		 je	 SHORT $L61021
  01440	33 c9		 xor	 ecx, ecx
  01442	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01445	8a 08		 mov	 cl, BYTE PTR [eax]
  01447	8b f1		 mov	 esi, ecx
  01449	49		 dec	 ecx
  0144a	85 f6		 test	 esi, esi
  0144c	74 18		 je	 SHORT $L61021
  0144e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61019:
  01451	8a 0a		 mov	 cl, BYTE PTR [edx]
  01453	80 f9 41	 cmp	 cl, 65			; 00000041H
  01456	7c 0a		 jl	 SHORT $L61020
  01458	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  0145b	7f 05		 jg	 SHORT $L61020
  0145d	80 c1 20	 add	 cl, 32			; 00000020H
  01460	88 0a		 mov	 BYTE PTR [edx], cl
$L61020:
  01462	42		 inc	 edx
  01463	4e		 dec	 esi
  01464	75 eb		 jne	 SHORT $L61019
$L61021:
  01466	68 91 01 00 00	 push	 401			; 00000191H
  0146b	50		 push	 eax
  0146c	e8 00 00 00 00	 call	 _quote_create
  01471	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01476	83 c4 08	 add	 esp, 8
  01479	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0147c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0147f	8b 01		 mov	 eax, DWORD PTR [ecx]
  01481	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 469  : 				RESTORE_XCONTEXT

  01484	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  0148a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  01490	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01496	8b 16		 mov	 edx, DWORD PTR [esi]
  01498	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0149b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  014a1	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  014a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  014ab	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  014af	8b 13		 mov	 edx, DWORD PTR [ebx]
  014b1	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax

; 470  : 				V_STATE = (cell)COMPILING; V_CONTEXT = V_CURRENT;

  014b5	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  014b8	83 c6 08	 add	 esi, 8
  014bb	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  014bf	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  014c3	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  014c7	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  014cb	83 c3 04	 add	 ebx, 4
  014ce	c7 47 18 01 00
	00 00		 mov	 DWORD PTR [edi+24], 1
  014d5	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax

; 471  : 				next;

  014db	e9 86 eb ff ff	 jmp	 $L58091
$L58348:

; 472  : 			case SEMICOLON:    
; 473  : 				SAVE_XCONTEXT

  014e0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  014e4	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  014e8	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  014ec	83 eb 04	 sub	 ebx, 4
  014ef	83 ee 08	 sub	 esi, 8
  014f2	89 0b		 mov	 DWORD PTR [ebx], ecx
  014f4	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  014f8	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  014fe	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01504	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  01508	89 06		 mov	 DWORD PTR [esi], eax
  0150a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0150d	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01513	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01519	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx

; 474  : 				xcompile(UNNEST);  reveal(); 

  0151f	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01522	50		 push	 eax
  01523	6a 6c		 push	 108			; 0000006cH
  01525	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01528	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  0152b	e8 00 00 00 00	 call	 _tokstore
  01530	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01535	83 c4 08	 add	 esp, 8
  01538	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0153b	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0153e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 475  : 				RESTORE_XCONTEXT

  01541	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01547	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  0154d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01553	8b 16		 mov	 edx, DWORD PTR [esi]
  01555	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01558	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0155e	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  01562	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  01568	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  0156c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0156e	83 c6 08	 add	 esi, 8
  01571	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01575	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  01579	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0157d	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  01581	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  01585	83 c3 04	 add	 ebx, 4
$L58514:

; 476  : 				V_STATE = (cell)INTERPRETING;   next;

  01588	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0158f	e9 d2 ea ff ff	 jmp	 $L58091
$L58352:

; 477  : 			case ABORT_QUOTE:
; 478  : 				SAVE_XCONTEXT

  01594	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01598	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  0159c	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  015a0	83 eb 04	 sub	 ebx, 4
  015a3	83 ee 08	 sub	 esi, 8
  015a6	89 03		 mov	 DWORD PTR [ebx], eax
  015a8	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  015ac	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  015b2	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  015b8	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  015bc	89 16		 mov	 DWORD PTR [esi], edx
  015be	89 46 04	 mov	 DWORD PTR [esi+4], eax
  015c1	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  015c7	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  015cd	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 479  : 				xcompile(PAREN_ABORT_QUOTE);    comma_string(word('"'));	   

  015d3	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  015d6	50		 push	 eax
  015d7	6a 73		 push	 115			; 00000073H
  015d9	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  015dc	89 57 70	 mov	 DWORD PTR [edi+112], edx
  015df	e8 00 00 00 00	 call	 _tokstore
  015e4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  015ea	83 c4 08	 add	 esp, 8
  015ed	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  015f3	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  015f6	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  015f9	03 f1		 add	 esi, ecx
  015fb	03 c1		 add	 eax, ecx
  015fd	b9 01 00 00 00	 mov	 ecx, 1
  01602	3b c6		 cmp	 eax, esi
  01604	73 1d		 jae	 SHORT $L61789
$L61040:
  01606	33 d2		 xor	 edx, edx
  01608	8a 10		 mov	 dl, BYTE PTR [eax]
  0160a	40		 inc	 eax
  0160b	83 fa 22	 cmp	 edx, 34			; 00000022H
  0160e	74 1c		 je	 SHORT $L61790
  01610	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  01616	7d 07		 jge	 SHORT $L61045
  01618	88 91 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], dl
  0161e	41		 inc	 ecx
$L61045:
  0161f	3b c6		 cmp	 eax, esi
  01621	72 e3		 jb	 SHORT $L61040
$L61789:
  01623	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1
  0162a	eb 03		 jmp	 SHORT $finish$61043
$L61790:
  0162c	89 57 20	 mov	 DWORD PTR [edi+32], edx
$finish$61043:
  0162f	8a d1		 mov	 dl, cl
  01631	fe ca		 dec	 dl
  01633	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  01639	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  01640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  01646	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_wordbuf
  0164b	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  01651	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  01654	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01659	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0165c	33 c0		 xor	 eax, eax
  0165e	a0 00 00 00 00	 mov	 al, BYTE PTR _wordbuf
  01663	40		 inc	 eax
  01664	8b f0		 mov	 esi, eax
  01666	48		 dec	 eax
  01667	85 f6		 test	 esi, esi
  01669	74 0c		 je	 SHORT $L61074
  0166b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L61073:
  0166e	8a 02		 mov	 al, BYTE PTR [edx]
  01670	88 01		 mov	 BYTE PTR [ecx], al
  01672	41		 inc	 ecx
  01673	42		 inc	 edx
  01674	4e		 dec	 esi
  01675	75 f7		 jne	 SHORT $L61073
$L61074:
  01677	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0167d	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
  01680	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01685	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  01688	8d 42 03	 lea	 eax, DWORD PTR [edx+3]
  0168b	24 fc		 and	 al, -4			; fffffffcH
  0168d	2b c2		 sub	 eax, edx
  0168f	8b c8		 mov	 ecx, eax
  01691	48		 dec	 eax
  01692	85 c9		 test	 ecx, ecx
  01694	0f 84 48 fd ff
	ff		 je	 $L61067
  0169a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0169d	33 c0		 xor	 eax, eax
  0169f	8b ce		 mov	 ecx, esi
  016a1	8b fa		 mov	 edi, edx
  016a3	8b d9		 mov	 ebx, ecx
  016a5	c1 e9 02	 shr	 ecx, 2
  016a8	f3 ab		 rep stosd
  016aa	8b cb		 mov	 ecx, ebx
  016ac	83 e1 03	 and	 ecx, 3
  016af	03 d6		 add	 edx, esi
  016b1	f3 aa		 rep stosb
  016b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  016b8	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 480  : 				RESTORE_XCONTEXT
; 481  : 				next;

  016bb	e9 b2 f2 ff ff	 jmp	 $L61519
$L58355:

; 482  : 			case COMPILE:
; 483  : 				SAVE_XCONTEXT

  016c0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  016c4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  016c8	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  016cc	83 eb 04	 sub	 ebx, 4
  016cf	83 ee 08	 sub	 esi, 8
  016d2	89 03		 mov	 DWORD PTR [ebx], eax
  016d4	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  016d8	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  016de	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  016e4	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  016e8	89 16		 mov	 DWORD PTR [esi], edx
  016ea	89 46 04	 mov	 DWORD PTR [esi+4], eax
  016ed	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  016f3	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  016f9	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 484  : 				xcompile(PAREN_COMPILE);

  016ff	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01702	50		 push	 eax
  01703	6a 77		 push	 119			; 00000077H
  01705	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01708	89 57 70	 mov	 DWORD PTR [edi+112], edx
  0170b	e8 00 00 00 00	 call	 _tokstore
  01710	83 c4 08	 add	 esp, 8

; 485  : 				RESTORE_XCONTEXT next;

  01713	e9 26 f0 ff ff	 jmp	 $L60780
$L58358:

; 486  : 			case CONSTANT: SAVE_XCONTEXT    create (DOCON); RESTORE_XCONTEXT

  01718	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0171c	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  01720	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  01724	83 eb 04	 sub	 ebx, 4
  01727	83 ee 08	 sub	 esi, 8
  0172a	89 13		 mov	 DWORD PTR [ebx], edx
  0172c	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  01730	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01736	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  0173b	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  0173f	89 0e		 mov	 DWORD PTR [esi], ecx
  01741	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01744	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0174a	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01750	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  01755	e8 00 00 00 00	 call	 _blword
  0175a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  01760	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  01763	85 d2		 test	 edx, edx
  01765	74 26		 je	 SHORT $L61084
  01767	33 c9		 xor	 ecx, ecx
  01769	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0176c	8a 08		 mov	 cl, BYTE PTR [eax]
  0176e	8b f1		 mov	 esi, ecx
  01770	49		 dec	 ecx
  01771	85 f6		 test	 esi, esi
  01773	74 18		 je	 SHORT $L61084
  01775	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61082:
  01778	8a 0a		 mov	 cl, BYTE PTR [edx]
  0177a	80 f9 41	 cmp	 cl, 65			; 00000041H
  0177d	7c 0a		 jl	 SHORT $L61083
  0177f	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  01782	7f 05		 jg	 SHORT $L61083
  01784	80 c1 20	 add	 cl, 32			; 00000020H
  01787	88 0a		 mov	 BYTE PTR [edx], cl
$L61083:
  01789	42		 inc	 edx
  0178a	4e		 dec	 esi
  0178b	75 eb		 jne	 SHORT $L61082
$L61084:
  0178d	68 92 01 00 00	 push	 402			; 00000192H
  01792	50		 push	 eax
  01793	e8 00 00 00 00	 call	 _quote_create

; 487  : 				comma;	    next;

  01798	e9 f0 05 00 00	 jmp	 $L61983
$L58363:

; 488  : 			case VARIABLE: SAVE_XCONTEXT create (DOVAR); RESTORE_XCONTEXT

  0179d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  017a1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  017a5	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  017a9	83 eb 04	 sub	 ebx, 4
  017ac	83 ee 08	 sub	 esi, 8
  017af	89 03		 mov	 DWORD PTR [ebx], eax
  017b1	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  017b5	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  017bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  017c1	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  017c5	89 16		 mov	 DWORD PTR [esi], edx
  017c7	89 46 04	 mov	 DWORD PTR [esi+4], eax
  017ca	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  017d0	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  017d6	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  017dc	e8 00 00 00 00	 call	 _blword
  017e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  017e7	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  017ea	85 c9		 test	 ecx, ecx
  017ec	74 26		 je	 SHORT $L61096
  017ee	33 c9		 xor	 ecx, ecx
  017f0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  017f3	8a 08		 mov	 cl, BYTE PTR [eax]
  017f5	8b f1		 mov	 esi, ecx
  017f7	49		 dec	 ecx
  017f8	85 f6		 test	 esi, esi
  017fa	74 18		 je	 SHORT $L61096
  017fc	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61094:
  017ff	8a 0a		 mov	 cl, BYTE PTR [edx]
  01801	80 f9 41	 cmp	 cl, 65			; 00000041H
  01804	7c 0a		 jl	 SHORT $L61095
  01806	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  01809	7f 05		 jg	 SHORT $L61095
  0180b	80 c1 20	 add	 cl, 32			; 00000020H
  0180e	88 0a		 mov	 BYTE PTR [edx], cl
$L61095:
  01810	42		 inc	 edx
  01811	4e		 dec	 esi
  01812	75 eb		 jne	 SHORT $L61094
$L61096:
  01814	68 93 01 00 00	 push	 403			; 00000193H
  01819	50		 push	 eax
  0181a	e8 00 00 00 00	 call	 _quote_create
  0181f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01825	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0182b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  01830	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01836	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01839	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0183b	89 54 24 1c	 mov	 DWORD PTR _ftos$[esp+316], edx

; 489  : 				ncomma(0);  next;

  0183f	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01842	89 44 24 28	 mov	 DWORD PTR _frp$[esp+312], eax
  01846	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  0184b	89 4c 24 18	 mov	 DWORD PTR _ftos$[esp+312], ecx
  0184f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01851	89 44 24 24	 mov	 DWORD PTR _rp$[esp+312], eax
  01855	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 537  : 				forw_mark; next;

  0185b	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0185e	83 c4 08	 add	 esp, 8
  01861	83 c6 08	 add	 esi, 8
  01864	83 c3 04	 add	 ebx, 4
  01867	83 c0 04	 add	 eax, 4
  0186a	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  0186e	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01872	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  01876	89 47 70	 mov	 DWORD PTR [edi+112], eax
  01879	e9 e8 e7 ff ff	 jmp	 $L58091
$L58368:

; 490  : 			case CREATE: SAVE_XCONTEXT create (DOVAR);	RESTORE_XCONTEXT next;

  0187e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01882	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  01886	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  0188a	83 eb 04	 sub	 ebx, 4
  0188d	83 ee 08	 sub	 esi, 8
  01890	89 03		 mov	 DWORD PTR [ebx], eax
  01892	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  01896	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0189c	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  018a2	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  018a6	89 16		 mov	 DWORD PTR [esi], edx
  018a8	89 46 04	 mov	 DWORD PTR [esi+4], eax
  018ab	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  018b1	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  018b7	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  018bd	e8 00 00 00 00	 call	 _blword
  018c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  018c8	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  018cb	85 c9		 test	 ecx, ecx
  018cd	74 26		 je	 SHORT $L61108
  018cf	33 c9		 xor	 ecx, ecx
  018d1	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  018d4	8a 08		 mov	 cl, BYTE PTR [eax]
  018d6	8b f1		 mov	 esi, ecx
  018d8	49		 dec	 ecx
  018d9	85 f6		 test	 esi, esi
  018db	74 18		 je	 SHORT $L61108
  018dd	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61106:
  018e0	8a 0a		 mov	 cl, BYTE PTR [edx]
  018e2	80 f9 41	 cmp	 cl, 65			; 00000041H
  018e5	7c 0a		 jl	 SHORT $L61107
  018e7	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  018ea	7f 05		 jg	 SHORT $L61107
  018ec	80 c1 20	 add	 cl, 32			; 00000020H
  018ef	88 0a		 mov	 BYTE PTR [edx], cl
$L61107:
  018f1	42		 inc	 edx
  018f2	4e		 dec	 esi
  018f3	75 eb		 jne	 SHORT $L61106
$L61108:
  018f5	68 93 01 00 00	 push	 403			; 00000193H
  018fa	50		 push	 eax
  018fb	e8 00 00 00 00	 call	 _quote_create
  01900	83 c4 08	 add	 esp, 8
  01903	e9 36 ee ff ff	 jmp	 $L60780
$L58371:

; 491  : 			case QUOTE_CREATE: ascr = apop;

  01908	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 492  : 				SAVE_XCONTEXT

  0190a	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0190e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01912	89 0b		 mov	 DWORD PTR [ebx], ecx
  01914	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  01918	83 ee 08	 sub	 esi, 8
  0191b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01921	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01927	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0192b	89 0e		 mov	 DWORD PTR [esi], ecx
  0192d	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]

; 493  : 				quote_create (ascr, (token_t)DOVAR); 

  01931	68 93 01 00 00	 push	 403			; 00000193H
  01936	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01939	50		 push	 eax
  0193a	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01940	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01946	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  0194c	e8 00 00 00 00	 call	 _quote_create
  01951	83 c4 08	 add	 esp, 8

; 494  : 				RESTORE_XCONTEXT next;

  01954	e9 4a 5c 00 00	 jmp	 $L60948
$L58374:

; 495  : 			case USER_SIZE:    push (MAXUSER);	next;

  01959	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0195d	83 eb 04	 sub	 ebx, 4
  01960	c7 44 24 0c 00
	08 00 00	 mov	 DWORD PTR _tos$[esp+304], 2048 ; 00000800H
  01968	89 0b		 mov	 DWORD PTR [ebx], ecx
  0196a	e9 f7 e6 ff ff	 jmp	 $L58091
$L58377:

; 496  : 			case USER: SAVE_XCONTEXT create (DOUSER); RESTORE_XCONTEXT

  0196f	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  01973	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  01977	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  0197b	83 eb 04	 sub	 ebx, 4
  0197e	83 ee 08	 sub	 esi, 8
  01981	89 13		 mov	 DWORD PTR [ebx], edx
  01983	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  01987	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0198d	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  01992	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  01996	89 0e		 mov	 DWORD PTR [esi], ecx
  01998	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0199b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  019a1	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  019a7	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  019ac	e8 00 00 00 00	 call	 _blword
  019b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  019b7	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  019ba	85 d2		 test	 edx, edx
  019bc	74 26		 je	 SHORT $L61120
  019be	33 c9		 xor	 ecx, ecx
  019c0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  019c3	8a 08		 mov	 cl, BYTE PTR [eax]
  019c5	8b f1		 mov	 esi, ecx
  019c7	49		 dec	 ecx
  019c8	85 f6		 test	 esi, esi
  019ca	74 18		 je	 SHORT $L61120
  019cc	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61118:
  019cf	8a 0a		 mov	 cl, BYTE PTR [edx]
  019d1	80 f9 41	 cmp	 cl, 65			; 00000041H
  019d4	7c 0a		 jl	 SHORT $L61119
  019d6	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  019d9	7f 05		 jg	 SHORT $L61119
  019db	80 c1 20	 add	 cl, 32			; 00000020H
  019de	88 0a		 mov	 BYTE PTR [edx], cl
$L61119:
  019e0	42		 inc	 edx
  019e1	4e		 dec	 esi
  019e2	75 eb		 jne	 SHORT $L61118
$L61120:
  019e4	68 94 01 00 00	 push	 404			; 00000194H
  019e9	50		 push	 eax
  019ea	e8 00 00 00 00	 call	 _quote_create

; 497  : 				comma;	next;

  019ef	e9 99 03 00 00	 jmp	 $L61983
$L58382:

; 498  : 			case IMMEDIATE:    SAVE_XCONTEXT makeimmediate (); 

  019f4	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  019f8	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  019fc	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  01a00	83 eb 04	 sub	 ebx, 4
  01a03	83 ee 08	 sub	 esi, 8
  01a06	89 03		 mov	 DWORD PTR [ebx], eax
  01a08	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  01a0c	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01a12	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01a18	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  01a1c	89 16		 mov	 DWORD PTR [esi], edx
  01a1e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01a21	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01a27	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01a2d	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  01a33	8b 7f 30	 mov	 edi, DWORD PTR [edi+48]
  01a36	80 4f 04 01	 or	 BYTE PTR [edi+4], 1

; 499  : 				RESTORE_XCONTEXT next;

  01a3a	e9 64 5b 00 00	 jmp	 $L60948
$L58383:

; 500  : 			case DOES: SAVE_XCONTEXT xcompile(P_DOES);	RESTORE_XCONTEXT next;

  01a3f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  01a43	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  01a47	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  01a4b	83 eb 04	 sub	 ebx, 4
  01a4e	83 ee 08	 sub	 esi, 8
  01a51	89 0b		 mov	 DWORD PTR [ebx], ecx
  01a53	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  01a57	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01a5d	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01a63	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  01a67	89 06		 mov	 DWORD PTR [esi], eax
  01a69	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  01a6c	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01a72	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01a78	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  01a7e	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01a81	50		 push	 eax
  01a82	6a 70		 push	 112			; 00000070H
  01a84	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01a87	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  01a8a	e8 00 00 00 00	 call	 _tokstore
  01a8f	83 c4 08	 add	 esp, 8
  01a92	e9 0c 5b 00 00	 jmp	 $L60948
$L58386:

; 501  : 			case IF:	SAVE_XCONTEXT pluslevel(); xcompile(QUES_BRANCH); 

  01a97	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  01a9b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  01a9f	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  01aa3	83 eb 04	 sub	 ebx, 4
  01aa6	83 ee 08	 sub	 esi, 8
  01aa9	89 0b		 mov	 DWORD PTR [ebx], ecx
  01aab	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  01aaf	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01ab5	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01abb	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  01abf	89 06		 mov	 DWORD PTR [esi], eax
  01ac1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  01ac4	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  01ac9	85 c0		 test	 eax, eax
  01acb	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01ad1	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01ad7	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  01add	74 08		 je	 SHORT $L61129
  01adf	40		 inc	 eax
  01ae0	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01ae5	eb 30		 jmp	 SHORT $L61131
$L61129:
  01ae7	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01aea	85 c0		 test	 eax, eax
  01aec	75 29		 jne	 SHORT $L61131
  01aee	b8 01 00 00 00	 mov	 eax, 1
  01af3	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01af8	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01afb	89 0d 00 00 00
	00		 mov	 DWORD PTR _saved_dp, ecx
  01b01	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET FLAT:_comp_buffer
  01b08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  01b0e	89 42 18	 mov	 DWORD PTR [edx+24], eax
  01b11	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
$L61131:
  01b17	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01b1a	50		 push	 eax
  01b1b	6a 76		 push	 118			; 00000076H
  01b1d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01b20	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  01b23	e8 00 00 00 00	 call	 _tokstore

; 502  : 				RESTORE_XCONTEXT forw_mark; next;

  01b28	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01b2e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  01b34	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01b3a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01b40	8b 06		 mov	 eax, DWORD PTR [esi]
  01b42	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01b45	83 c4 08	 add	 esp, 8
  01b48	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  01b4c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  01b52	83 c6 08	 add	 esi, 8
  01b55	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01b59	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  01b5d	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  01b61	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01b65	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  01b69	e9 6f 08 00 00	 jmp	 $L61967
$L58393:

; 503  : 			case ELSE:	SAVE_XCONTEXT xcompile(BRANCH); RESTORE_XCONTEXT

  01b6e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01b72	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  01b76	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  01b7a	83 eb 04	 sub	 ebx, 4
  01b7d	83 ee 08	 sub	 esi, 8
  01b80	89 03		 mov	 DWORD PTR [ebx], eax
  01b82	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  01b86	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01b8c	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01b92	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  01b96	89 16		 mov	 DWORD PTR [esi], edx
  01b98	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01b9b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01ba1	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01ba7	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  01bad	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01bb0	50		 push	 eax
  01bb1	6a 75		 push	 117			; 00000075H
  01bb3	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01bb6	89 57 70	 mov	 DWORD PTR [edi+112], edx
  01bb9	e8 00 00 00 00	 call	 _tokstore
  01bbe	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  01bc3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01bc9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01bcf	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01bd5	89 44 24 28	 mov	 DWORD PTR _frp$[esp+312], eax
  01bd9	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  01bde	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01be1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01be3	89 44 24 24	 mov	 DWORD PTR _rp$[esp+312], eax

; 504  : 				forw_mark;

  01be7	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01bea	89 54 24 1c	 mov	 DWORD PTR _ftos$[esp+316], edx
  01bee	89 4c 24 18	 mov	 DWORD PTR _ftos$[esp+312], ecx
  01bf2	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  01bf8	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01bfb	83 c2 04	 add	 edx, 4
  01bfe	8b c8		 mov	 ecx, eax
  01c00	89 57 70	 mov	 DWORD PTR [edi+112], edx

; 505  : 				scr = *sp;   *sp = tos;	  tos = scr;  /* swap */

  01c03	8b 03		 mov	 eax, DWORD PTR [ebx]
  01c05	89 4c 24 14	 mov	 DWORD PTR _tos$[esp+312], ecx
  01c09	89 0b		 mov	 DWORD PTR [ebx], ecx

; 506  : 				forw_resolve;

  01c0b	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01c0e	83 c4 08	 add	 esp, 8
  01c11	2b c8		 sub	 ecx, eax
  01c13	83 c6 08	 add	 esi, 8
  01c16	83 c3 04	 add	 ebx, 4
  01c19	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01c1d	c1 f9 02	 sar	 ecx, 2
  01c20	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01c24	89 08		 mov	 DWORD PTR [eax], ecx

; 507  : 				next;

  01c26	e9 3b e4 ff ff	 jmp	 $L58091
$L58403:

; 508  : 			case THEN:	forw_resolve;  minuslevel; next;

  01c2b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01c2f	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01c32	8b 13		 mov	 edx, DWORD PTR [ebx]
  01c34	2b c8		 sub	 ecx, eax
  01c36	c1 f9 02	 sar	 ecx, 2
  01c39	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  01c3d	89 08		 mov	 DWORD PTR [eax], ecx
  01c3f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  01c45	83 c3 04	 add	 ebx, 4
  01c48	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01c4b	85 c0		 test	 eax, eax
  01c4d	75 0d		 jne	 SHORT $L61135
  01c4f	68 00 00 00 00	 push	 OFFSET FLAT:$SG60366
  01c54	e8 00 00 00 00	 call	 _error
  01c59	83 c4 04	 add	 esp, 4
$L61135:
  01c5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  01c61	85 c0		 test	 eax, eax
  01c63	0f 84 f5 e3 ff
	ff		 je	 $L61881
  01c69	48		 dec	 eax
  01c6a	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01c6f	0f 85 e9 e3 ff
	ff		 jne	 $L61881
  01c75	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01c7a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  01c7d	51		 push	 ecx
  01c7e	6a 69		 push	 105			; 00000069H
  01c80	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  01c83	89 50 70	 mov	 DWORD PTR [eax+112], edx
  01c86	e8 00 00 00 00	 call	 _tokstore
  01c8b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  01c90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _saved_dp
  01c96	83 eb 04	 sub	 ebx, 4
  01c99	68 00 00 00 00	 push	 OFFSET FLAT:_comp_buffer
  01c9e	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  01ca1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  01ca7	8b 44 24 18	 mov	 eax, DWORD PTR _tos$[esp+316]
  01cab	8b 4c 24 28	 mov	 ecx, DWORD PTR _rp$[esp+316]
  01caf	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
  01cb6	8b 54 24 1c	 mov	 edx, DWORD PTR _ftos$[esp+316]
  01cba	89 03		 mov	 DWORD PTR [ebx], eax
  01cbc	8b 44 24 30	 mov	 eax, DWORD PTR _fsp$[esp+316]
  01cc0	83 e8 08	 sub	 eax, 8
  01cc3	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01cc9	8b 4c 24 20	 mov	 ecx, DWORD PTR _ftos$[esp+320]
  01ccd	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01cd3	89 10		 mov	 DWORD PTR [eax], edx
  01cd5	8b 54 24 34	 mov	 edx, DWORD PTR _up$[esp+316]
  01cd9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01cdc	a3 00 00 00 00	 mov	 DWORD PTR _xfsp, eax
  01ce1	8b 44 24 2c	 mov	 eax, DWORD PTR _frp$[esp+316]
  01ce5	89 15 00 00 00
	00		 mov	 DWORD PTR _xup, edx
  01ceb	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  01cf0	e8 00 00 00 00	 call	 _inner_interpreter
  01cf5	83 c4 0c	 add	 esp, 12			; 0000000cH
  01cf8	e9 75 ec ff ff	 jmp	 $L61519
$L58409:

; 509  : 			case FORW_RESOLVE: forw_resolve;	next;

  01cfd	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01d01	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01d04	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01d06	2b d0		 sub	 edx, eax
  01d08	83 c3 04	 add	 ebx, 4
  01d0b	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  01d0f	c1 fa 02	 sar	 edx, 2
  01d12	89 10		 mov	 DWORD PTR [eax], edx
  01d14	e9 4d e3 ff ff	 jmp	 $L58091
$L58413:

; 510  : 			case FORW_MARK:	  forw_mark;		next;

  01d19	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01d1d	83 eb 04	 sub	 ebx, 4
  01d20	89 03		 mov	 DWORD PTR [ebx], eax
  01d22	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01d25	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  01d29	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  01d2f	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01d32	83 c0 04	 add	 eax, 4
  01d35	89 47 70	 mov	 DWORD PTR [edi+112], eax
  01d38	e9 29 e3 ff ff	 jmp	 $L58091
$L58418:

; 511  : 			case LITERAL: 
; 512  : 				SAVE_XCONTEXT xcompile(PAREN_LIT); RESTORE_XCONTEXT comma; next;

  01d3d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  01d41	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  01d45	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  01d49	83 eb 04	 sub	 ebx, 4
  01d4c	83 ee 08	 sub	 esi, 8
  01d4f	89 0b		 mov	 DWORD PTR [ebx], ecx
  01d51	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  01d55	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01d5b	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  01d61	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  01d65	89 06		 mov	 DWORD PTR [esi], eax
  01d67	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  01d6a	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01d70	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01d76	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  01d7c	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01d7f	50		 push	 eax
  01d80	6a 71		 push	 113			; 00000071H
  01d82	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01d85	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  01d88	e8 00 00 00 00	 call	 _tokstore
$L61983:
  01d8d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01d93	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01d99	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01d9f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  01da5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01da8	8b 06		 mov	 eax, DWORD PTR [esi]
  01daa	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  01dae	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01db1	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  01db5	8b 03		 mov	 eax, DWORD PTR [ebx]
  01db7	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  01dbb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  01dc1	89 01		 mov	 DWORD PTR [ecx], eax
  01dc3	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01dc6	83 c3 04	 add	 ebx, 4
  01dc9	83 c1 04	 add	 ecx, 4
  01dcc	89 54 24 24	 mov	 DWORD PTR _rp$[esp+312], edx
  01dd0	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  01dd3	8b 13		 mov	 edx, DWORD PTR [ebx]
  01dd5	83 c6 08	 add	 esi, 8
  01dd8	83 c4 08	 add	 esp, 8
  01ddb	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01ddf	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01de3	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2553 : 				RESTORE_XCONTEXT

  01de7	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  01dea	e9 77 e2 ff ff	 jmp	 $L58091
$L58423:

; 513  : 			case DO:	SAVE_XCONTEXT pluslevel(); xcompile(P_DO);   

  01def	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  01df3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  01df7	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  01dfb	83 eb 04	 sub	 ebx, 4
  01dfe	83 ee 08	 sub	 esi, 8
  01e01	89 03		 mov	 DWORD PTR [ebx], eax
  01e03	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  01e07	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01e0d	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  01e13	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  01e17	89 16		 mov	 DWORD PTR [esi], edx
  01e19	89 46 04	 mov	 DWORD PTR [esi+4], eax
  01e1c	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  01e21	85 c0		 test	 eax, eax
  01e23	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01e29	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01e2f	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  01e35	74 08		 je	 SHORT $L61142
  01e37	40		 inc	 eax
  01e38	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01e3d	eb 30		 jmp	 SHORT $L61144
$L61142:
  01e3f	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01e42	85 c0		 test	 eax, eax
  01e44	75 29		 jne	 SHORT $L61144
  01e46	b8 01 00 00 00	 mov	 eax, 1
  01e4b	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01e50	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01e53	89 15 00 00 00
	00		 mov	 DWORD PTR _saved_dp, edx
  01e59	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET FLAT:_comp_buffer
  01e60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  01e66	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  01e69	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
$L61144:
  01e6f	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01e72	50		 push	 eax
  01e73	6a 6d		 push	 109			; 0000006dH
  01e75	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  01e78	89 57 70	 mov	 DWORD PTR [edi+112], edx
  01e7b	e8 00 00 00 00	 call	 _tokstore

; 514  : 				RESTORE_XCONTEXT

  01e80	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  01e85	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01e8b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01e91	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01e97	89 44 24 28	 mov	 DWORD PTR _frp$[esp+312], eax
  01e9b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  01ea0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01ea2	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01ea5	89 44 24 24	 mov	 DWORD PTR _rp$[esp+312], eax
  01ea9	8b 03		 mov	 eax, DWORD PTR [ebx]

; 515  : 				forw_mark;     back_mark;  next;

  01eab	89 03		 mov	 DWORD PTR [ebx], eax
  01ead	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01eb0	89 54 24 1c	 mov	 DWORD PTR _ftos$[esp+316], edx
  01eb4	83 c4 08	 add	 esp, 8
  01eb7	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  01ebd	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01ec0	83 c6 08	 add	 esi, 8
  01ec3	83 c2 04	 add	 edx, 4
  01ec6	83 eb 04	 sub	 ebx, 4
  01ec9	89 57 70	 mov	 DWORD PTR [edi+112], edx
  01ecc	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  01ed0	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01ed4	89 03		 mov	 DWORD PTR [ebx], eax
  01ed6	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01ed9	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  01edd	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  01ee1	e9 80 e1 ff ff	 jmp	 $L58091
$L58432:

; 516  : 			case QUES_DO: SAVE_XCONTEXT pluslevel(); 

  01ee6	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  01eea	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  01eee	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  01ef2	83 eb 04	 sub	 ebx, 4
  01ef5	83 ee 08	 sub	 esi, 8
  01ef8	89 13		 mov	 DWORD PTR [ebx], edx
  01efa	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  01efe	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01f04	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  01f09	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  01f0d	89 0e		 mov	 DWORD PTR [esi], ecx
  01f0f	89 56 04	 mov	 DWORD PTR [esi+4], edx
  01f12	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  01f17	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  01f1c	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  01f22	85 c0		 test	 eax, eax
  01f24	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  01f2a	74 08		 je	 SHORT $L61148
  01f2c	40		 inc	 eax
  01f2d	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01f32	eb 30		 jmp	 SHORT $L61150
$L61148:
  01f34	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  01f37	85 c0		 test	 eax, eax
  01f39	75 29		 jne	 SHORT $L61150
  01f3b	b8 01 00 00 00	 mov	 eax, 1
  01f40	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  01f45	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  01f48	89 0d 00 00 00
	00		 mov	 DWORD PTR _saved_dp, ecx
  01f4e	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET FLAT:_comp_buffer
  01f55	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  01f5b	89 42 18	 mov	 DWORD PTR [edx+24], eax
  01f5e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
$L61150:

; 517  : 				xcompile(PAREN_QUESTION_DO);

  01f64	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01f67	50		 push	 eax
  01f68	68 89 00 00 00	 push	 137			; 00000089H
  01f6d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  01f70	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  01f73	e8 00 00 00 00	 call	 _tokstore

; 518  : 				RESTORE_XCONTEXT    forw_mark;	 back_mark;	 next;

  01f78	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  01f7e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  01f84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  01f8a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  01f90	8b 06		 mov	 eax, DWORD PTR [esi]
  01f92	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01f95	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  01f99	8b 03		 mov	 eax, DWORD PTR [ebx]
  01f9b	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  01f9f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  01fa5	89 03		 mov	 DWORD PTR [ebx], eax
  01fa7	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01faa	89 54 24 24	 mov	 DWORD PTR _rp$[esp+312], edx
  01fae	83 c4 08	 add	 esp, 8
  01fb1	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  01fb7	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  01fba	83 c6 08	 add	 esi, 8
  01fbd	83 c2 04	 add	 edx, 4
  01fc0	83 eb 04	 sub	 ebx, 4
  01fc3	89 57 70	 mov	 DWORD PTR [edi+112], edx
  01fc6	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  01fca	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  01fce	89 03		 mov	 DWORD PTR [ebx], eax
  01fd0	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  01fd3	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2298 : 				push(scr);

  01fd7	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  01fdb	e9 86 e0 ff ff	 jmp	 $L58091
$L58441:

; 519  : 			case LOOP:	SAVE_XCONTEXT xcompile(PAREN_LOOP);  RESTORE_XCONTEXT

  01fe0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  01fe4	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  01fe8	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  01fec	83 eb 04	 sub	 ebx, 4
  01fef	83 ee 08	 sub	 esi, 8
  01ff2	89 0b		 mov	 DWORD PTR [ebx], ecx
  01ff4	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  01ff8	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  01ffe	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02004	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  02008	89 06		 mov	 DWORD PTR [esi], eax
  0200a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0200d	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02013	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02019	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0201f	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  02022	50		 push	 eax
  02023	6a 6e		 push	 110			; 0000006eH
  02025	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  02028	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  0202b	e8 00 00 00 00	 call	 _tokstore
  02030	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  02036	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0203c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  02042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  02048	8b 06		 mov	 eax, DWORD PTR [esi]
  0204a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0204d	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  02051	8b 03		 mov	 eax, DWORD PTR [ebx]
  02053	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx

; 520  : 				back_resolve; forw_resolve;

  02057	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  0205a	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  0205e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  02064	83 c3 04	 add	 ebx, 4
  02067	2b c1		 sub	 eax, ecx
  02069	89 54 24 24	 mov	 DWORD PTR _rp$[esp+312], edx
  0206d	83 c4 08	 add	 esp, 8
  02070	8b 13		 mov	 edx, DWORD PTR [ebx]
  02072	83 c3 04	 add	 ebx, 4
  02075	c1 f8 02	 sar	 eax, 2
  02078	89 01		 mov	 DWORD PTR [ecx], eax
  0207a	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0207d	83 c0 04	 add	 eax, 4
  02080	8b ca		 mov	 ecx, edx
  02082	89 47 70	 mov	 DWORD PTR [edi+112], eax
  02085	8b 13		 mov	 edx, DWORD PTR [ebx]
  02087	2b c1		 sub	 eax, ecx
  02089	83 c6 08	 add	 esi, 8
  0208c	c1 f8 02	 sar	 eax, 2
  0208f	89 01		 mov	 DWORD PTR [ecx], eax

; 521  : 				minuslevel; next;

  02091	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  02096	83 c3 04	 add	 ebx, 4
  02099	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  0209d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  020a0	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  020a4	85 c9		 test	 ecx, ecx
  020a6	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  020aa	75 12		 jne	 SHORT $L61161
$L61980:
  020ac	68 00 00 00 00	 push	 OFFSET FLAT:$SG60366
  020b1	e8 00 00 00 00	 call	 _error
  020b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  020bb	83 c4 04	 add	 esp, 4

; 524  : 				forw_resolve;  minuslevel;  next;

$L61161:
  020be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _comp_level
  020c4	85 c9		 test	 ecx, ecx
  020c6	0f 84 92 df ff
	ff		 je	 $L61881
  020cc	49		 dec	 ecx
  020cd	89 0d 00 00 00
	00		 mov	 DWORD PTR _comp_level, ecx
  020d3	0f 85 85 df ff
	ff		 jne	 $L61881
  020d9	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  020dc	51		 push	 ecx
  020dd	6a 69		 push	 105			; 00000069H
  020df	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  020e2	89 50 70	 mov	 DWORD PTR [eax+112], edx
  020e5	e8 00 00 00 00	 call	 _tokstore
  020ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  020ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _saved_dp
  020f5	83 eb 04	 sub	 ebx, 4
  020f8	83 ee 08	 sub	 esi, 8
  020fb	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  020fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  02104	8b 44 24 14	 mov	 eax, DWORD PTR _tos$[esp+312]
  02108	8b 4c 24 24	 mov	 ecx, DWORD PTR _rp$[esp+312]
  0210c	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0
  02113	8b 54 24 18	 mov	 edx, DWORD PTR _ftos$[esp+312]
  02117	89 03		 mov	 DWORD PTR [ebx], eax
  02119	8b 44 24 1c	 mov	 eax, DWORD PTR _ftos$[esp+316]
  0211d	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02123	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  02129	8b 4c 24 28	 mov	 ecx, DWORD PTR _frp$[esp+312]
  0212d	89 16		 mov	 DWORD PTR [esi], edx
  0212f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  02132	68 00 00 00 00	 push	 OFFSET FLAT:_comp_buffer
  02137	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0213d	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02143	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  02149	e8 00 00 00 00	 call	 _inner_interpreter
  0214e	e9 4d 54 00 00	 jmp	 $L61949
$L58454:

; 522  : 			case PLUS_LOOP:	SAVE_XCONTEXT xcompile(PAREN_PLUS_LOOP);

  02153	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  02157	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0215b	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0215f	83 eb 04	 sub	 ebx, 4
  02162	83 ee 08	 sub	 esi, 8
  02165	89 0b		 mov	 DWORD PTR [ebx], ecx
  02167	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0216b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02171	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02177	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  0217b	89 06		 mov	 DWORD PTR [esi], eax
  0217d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  02180	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02186	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0218c	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  02192	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  02195	50		 push	 eax
  02196	6a 6f		 push	 111			; 0000006fH
  02198	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0219b	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
$L61986:
  0219e	e8 00 00 00 00	 call	 _tokstore

; 523  : 				RESTORE_XCONTEXT back_resolve;

  021a3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  021a9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  021af	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  021b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  021bb	8b 06		 mov	 eax, DWORD PTR [esi]
  021bd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  021c0	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  021c4	8b 03		 mov	 eax, DWORD PTR [ebx]
  021c6	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  021ca	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  021cd	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  021d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  021d7	83 c3 04	 add	 ebx, 4
  021da	2b c1		 sub	 eax, ecx
  021dc	89 54 24 24	 mov	 DWORD PTR _rp$[esp+312], edx
  021e0	83 c4 08	 add	 esp, 8
  021e3	8b 13		 mov	 edx, DWORD PTR [ebx]
  021e5	83 c3 04	 add	 ebx, 4
  021e8	c1 f8 02	 sar	 eax, 2
  021eb	89 01		 mov	 DWORD PTR [ecx], eax
  021ed	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  021f0	83 c0 04	 add	 eax, 4

; 524  : 				forw_resolve;  minuslevel;  next;

  021f3	8b ca		 mov	 ecx, edx
  021f5	89 47 70	 mov	 DWORD PTR [edi+112], eax
  021f8	8b 13		 mov	 edx, DWORD PTR [ebx]
  021fa	2b c1		 sub	 eax, ecx
  021fc	83 c6 08	 add	 esi, 8
  021ff	83 c3 04	 add	 ebx, 4
  02202	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  02206	c1 f8 02	 sar	 eax, 2
  02209	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0220d	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  02211	89 01		 mov	 DWORD PTR [ecx], eax
  02213	e9 e6 02 00 00	 jmp	 $L61985
$L58467:

; 525  : 			case QUES_LEAVE: scr = pop;  if (!scr) { next; }

  02218	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0221c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0221e	83 c3 04	 add	 ebx, 4
  02221	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  02225	85 c0		 test	 eax, eax
  02227	0f 84 39 de ff
	ff		 je	 $L58091
$L58468:

; 526  : 				 /* else fall through */
; 527  : 			case LEAVE:		rp += 2;	/* Throw away the loop indices */

  0222d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  02231	83 c1 08	 add	 ecx, 8

; 528  : 				ip = *(token_t **)rp++; /* Go to location after (do */

  02234	8b 01		 mov	 eax, DWORD PTR [ecx]
  02236	83 c1 04	 add	 ecx, 4
  02239	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx

; 529  : 				branch;	      /* Get the offset there */

  0223d	8b 10		 mov	 edx, DWORD PTR [eax]
  0223f	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  02242	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 530  : 				next;

  02245	e9 1c de ff ff	 jmp	 $L58091
$L58472:

; 531  : 			case BEGIN: SAVE_XCONTEXT pluslevel(); RESTORE_XCONTEXT 

  0224a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0224e	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  02252	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  02256	83 eb 04	 sub	 ebx, 4
  02259	83 ee 08	 sub	 esi, 8
  0225c	89 0b		 mov	 DWORD PTR [ebx], ecx
  0225e	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  02262	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02268	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  0226e	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  02272	89 06		 mov	 DWORD PTR [esi], eax
  02274	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  02277	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  0227c	85 c0		 test	 eax, eax
  0227e	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02284	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0228a	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  02290	74 08		 je	 SHORT $L61168
  02292	40		 inc	 eax
  02293	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  02298	eb 2a		 jmp	 SHORT $L61170
$L61168:
  0229a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0229d	85 c0		 test	 eax, eax
  0229f	75 23		 jne	 SHORT $L61170
  022a1	b8 01 00 00 00	 mov	 eax, 1
  022a6	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  022ab	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  022ae	89 0d 00 00 00
	00		 mov	 DWORD PTR _saved_dp, ecx
  022b4	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [edi+112], OFFSET FLAT:_comp_buffer
  022bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  022c1	89 42 18	 mov	 DWORD PTR [edx+24], eax
$L61170:
  022c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  022c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  022cf	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  022d5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  022db	8b 0e		 mov	 ecx, DWORD PTR [esi]
  022dd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  022e0	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  022e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  022e9	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  022ed	8b 03		 mov	 eax, DWORD PTR [ebx]
  022ef	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx

; 532  : 				back_mark; next;

  022f3	89 03		 mov	 DWORD PTR [ebx], eax
  022f5	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  022f8	83 c6 08	 add	 esi, 8
  022fb	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  022ff	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  02303	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  02307	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0230b	e9 56 dd ff ff	 jmp	 $L58091
$L58475:

; 533  : 			case BACK_MARK:	back_mark;	     next;

  02310	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  02314	83 eb 04	 sub	 ebx, 4
  02317	89 13		 mov	 DWORD PTR [ebx], edx
  02319	8b 47 70	 mov	 eax, DWORD PTR [edi+112]

; 2298 : 				push(scr);

  0231c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  02320	e9 41 dd ff ff	 jmp	 $L58091
$L58478:

; 534  : 			case BACK_RESOLVE: back_resolve;	     next;

  02325	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02327	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0232b	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0232f	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  02332	2b c1		 sub	 eax, ecx
  02334	83 c3 04	 add	 ebx, 4
  02337	c1 f8 02	 sar	 eax, 2
  0233a	89 01		 mov	 DWORD PTR [ecx], eax
  0233c	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0233f	83 c0 04	 add	 eax, 4
  02342	89 47 70	 mov	 DWORD PTR [edi+112], eax
  02345	e9 1c dd ff ff	 jmp	 $L58091
$L58484:

; 535  : 
; 536  : 			case WHILE:	SAVE_XCONTEXT xcompile(QUES_BRANCH); RESTORE_XCONTEXT 

  0234a	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0234e	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  02352	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  02356	83 eb 04	 sub	 ebx, 4
  02359	83 ee 08	 sub	 esi, 8
  0235c	89 13		 mov	 DWORD PTR [ebx], edx
  0235e	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  02362	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02368	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  0236d	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  02371	89 0e		 mov	 DWORD PTR [esi], ecx
  02373	89 56 04	 mov	 DWORD PTR [esi+4], edx
  02376	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0237c	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02382	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  02387	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0238a	50		 push	 eax
  0238b	6a 76		 push	 118			; 00000076H
  0238d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  02390	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  02393	e8 00 00 00 00	 call	 _tokstore
  02398	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  0239e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  023a4	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  023aa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  023b0	8b 06		 mov	 eax, DWORD PTR [esi]
  023b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  023b5	83 c4 08	 add	 esp, 8
  023b8	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  023bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  023c2	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  023c6	8b 03		 mov	 eax, DWORD PTR [ebx]
  023c8	83 c6 08	 add	 esi, 8
  023cb	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  023cf	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  023d3	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  023d7	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx

; 537  : 				forw_mark; next;

  023db	89 03		 mov	 DWORD PTR [ebx], eax
$L61967:
  023dd	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  023e0	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  023e4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  023ea	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  023ed	83 c0 04	 add	 eax, 4
  023f0	89 47 70	 mov	 DWORD PTR [edi+112], eax
  023f3	e9 6e dc ff ff	 jmp	 $L58091
$L58491:

; 538  : 			case REPEAT:scr = *sp; *sp = tos; tos = scr;   /* swap */

  023f8	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  023fc	8b 03		 mov	 eax, DWORD PTR [ebx]

; 539  : 				SAVE_XCONTEXT xcompile(BRANCH); RESTORE_XCONTEXT

  023fe	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  02402	89 0b		 mov	 DWORD PTR [ebx], ecx
  02404	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  02408	83 eb 04	 sub	 ebx, 4
  0240b	83 ee 08	 sub	 esi, 8
  0240e	89 03		 mov	 DWORD PTR [ebx], eax
  02410	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  02414	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0241a	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02420	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  02424	89 06		 mov	 DWORD PTR [esi], eax
  02426	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  02429	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0242f	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02435	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0243b	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0243e	50		 push	 eax
  0243f	6a 75		 push	 117			; 00000075H
  02441	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  02444	89 4f 70	 mov	 DWORD PTR [edi+112], ecx

; 540  : 				back_resolve; /* Branch back to begin */
; 541  : 				forw_resolve;		     /* Complete while */
; 542  : 				minuslevel; next;

  02447	e9 52 fd ff ff	 jmp	 $L61986
$L58504:

; 543  : 			case UNTIL:	SAVE_XCONTEXT xcompile(QUES_BRANCH); RESTORE_XCONTEXT

  0244c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  02450	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  02454	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  02458	83 eb 04	 sub	 ebx, 4
  0245b	83 ee 08	 sub	 esi, 8
  0245e	89 0b		 mov	 DWORD PTR [ebx], ecx
  02460	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  02464	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0246a	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02470	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  02474	89 06		 mov	 DWORD PTR [esi], eax
  02476	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  02479	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0247f	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02485	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0248b	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0248e	50		 push	 eax
  0248f	6a 76		 push	 118			; 00000076H
  02491	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  02494	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  02497	e8 00 00 00 00	 call	 _tokstore
  0249c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  024a2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  024a8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  024ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  024b4	8b 06		 mov	 eax, DWORD PTR [esi]
  024b6	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  024b9	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  024bd	8b 03		 mov	 eax, DWORD PTR [ebx]
  024bf	83 c3 04	 add	 ebx, 4
  024c2	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  024c6	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  024ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp

; 544  : 				back_resolve;

  024d0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  024d2	89 54 24 24	 mov	 DWORD PTR _rp$[esp+312], edx
  024d6	89 4c 24 14	 mov	 DWORD PTR _tos$[esp+312], ecx
  024da	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  024dd	2b c1		 sub	 eax, ecx
  024df	83 c4 08	 add	 esp, 8
  024e2	c1 f8 02	 sar	 eax, 2
  024e5	89 01		 mov	 DWORD PTR [ecx], eax
  024e7	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  024ea	83 c6 08	 add	 esi, 8
  024ed	83 c3 04	 add	 ebx, 4
  024f0	83 c2 04	 add	 edx, 4
  024f3	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  024f7	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  024fb	89 57 70	 mov	 DWORD PTR [edi+112], edx
$L61985:

; 545  : 				minuslevel; next;

  024fe	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  02503	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  02506	85 c9		 test	 ecx, ecx
  02508	0f 85 b0 fb ff
	ff		 jne	 $L61161
  0250e	e9 99 fb ff ff	 jmp	 $L61980
$L58516:

; 546  :     case LEFT_BRACKET:	  V_STATE = (cell)INTERPRETING;  next;
; 547  :     case TICK:	{ u_char *temp;
; 548  : 	SAVE_XCONTEXT temp = canonical(blword());

  02513	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  02517	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0251b	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0251f	83 eb 04	 sub	 ebx, 4
  02522	83 ee 08	 sub	 esi, 8
  02525	89 0b		 mov	 DWORD PTR [ebx], ecx
  02527	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0252b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02531	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02537	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  0253b	89 06		 mov	 DWORD PTR [esi], eax
  0253d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  02540	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02546	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0254c	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  02552	e8 00 00 00 00	 call	 _blword
  02557	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  0255d	89 44 24 38	 mov	 DWORD PTR $T61196[esp+304], eax
  02561	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  02564	85 d2		 test	 edx, edx
  02566	74 26		 je	 SHORT $L61194
  02568	33 c9		 xor	 ecx, ecx
  0256a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0256d	8a 08		 mov	 cl, BYTE PTR [eax]
  0256f	8b f1		 mov	 esi, ecx
  02571	49		 dec	 ecx
  02572	85 f6		 test	 esi, esi
  02574	74 18		 je	 SHORT $L61194
  02576	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61192:
  02579	8a 0a		 mov	 cl, BYTE PTR [edx]
  0257b	80 f9 41	 cmp	 cl, 65			; 00000041H
  0257e	7c 0a		 jl	 SHORT $L61193
  02580	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  02583	7f 05		 jg	 SHORT $L61193
  02585	80 c1 20	 add	 cl, 32			; 00000020H
  02588	88 0a		 mov	 BYTE PTR [edx], cl
$L61193:
  0258a	42		 inc	 edx
  0258b	4e		 dec	 esi
  0258c	75 eb		 jne	 SHORT $L61192
$L61194:

; 549  : 	if ( find((cell *)&temp) ) { RESTORE_XCONTEXT push ( temp );  }

  0258e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
  02594	8b d0		 mov	 edx, eax
  02596	33 f6		 xor	 esi, esi
  02598	89 54 24 2c	 mov	 DWORD PTR _temp$58517[esp+304], edx
  0259c	85 c9		 test	 ecx, ecx
  0259e	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  025a4	7e 56		 jle	 SHORT $L61260
$L61259:
  025a6	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  025a9	33 db		 xor	 ebx, ebx
  025ab	8d 0c 4e	 lea	 ecx, DWORD PTR [esi+ecx*2]
  025ae	8a 1c 8d 00 00
	00 00		 mov	 bl, BYTE PTR _locnames[ecx*4]
  025b5	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR _locnames[ecx*4]
  025bc	8b fb		 mov	 edi, ebx
  025be	33 db		 xor	 ebx, ebx
  025c0	8a 18		 mov	 bl, BYTE PTR [eax]
  025c2	41		 inc	 ecx
  025c3	40		 inc	 eax
  025c4	3b df		 cmp	 ebx, edi
  025c6	75 1f		 jne	 SHORT $L61935
$L61263:
  025c8	8b d7		 mov	 edx, edi
  025ca	4f		 dec	 edi
  025cb	85 d2		 test	 edx, edx
  025cd	0f 84 a1 00 00
	00		 je	 $L61264
  025d3	8a 18		 mov	 bl, BYTE PTR [eax]
  025d5	8a 11		 mov	 dl, BYTE PTR [ecx]
  025d7	40		 inc	 eax
  025d8	41		 inc	 ecx
  025d9	3a d3		 cmp	 dl, bl
  025db	74 eb		 je	 SHORT $L61263
  025dd	8b 44 24 38	 mov	 eax, DWORD PTR $T61196[esp+304]
  025e1	8b 54 24 2c	 mov	 edx, DWORD PTR _temp$58517[esp+304]
  025e5	eb 04		 jmp	 SHORT $nextword$61262
$L61935:
  025e7	8b 44 24 38	 mov	 eax, DWORD PTR $T61196[esp+304]
$nextword$61262:
  025eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
  025f1	46		 inc	 esi
  025f2	3b f1		 cmp	 esi, ecx
  025f4	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  025fa	7c aa		 jl	 SHORT $L61259
$L61260:
  025fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  02601	33 f6		 xor	 esi, esi
  02603	33 c9		 xor	 ecx, ecx
  02605	89 74 24 5c	 mov	 DWORD PTR _i$61242[esp+304], esi
  02609	8d b8 b0 00 00
	00		 lea	 edi, DWORD PTR [eax+176]
  0260f	89 7c 24 30	 mov	 DWORD PTR -256+[esp+304], edi
$L61247:
  02613	8b 07		 mov	 eax, DWORD PTR [edi]
  02615	85 c0		 test	 eax, eax
  02617	0f 84 9a 00 00
	00		 je	 $L61248
  0261d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _origin
  02623	0f 84 8e 00 00
	00		 je	 $L61248
  02629	3b c6		 cmp	 eax, esi
  0262b	0f 84 80 00 00
	00		 je	 $L61252
  02631	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  02634	8b 1e		 mov	 ebx, DWORD PTR [esi]
  02636	85 db		 test	 ebx, ebx
  02638	89 5c 24 38	 mov	 DWORD PTR -248+[esp+304], ebx
  0263c	74 4d		 je	 SHORT $L61275
  0263e	33 c9		 xor	 ecx, ecx
  02640	8a 0a		 mov	 cl, BYTE PTR [edx]
  02642	89 4c 24 40	 mov	 DWORD PTR -240+[esp+304], ecx
$L61274:
  02646	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  02649	33 c9		 xor	 ecx, ecx
  0264b	8a 08		 mov	 cl, BYTE PTR [eax]
  0264d	40		 inc	 eax
  0264e	8b f9		 mov	 edi, ecx
  02650	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  02653	39 7c 24 40	 cmp	 DWORD PTR -240+[esp+304], edi
  02657	75 22		 jne	 SHORT $L61925
$L61278:
  02659	8b d7		 mov	 edx, edi
  0265b	4f		 dec	 edi
  0265c	85 d2		 test	 edx, edx
  0265e	74 2f		 je	 SHORT $L61279
  02660	8a 19		 mov	 bl, BYTE PTR [ecx]
  02662	8a 10		 mov	 dl, BYTE PTR [eax]
  02664	41		 inc	 ecx
  02665	40		 inc	 eax
  02666	3a d3		 cmp	 dl, bl
  02668	74 ef		 je	 SHORT $L61278
  0266a	8b 54 24 2c	 mov	 edx, DWORD PTR _temp$58517[esp+304]
  0266e	8b 5c 24 38	 mov	 ebx, DWORD PTR -248+[esp+304]
  02672	eb 0b		 jmp	 SHORT $nextword$61277
$L61264:
  02674	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_lnamebuf
  02679	eb 59		 jmp	 SHORT $L61855
$L61925:
  0267b	8b 54 24 2c	 mov	 edx, DWORD PTR _temp$58517[esp+304]
$nextword$61277:
  0267f	8b f3		 mov	 esi, ebx
  02681	8b 1e		 mov	 ebx, DWORD PTR [esi]
  02683	85 db		 test	 ebx, ebx
  02685	89 5c 24 38	 mov	 DWORD PTR -248+[esp+304], ebx
  02689	75 bb		 jne	 SHORT $L61274
$L61275:
  0268b	33 c9		 xor	 ecx, ecx
  0268d	eb 22		 jmp	 SHORT $L61252
$L61279:
  0268f	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  02692	33 c0		 xor	 eax, eax
  02694	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  02697	80 e1 01	 and	 cl, 1
  0269a	8d 54 30 09	 lea	 edx, DWORD PTR [eax+esi+9]
  0269e	83 e2 fc	 and	 edx, -4			; fffffffcH
  026a1	f6 d9		 neg	 cl
  026a3	1b c9		 sbb	 ecx, ecx
  026a5	89 54 24 2c	 mov	 DWORD PTR _temp$58517[esp+304], edx
  026a9	83 e1 02	 and	 ecx, 2
  026ac	49		 dec	 ecx
  026ad	85 c9		 test	 ecx, ecx
  026af	75 23		 jne	 SHORT $L61855
$L61252:
  026b1	8b 7c 24 30	 mov	 edi, DWORD PTR -256+[esp+304]
  026b5	8b 37		 mov	 esi, DWORD PTR [edi]
$L61248:
  026b7	8b 44 24 5c	 mov	 eax, DWORD PTR _i$61242[esp+304]
  026bb	83 c7 04	 add	 edi, 4
  026be	40		 inc	 eax
  026bf	89 7c 24 30	 mov	 DWORD PTR -256+[esp+304], edi
  026c3	83 f8 10	 cmp	 eax, 16			; 00000010H
  026c6	89 44 24 5c	 mov	 DWORD PTR _i$61242[esp+304], eax
  026ca	0f 8c 43 ff ff
	ff		 jl	 $L61247
  026d0	85 c9		 test	 ecx, ecx
  026d2	74 4a		 je	 SHORT $L58519
$L61855:
  026d4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  026da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  026e0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  026e6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  026ec	8b 06		 mov	 eax, DWORD PTR [esi]
  026ee	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  026f2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  026f5	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  026f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  026fe	83 c6 08	 add	 esi, 8
  02701	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  02705	8b 03		 mov	 eax, DWORD PTR [ebx]
  02707	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  0270b	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  0270f	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  02713	89 03		 mov	 DWORD PTR [ebx], eax
  02715	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 551  : 	} next;

  02719	e9 48 d9 ff ff	 jmp	 $L58091
$L58519:

; 550  : 	else		   { where();  RESTORE_XCONTEXT goto abort;}

  0271e	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  02723	83 c9 ff	 or	 ecx, -1
  02726	33 c0		 xor	 eax, eax
  02728	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _input_name
  0272e	f2 ae		 repne scasb
  02730	f7 d1		 not	 ecx
  02732	2b f9		 sub	 edi, ecx
  02734	8b d1		 mov	 edx, ecx
  02736	8b f7		 mov	 esi, edi
  02738	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0273d	c1 e9 02	 shr	 ecx, 2
  02740	f3 a5		 rep movsd
  02742	8b ca		 mov	 ecx, edx
  02744	83 e1 03	 and	 ecx, 3
  02747	f3 a4		 rep movsb
  02749	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0274e	83 c9 ff	 or	 ecx, -1
  02751	f2 ae		 repne scasb
  02753	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60211
  02759	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR $SG60211+2
  0275f	4f		 dec	 edi
  02760	66 89 07	 mov	 WORD PTR [edi], ax
  02763	88 4f 02	 mov	 BYTE PTR [edi+2], cl
  02766	8a 03		 mov	 al, BYTE PTR [ebx]
  02768	84 c0		 test	 al, al
  0276a	0f 84 f7 00 00
	00		 je	 $L61305
  02770	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02775	83 c9 ff	 or	 ecx, -1
  02778	33 c0		 xor	 eax, eax
  0277a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG60213
  02780	f2 ae		 repne scasb
  02782	a1 04 00 00 00	 mov	 eax, DWORD PTR $SG60213+4
  02787	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR $SG60213+8
  0278e	4f		 dec	 edi
  0278f	89 17		 mov	 DWORD PTR [edi], edx
  02791	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  02797	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0279a	66 89 4f 08	 mov	 WORD PTR [edi+8], cx
  0279e	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  027a1	83 c0 05	 add	 eax, 5
  027a4	33 d2		 xor	 edx, edx
  027a6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  027ab	8a 10		 mov	 dl, BYTE PTR [eax]
  027ad	40		 inc	 eax
  027ae	8b f2		 mov	 esi, edx
  027b0	4a		 dec	 edx
  027b1	85 f6		 test	 esi, esi
  027b3	74 0c		 je	 SHORT $L61312
  027b5	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L61311:
  027b8	8a 10		 mov	 dl, BYTE PTR [eax]
  027ba	88 11		 mov	 BYTE PTR [ecx], dl
  027bc	41		 inc	 ecx
  027bd	40		 inc	 eax
  027be	4e		 dec	 esi
  027bf	75 f7		 jne	 SHORT $L61311
$L61312:
  027c1	c6 01 00	 mov	 BYTE PTR [ecx], 0
  027c4	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  027c9	83 c9 ff	 or	 ecx, -1
  027cc	33 c0		 xor	 eax, eax
  027ce	f2 ae		 repne scasb
  027d0	f7 d1		 not	 ecx
  027d2	2b f9		 sub	 edi, ecx
  027d4	8b f7		 mov	 esi, edi
  027d6	8b d1		 mov	 edx, ecx
  027d8	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  027dd	83 c9 ff	 or	 ecx, -1
  027e0	f2 ae		 repne scasb
  027e2	8b ca		 mov	 ecx, edx
  027e4	4f		 dec	 edi
  027e5	c1 e9 02	 shr	 ecx, 2
  027e8	f3 a5		 rep movsd
  027ea	8b ca		 mov	 ecx, edx
  027ec	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  027f3	83 e1 03	 and	 ecx, 3
  027f6	f3 a4		 rep movsb
  027f8	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  027fd	83 c9 ff	 or	 ecx, -1
  02800	f2 ae		 repne scasb
  02802	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  02807	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  0280d	4f		 dec	 edi
  0280e	89 07		 mov	 DWORD PTR [edi], eax
  02810	8b c3		 mov	 eax, ebx
  02812	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  02815	33 c9		 xor	 ecx, ecx
  02817	40		 inc	 eax
  02818	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  0281c	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  0281f	8b f1		 mov	 esi, ecx
  02821	49		 dec	 ecx
  02822	85 f6		 test	 esi, esi
  02824	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  02829	74 0c		 je	 SHORT $L61318
  0282b	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61317:
  0282e	8a 08		 mov	 cl, BYTE PTR [eax]
  02830	88 0a		 mov	 BYTE PTR [edx], cl
  02832	42		 inc	 edx
  02833	40		 inc	 eax
  02834	4e		 dec	 esi
  02835	75 f7		 jne	 SHORT $L61317
$L61318:
  02837	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  0283c	83 c9 ff	 or	 ecx, -1
  0283f	33 c0		 xor	 eax, eax
  02841	c6 02 00	 mov	 BYTE PTR [edx], 0
  02844	f2 ae		 repne scasb
  02846	f7 d1		 not	 ecx
  02848	2b f9		 sub	 edi, ecx
  0284a	8b f7		 mov	 esi, edi
  0284c	8b d1		 mov	 edx, ecx
  0284e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02853	83 c9 ff	 or	 ecx, -1
  02856	f2 ae		 repne scasb
  02858	8b ca		 mov	 ecx, edx
  0285a	4f		 dec	 edi
  0285b	c1 e9 02	 shr	 ecx, 2
  0285e	f3 a5		 rep movsd
  02860	8b ca		 mov	 ecx, edx
  02862	83 e1 03	 and	 ecx, 3
  02865	f3 a4		 rep movsb
$L61305:
  02867	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0286c	83 c9 ff	 or	 ecx, -1
  0286f	33 c0		 xor	 eax, eax
  02871	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  02876	f2 ae		 repne scasb
  02878	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  0287e	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  02882	e8 00 00 00 00	 call	 _error
  02887	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfsp
  0288c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  02892	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  02898	89 4c 24 2c	 mov	 DWORD PTR _up$[esp+308], ecx
  0289c	8b 10		 mov	 edx, DWORD PTR [eax]
  0289e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  028a1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  028a3	8b 7c 24 2c	 mov	 edi, DWORD PTR _up$[esp+308]
  028a7	83 c4 04	 add	 esp, 4
  028aa	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  028ae	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  028b2	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  028b6	83 c3 04	 add	 ebx, 4
  028b9	e9 3a 08 00 00	 jmp	 $abort$58103
$L58522:

; 552  : 
; 553  :     case BRAC_TICK: SAVE_XCONTEXT xcompile(PAREN_TICK); RESTORE_XCONTEXT

  028be	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  028c2	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  028c6	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  028ca	83 eb 04	 sub	 ebx, 4
  028cd	83 ee 08	 sub	 esi, 8
  028d0	89 13		 mov	 DWORD PTR [ebx], edx
  028d2	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  028d6	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  028dc	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  028e1	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  028e5	89 0e		 mov	 DWORD PTR [esi], ecx
  028e7	89 56 04	 mov	 DWORD PTR [esi+4], edx
  028ea	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  028f0	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  028f6	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  028fb	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  028fe	50		 push	 eax
  028ff	6a 72		 push	 114			; 00000072H
  02901	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  02904	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
  02907	e8 00 00 00 00	 call	 _tokstore
  0290c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  02912	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  02918	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  0291e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  02924	8b 06		 mov	 eax, DWORD PTR [esi]
  02926	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02929	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  0292d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  02933	89 44 24 18	 mov	 DWORD PTR _ftos$[esp+312], eax
  02937	8b 03		 mov	 eax, DWORD PTR [ebx]
  02939	83 c4 08	 add	 esp, 8
  0293c	83 c6 08	 add	 esi, 8
  0293f	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  02943	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  02947	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  0294b	83 c3 04	 add	 ebx, 4
$L58525:

; 554  : 	/* Yes, it is correct that there is no "next" here */
; 555  :     case BRAC_COMPILE: 
; 556  : 	SAVE_XCONTEXT scompile(canonical(blword ())); RESTORE_XCONTEXT next;

  0294e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  02952	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  02956	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0295a	83 eb 04	 sub	 ebx, 4
  0295d	83 ee 08	 sub	 esi, 8
  02960	89 0b		 mov	 DWORD PTR [ebx], ecx
  02962	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  02966	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0296c	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  02972	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  02976	89 06		 mov	 DWORD PTR [esi], eax
  02978	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0297b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02981	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02987	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0298d	e8 00 00 00 00	 call	 _blword
  02992	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  02998	89 44 24 40	 mov	 DWORD PTR $T61330[esp+304], eax
  0299c	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0299f	85 d2		 test	 edx, edx
  029a1	74 26		 je	 SHORT $L61328
  029a3	33 c9		 xor	 ecx, ecx
  029a5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  029a8	8a 08		 mov	 cl, BYTE PTR [eax]
  029aa	8b f1		 mov	 esi, ecx
  029ac	49		 dec	 ecx
  029ad	85 f6		 test	 esi, esi
  029af	74 18		 je	 SHORT $L61328
  029b1	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61326:
  029b4	8a 0a		 mov	 cl, BYTE PTR [edx]
  029b6	80 f9 41	 cmp	 cl, 65			; 00000041H
  029b9	7c 0a		 jl	 SHORT $L61327
  029bb	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  029be	7f 05		 jg	 SHORT $L61327
  029c0	80 c1 20	 add	 cl, 32			; 00000020H
  029c3	88 0a		 mov	 BYTE PTR [edx], cl
$L61327:
  029c5	42		 inc	 edx
  029c6	4e		 dec	 esi
  029c7	75 eb		 jne	 SHORT $L61326
$L61328:
  029c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nlocnames
  029cf	8b c8		 mov	 ecx, eax
  029d1	33 f6		 xor	 esi, esi
  029d3	89 4c 24 2c	 mov	 DWORD PTR _tp$61469[esp+304], ecx
  029d7	85 d2		 test	 edx, edx
  029d9	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  029df	7e 58		 jle	 SHORT $L61493
$L61492:
  029e1	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  029e4	33 db		 xor	 ebx, ebx
  029e6	8a 18		 mov	 bl, BYTE PTR [eax]
  029e8	8d 0c 56	 lea	 ecx, DWORD PTR [esi+edx*2]
  029eb	33 d2		 xor	 edx, edx
  029ed	8a 14 8d 00 00
	00 00		 mov	 dl, BYTE PTR _locnames[ecx*4]
  029f4	8d 0c 8d 00 00
	00 00		 lea	 ecx, DWORD PTR _locnames[ecx*4]
  029fb	8b fa		 mov	 edi, edx
  029fd	41		 inc	 ecx
  029fe	3b df		 cmp	 ebx, edi
  02a00	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  02a03	75 1f		 jne	 SHORT $L61932
$L61496:
  02a05	8b c7		 mov	 eax, edi
  02a07	4f		 dec	 edi
  02a08	85 c0		 test	 eax, eax
  02a0a	0f 84 ab 00 00
	00		 je	 $L61497
  02a10	8a 1a		 mov	 bl, BYTE PTR [edx]
  02a12	8a 01		 mov	 al, BYTE PTR [ecx]
  02a14	42		 inc	 edx
  02a15	41		 inc	 ecx
  02a16	3a c3		 cmp	 al, bl
  02a18	74 eb		 je	 SHORT $L61496
  02a1a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _tp$61469[esp+304]
  02a1e	8b 44 24 40	 mov	 eax, DWORD PTR $T61330[esp+304]
  02a22	eb 04		 jmp	 SHORT $nextword$61495
$L61932:
  02a24	8b 4c 24 2c	 mov	 ecx, DWORD PTR _tp$61469[esp+304]
$nextword$61495:
  02a28	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nlocnames
  02a2e	46		 inc	 esi
  02a2f	3b f2		 cmp	 esi, edx
  02a31	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  02a37	7c a8		 jl	 SHORT $L61492
$L61493:
  02a39	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  02a3e	33 d2		 xor	 edx, edx
  02a40	33 f6		 xor	 esi, esi
  02a42	8d b8 b0 00 00
	00		 lea	 edi, DWORD PTR [eax+176]
  02a48	89 74 24 5c	 mov	 DWORD PTR _i$61475[esp+304], esi
  02a4c	89 7c 24 30	 mov	 DWORD PTR -256+[esp+304], edi
$L61480:
  02a50	8b 07		 mov	 eax, DWORD PTR [edi]
  02a52	85 c0		 test	 eax, eax
  02a54	0f 84 90 00 00
	00		 je	 $L61481
  02a5a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _origin
  02a60	0f 84 84 00 00
	00		 je	 $L61481
  02a66	3b c6		 cmp	 eax, esi
  02a68	74 7a		 je	 SHORT $L61485
  02a6a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  02a6d	8b 16		 mov	 edx, DWORD PTR [esi]
  02a6f	85 d2		 test	 edx, edx
  02a71	89 54 24 38	 mov	 DWORD PTR -248+[esp+304], edx
  02a75	74 40		 je	 SHORT $L61508
  02a77	33 c0		 xor	 eax, eax
  02a79	8a 01		 mov	 al, BYTE PTR [ecx]
  02a7b	89 44 24 40	 mov	 DWORD PTR -240+[esp+304], eax
$L61507:
  02a7f	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  02a82	33 db		 xor	 ebx, ebx
  02a84	8a 18		 mov	 bl, BYTE PTR [eax]
  02a86	40		 inc	 eax
  02a87	8b fb		 mov	 edi, ebx
  02a89	8b 5c 24 40	 mov	 ebx, DWORD PTR -240+[esp+304]
  02a8d	41		 inc	 ecx
  02a8e	3b df		 cmp	 ebx, edi
  02a90	75 15		 jne	 SHORT $L61924
$L61511:
  02a92	8b d7		 mov	 edx, edi
  02a94	4f		 dec	 edi
  02a95	85 d2		 test	 edx, edx
  02a97	74 29		 je	 SHORT $L61512
  02a99	8a 19		 mov	 bl, BYTE PTR [ecx]
  02a9b	8a 10		 mov	 dl, BYTE PTR [eax]
  02a9d	41		 inc	 ecx
  02a9e	40		 inc	 eax
  02a9f	3a d3		 cmp	 dl, bl
  02aa1	74 ef		 je	 SHORT $L61511
  02aa3	8b 54 24 38	 mov	 edx, DWORD PTR -248+[esp+304]
$L61924:
  02aa7	8b 4c 24 2c	 mov	 ecx, DWORD PTR _tp$61469[esp+304]
  02aab	8b f2		 mov	 esi, edx
$nextword$61510:
  02aad	8b 16		 mov	 edx, DWORD PTR [esi]
  02aaf	85 d2		 test	 edx, edx
  02ab1	89 54 24 38	 mov	 DWORD PTR -248+[esp+304], edx
  02ab5	75 c8		 jne	 SHORT $L61507
$L61508:
  02ab7	33 d2		 xor	 edx, edx
  02ab9	eb 29		 jmp	 SHORT $L61485
$L61497:
  02abb	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_lnamebuf
  02ac0	eb 45		 jmp	 SHORT $L61857
$L61512:
  02ac2	8a 56 04	 mov	 dl, BYTE PTR [esi+4]
  02ac5	33 c0		 xor	 eax, eax
  02ac7	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  02aca	80 e2 01	 and	 dl, 1
  02acd	8d 4c 30 09	 lea	 ecx, DWORD PTR [eax+esi+9]
  02ad1	83 e1 fc	 and	 ecx, -4			; fffffffcH
  02ad4	f6 da		 neg	 dl
  02ad6	1b d2		 sbb	 edx, edx
  02ad8	89 4c 24 2c	 mov	 DWORD PTR _tp$61469[esp+304], ecx
  02adc	83 e2 02	 and	 edx, 2
  02adf	4a		 dec	 edx
  02ae0	85 d2		 test	 edx, edx
  02ae2	75 23		 jne	 SHORT $L61857
$L61485:
  02ae4	8b 7c 24 30	 mov	 edi, DWORD PTR -256+[esp+304]
  02ae8	8b 37		 mov	 esi, DWORD PTR [edi]
$L61481:
  02aea	8b 44 24 5c	 mov	 eax, DWORD PTR _i$61475[esp+304]
  02aee	83 c7 04	 add	 edi, 4
  02af1	40		 inc	 eax
  02af2	89 7c 24 30	 mov	 DWORD PTR -256+[esp+304], edi
  02af6	83 f8 10	 cmp	 eax, 16			; 00000010H
  02af9	89 44 24 5c	 mov	 DWORD PTR _i$61475[esp+304], eax
  02afd	0f 8c 4d ff ff
	ff		 jl	 $L61480
  02b03	85 d2		 test	 edx, edx
  02b05	74 29		 je	 SHORT $L61470
$L61857:
  02b07	8b 01		 mov	 eax, DWORD PTR [ecx]
  02b09	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  02b0e	73 02		 jae	 SHORT $L61471
  02b10	8b c8		 mov	 ecx, eax
$L61471:
  02b12	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  02b18	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  02b1b	50		 push	 eax
  02b1c	51		 push	 ecx
  02b1d	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  02b20	89 72 70	 mov	 DWORD PTR [edx+112], esi
  02b23	e8 00 00 00 00	 call	 _tokstore
  02b28	83 c4 08	 add	 esp, 8
  02b2b	e9 42 de ff ff	 jmp	 $L61519
$L61470:
  02b30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  02b36	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  02b39	50		 push	 eax
  02b3a	6a 78		 push	 120			; 00000078H
  02b3c	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  02b3f	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  02b42	e8 00 00 00 00	 call	 _tokstore
  02b47	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  02b4c	83 c9 ff	 or	 ecx, -1
  02b4f	33 c0		 xor	 eax, eax
  02b51	83 c4 08	 add	 esp, 8
  02b54	f2 ae		 repne scasb
  02b56	f7 d1		 not	 ecx
  02b58	2b f9		 sub	 edi, ecx
  02b5a	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR $SG60211+2
  02b60	8b c1		 mov	 eax, ecx
  02b62	8b f7		 mov	 esi, edi
  02b64	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02b69	c1 e9 02	 shr	 ecx, 2
  02b6c	f3 a5		 rep movsd
  02b6e	8b c8		 mov	 ecx, eax
  02b70	33 c0		 xor	 eax, eax
  02b72	83 e1 03	 and	 ecx, 3
  02b75	f3 a4		 rep movsb
  02b77	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02b7c	83 c9 ff	 or	 ecx, -1
  02b7f	f2 ae		 repne scasb
  02b81	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR $SG60211
  02b88	a1 00 00 00 00	 mov	 eax, DWORD PTR _input_name
  02b8d	4f		 dec	 edi
  02b8e	66 89 0f	 mov	 WORD PTR [edi], cx
  02b91	88 57 02	 mov	 BYTE PTR [edi+2], dl
  02b94	8a 08		 mov	 cl, BYTE PTR [eax]
  02b96	84 c9		 test	 cl, cl
  02b98	0f 84 fa 00 00
	00		 je	 $L61454
  02b9e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02ba3	83 c9 ff	 or	 ecx, -1
  02ba6	33 c0		 xor	 eax, eax
  02ba8	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG60213+4
  02bae	f2 ae		 repne scasb
  02bb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR $SG60213
  02bb6	66 a1 08 00 00
	00		 mov	 ax, WORD PTR $SG60213+8
  02bbc	4f		 dec	 edi
  02bbd	89 0f		 mov	 DWORD PTR [edi], ecx
  02bbf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  02bc5	89 57 04	 mov	 DWORD PTR [edi+4], edx
  02bc8	33 d2		 xor	 edx, edx
  02bca	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  02bce	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  02bd1	83 c0 05	 add	 eax, 5
  02bd4	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  02bd9	8a 10		 mov	 dl, BYTE PTR [eax]
  02bdb	40		 inc	 eax
  02bdc	8b f2		 mov	 esi, edx
  02bde	4a		 dec	 edx
  02bdf	85 f6		 test	 esi, esi
  02be1	74 0c		 je	 SHORT $L61460
  02be3	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L61459:
  02be6	8a 10		 mov	 dl, BYTE PTR [eax]
  02be8	88 11		 mov	 BYTE PTR [ecx], dl
  02bea	41		 inc	 ecx
  02beb	40		 inc	 eax
  02bec	4e		 dec	 esi
  02bed	75 f7		 jne	 SHORT $L61459
$L61460:
  02bef	c6 01 00	 mov	 BYTE PTR [ecx], 0
  02bf2	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  02bf7	83 c9 ff	 or	 ecx, -1
  02bfa	33 c0		 xor	 eax, eax
  02bfc	f2 ae		 repne scasb
  02bfe	f7 d1		 not	 ecx
  02c00	2b f9		 sub	 edi, ecx
  02c02	8b f7		 mov	 esi, edi
  02c04	8b d1		 mov	 edx, ecx
  02c06	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02c0b	83 c9 ff	 or	 ecx, -1
  02c0e	f2 ae		 repne scasb
  02c10	8b ca		 mov	 ecx, edx
  02c12	4f		 dec	 edi
  02c13	c1 e9 02	 shr	 ecx, 2
  02c16	f3 a5		 rep movsd
  02c18	8b ca		 mov	 ecx, edx
  02c1a	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  02c21	83 e1 03	 and	 ecx, 3
  02c24	f3 a4		 rep movsb
  02c26	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02c2b	83 c9 ff	 or	 ecx, -1
  02c2e	f2 ae		 repne scasb
  02c30	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  02c35	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  02c3b	4f		 dec	 edi
  02c3c	89 07		 mov	 DWORD PTR [edi], eax
  02c3e	a1 00 00 00 00	 mov	 eax, DWORD PTR _input_name
  02c43	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  02c46	33 c9		 xor	 ecx, ecx
  02c48	40		 inc	 eax
  02c49	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  02c4d	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  02c50	8b f1		 mov	 esi, ecx
  02c52	49		 dec	 ecx
  02c53	85 f6		 test	 esi, esi
  02c55	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  02c5a	74 0c		 je	 SHORT $L61466
  02c5c	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L61465:
  02c5f	8a 08		 mov	 cl, BYTE PTR [eax]
  02c61	88 0a		 mov	 BYTE PTR [edx], cl
  02c63	42		 inc	 edx
  02c64	40		 inc	 eax
  02c65	4e		 dec	 esi
  02c66	75 f7		 jne	 SHORT $L61465
$L61466:
  02c68	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  02c6d	83 c9 ff	 or	 ecx, -1
  02c70	33 c0		 xor	 eax, eax
  02c72	c6 02 00	 mov	 BYTE PTR [edx], 0
  02c75	f2 ae		 repne scasb
  02c77	f7 d1		 not	 ecx
  02c79	2b f9		 sub	 edi, ecx
  02c7b	8b f7		 mov	 esi, edi
  02c7d	8b d1		 mov	 edx, ecx
  02c7f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02c84	83 c9 ff	 or	 ecx, -1
  02c87	f2 ae		 repne scasb
  02c89	8b ca		 mov	 ecx, edx
  02c8b	4f		 dec	 edi
  02c8c	c1 e9 02	 shr	 ecx, 2
  02c8f	f3 a5		 rep movsd
  02c91	8b ca		 mov	 ecx, edx
  02c93	83 e1 03	 and	 ecx, 3
  02c96	f3 a4		 rep movsb
$L61454:
  02c98	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  02c9d	83 c9 ff	 or	 ecx, -1
  02ca0	33 c0		 xor	 eax, eax
  02ca2	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  02ca7	f2 ae		 repne scasb
  02ca9	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  02caf	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  02cb3	e8 00 00 00 00	 call	 _error
  02cb8	83 c4 04	 add	 esp, 4
  02cbb	e9 b2 dc ff ff	 jmp	 $L61519
$L58526:

; 557  :     case RIGHT_BRACKET:	  V_STATE = (cell)COMPILING;	  next;

  02cc0	c7 47 18 01 00
	00 00		 mov	 DWORD PTR [edi+24], 1
  02cc7	e9 9a d3 ff ff	 jmp	 $L58091
$L58528:

; 558  :     case PAREN_QUESTION_DO:
; 559  : 	scr = *sp++;

  02ccc	8b 03		 mov	 eax, DWORD PTR [ebx]

; 560  : 	if ( scr == tos ) { tos = *sp++; branch; next; }

  02cce	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  02cd2	83 c3 04	 add	 ebx, 4
  02cd5	3b c1		 cmp	 eax, ecx
  02cd7	75 1e		 jne	 SHORT $L58529
  02cd9	8b 03		 mov	 eax, DWORD PTR [ebx]
  02cdb	83 c3 04	 add	 ebx, 4
  02cde	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  02ce2	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02ce5	8b 08		 mov	 ecx, DWORD PTR [eax]
  02ce7	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  02cea	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  02ced	e9 74 d3 ff ff	 jmp	 $L58091
$L58534:

; 561  : 
; 562  : 	*(token_t **)--rp = ip++;		/* Address of offset to end */
; 563  : 	*(cell *)--rp =	scr ;		/* limit value */
; 564  : 	*(cell *)--rp = tos - scr ;		/* Distance up to 0 */
; 565  : 	tos = *sp++;
; 566  : 	next;
; 567  : 
; 568  :     case P_DO: 
; 569  : 	scr = *sp++;

  02cf2	8b 03		 mov	 eax, DWORD PTR [ebx]
  02cf4	83 c3 04	 add	 ebx, 4
$L58529:

; 570  : 	*(token_t **)--rp = ip++;		/* Address of offset to end */

  02cf7	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  02cfb	8b 55 08	 mov	 edx, DWORD PTR _ip$[ebp]
  02cfe	83 e9 04	 sub	 ecx, 4
  02d01	89 11		 mov	 DWORD PTR [ecx], edx
  02d03	83 c2 04	 add	 edx, 4

; 571  : 	*(cell *)--rp =	scr ;		/* limit value */

  02d06	83 e9 04	 sub	 ecx, 4
  02d09	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx

; 572  : 	*(cell *)--rp = tos - scr ;		/* Distance up to 0 */

  02d0c	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  02d10	89 01		 mov	 DWORD PTR [ecx], eax
  02d12	83 e9 04	 sub	 ecx, 4
  02d15	2b d0		 sub	 edx, eax
  02d17	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  02d1b	89 11		 mov	 DWORD PTR [ecx], edx

; 2553 : 				RESTORE_XCONTEXT

  02d1d	8b 03		 mov	 eax, DWORD PTR [ebx]
  02d1f	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  02d23	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  02d26	e9 3b d3 ff ff	 jmp	 $L58091
$L58538:

; 573  : 	tos = *sp++;
; 574  : 	next;
; 575  : 
; 576  :     case PAREN_LOOP: 
; 577  : 	if (++(*(cell *)rp) != 0) {

  02d2b	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  02d2f	8b 08		 mov	 ecx, DWORD PTR [eax]
  02d31	41		 inc	 ecx
  02d32	89 08		 mov	 DWORD PTR [eax], ecx
  02d34	74 10		 je	 SHORT $L58540

; 578  : 	    branch;

  02d36	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02d39	8b 08		 mov	 ecx, DWORD PTR [eax]
  02d3b	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  02d3e	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx

; 579  : 	    next;

  02d41	e9 20 d3 ff ff	 jmp	 $L58091
$L58540:

; 580  : 	}
; 581  : 	/* Loop terminates; clean up return stack and skip branch offset */
; 582  :         /* Pointer alignment */
; 583  : 	rp = (token_t **)((char *)rp + 2 * sizeof(cell) + sizeof(token_t *));

  02d46	83 c0 0c	 add	 eax, 12			; 0000000cH
  02d49	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax

; 584  : 	++ip; next;

  02d4d	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02d50	83 c0 04	 add	 eax, 4
  02d53	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  02d56	e9 0b d3 ff ff	 jmp	 $L58091
$L58546:

; 585  :     case PAREN_PLUS_LOOP: 
; 586  : 	/*
; 587  : 	 * The loop terminates when the index crosses the boundary between
; 588  : 	 * limit-1 and limit.  We have biased the internal copy of the index
; 589  : 	 * so that the loop terminates when the internal index crosses the
; 590  : 	 * boundary between -1 and 0.  In the +LOOP case, we have to cope
; 591  : 	 * with the possibility of either positive or negative increment
; 592  : 	 * values.  The following calculation assumes 2's-complement
; 593  : 	 * arithmetic.  It can be understood as follows:
; 594  : 	 * tos: increment value   scr: old biased index
; 595  : 	 * scr+tos: new biased index
; 596  : 	 * Continue looping if the new biased index and the increment
; 597  : 	 * value have different signs (we haven't crossed the boundary yet),
; 598  : 	 *r if the old biased index and the increment value have the
; 599  : 	 * same sign (we are more than half the number circle away from
; 600  : 	 * the -1/0 boundary).
; 601  : 	 * This scheme allows loops to work over both signed number ranges
; 602  : 	 * and unsigned address ranges, with problems at the "rollover"
; 603  : 	 * point where the largest signed positive integer is adjacent to
; 604  : 	 * the smallest negative integer.
; 605  : 	 * Typically, in assembly language Forth implementations, the
; 606  : 	 * index is biased to terminate at that rollover point, using the
; 607  : 	 * overflow bit to test for the boundary crossing.  The overflow
; 608  : 	 * bit is not available from C.  A calculation very similar to the
; 609  : 	 * following may be used to test for overflow (just interchange
; 610  : 	 * < and >=).  However, the normal LOOP case may be implemented more
; 611  : 	 * efficiently in C when the boundary is at 0, and we must use the
; 612  : 	 * same boundary for LOOP and +LOOP since the same DO sets up the
; 613  : 	 * biased index in both cases.
; 614  : 	 */
; 615  :         scr = *(cell *)rp;

  02d5b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]

; 616  : 	if ((((*(cell *)rp = scr+tos)^tos) < 0) || ((scr^tos) >= 0)) {

  02d5f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  02d63	8b 0a		 mov	 ecx, DWORD PTR [edx]
  02d65	03 c1		 add	 eax, ecx
  02d67	89 02		 mov	 DWORD PTR [edx], eax
  02d69	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  02d6d	33 c2		 xor	 eax, edx
  02d6f	7c 26		 jl	 SHORT $L58550
  02d71	33 ca		 xor	 ecx, edx
  02d73	7d 22		 jge	 SHORT $L58550

; 618  : 	}
; 619  : 	/* Loop terminates; clean up return stack and skip branch offset */
; 620  : 	tos = *sp++;

  02d75	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 621  :         /* Pointer alignment */
; 622  : 	rp = (token_t **)((char *)rp + 2 * sizeof(cell) + sizeof(token_t *));
; 623  : 	++ip; next;

  02d77	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02d7a	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  02d7e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  02d82	83 c3 04	 add	 ebx, 4
  02d85	83 c1 0c	 add	 ecx, 12			; 0000000cH
  02d88	83 c0 04	 add	 eax, 4
  02d8b	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  02d8f	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  02d92	e9 cf d2 ff ff	 jmp	 $L58091
$L58550:

; 617  : 	    tos = *sp++; branch; next;

  02d97	8b 13		 mov	 edx, DWORD PTR [ebx]
  02d99	83 c3 04	 add	 ebx, 4
  02d9c	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
$L59456:
  02da0	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02da3	8b 08		 mov	 ecx, DWORD PTR [eax]
  02da5	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  02da8	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  02dab	e9 b6 d2 ff ff	 jmp	 $L58091
$L58556:

; 624  : /*
; 625  :  * This is subtle.  The rule is that whenever a token appears on the stack,
; 626  :  * it is in the form of the absolute address of the code field of its header.
; 627  :  * When a token is stored in a definition, it is either the switch index
; 628  :  * for a primitive or the code-field-address.  (' has to decide which it
; 629  :  * is, and if it is the switch index, convert it to the appropriate cfa.
; 630  :  * A table of cfa's indexed by the switch index appears as the first thing
; 631  :  * in the dictionary, at origin.  This table is constructed by the code
; 632  :  * that initializes the dictionary.
; 633  :  */
; 634  :     case PAREN_TICK:	token = *(token_t **)ip++;

  02db0	8b 4d 08	 mov	 ecx, DWORD PTR _ip$[ebp]
  02db3	8b 01		 mov	 eax, DWORD PTR [ecx]
  02db5	83 c1 04	 add	 ecx, 4

; 635  : 			if ( (token_t)token < MAXPRIM )

  02db8	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  02dbd	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx
  02dc0	73 09		 jae	 SHORT $L58559

; 636  : 			    token = (token_t *)origin[(cell)token];

  02dc2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _origin
  02dc8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
$L58559:

; 637  : 			push ( token ); next;

  02dcb	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  02dcf	83 eb 04	 sub	 ebx, 4

; 2298 : 				push(scr);

  02dd2	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  02dd6	89 13		 mov	 DWORD PTR [ebx], edx

; 2299 : 				next;

  02dd8	e9 89 d2 ff ff	 jmp	 $L58091
$L58563:

; 638  : 
; 639  :     case PAREN_LIT:    push ( *ip++ );	  next;

  02ddd	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  02de1	83 eb 04	 sub	 ebx, 4
  02de4	89 03		 mov	 DWORD PTR [ebx], eax
  02de6	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02de9	8b 08		 mov	 ecx, DWORD PTR [eax]
  02deb	83 c0 04	 add	 eax, 4
  02dee	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  02df2	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  02df5	e9 6c d2 ff ff	 jmp	 $L58091
$L58565:

; 640  : 
; 641  :     case P_DOES:
; 642  : 	SAVE_XCONTEXT

  02dfa	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  02dfe	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  02e02	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  02e06	83 eb 04	 sub	 ebx, 4
  02e09	83 ee 08	 sub	 esi, 8
  02e0c	89 13		 mov	 DWORD PTR [ebx], edx
  02e0e	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  02e12	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02e18	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  02e1d	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  02e21	89 0e		 mov	 DWORD PTR [esi], ecx
  02e23	89 56 04	 mov	 DWORD PTR [esi+4], edx
  02e26	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02e2c	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02e32	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax

; 643  : 	tokstore((token_t)ip,
; 644  : 	         (cell *)name_from(&((dict_entry_t *)V_LAST) -> name));

  02e37	8b 7f 30	 mov	 edi, DWORD PTR [edi+48]
  02e3a	33 c9		 xor	 ecx, ecx
  02e3c	83 c7 05	 add	 edi, 5
  02e3f	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02e42	8a 0f		 mov	 cl, BYTE PTR [edi]
  02e44	8d 54 39 04	 lea	 edx, DWORD PTR [ecx+edi+4]
  02e48	83 e2 fc	 and	 edx, -4			; fffffffcH
  02e4b	52		 push	 edx
  02e4c	50		 push	 eax
  02e4d	e8 00 00 00 00	 call	 _tokstore

; 645  : 	RESTORE_XCONTEXT

  02e52	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  02e58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  02e5e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  02e64	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  02e6a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  02e6d	8b 16		 mov	 edx, DWORD PTR [esi]
  02e6f	89 44 24 1c	 mov	 DWORD PTR _ftos$[esp+316], eax
  02e73	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  02e78	89 4c 24 28	 mov	 DWORD PTR _frp$[esp+312], ecx
  02e7c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02e7e	89 54 24 18	 mov	 DWORD PTR _ftos$[esp+312], edx

; 646  : 	ip = *rp++;

  02e82	8b 10		 mov	 edx, DWORD PTR [eax]
  02e84	83 c4 08	 add	 esp, 8
  02e87	83 c6 08	 add	 esi, 8
  02e8a	83 c3 04	 add	 ebx, 4
  02e8d	83 c0 04	 add	 eax, 4
  02e90	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  02e94	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  02e98	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  02e9c	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  02e9f	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax

; 647  : 	next;

  02ea3	e9 be d1 ff ff	 jmp	 $L58091
$L58570:

; 651  : 	SAVE_XCONTEXT

  02ea8	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  02eac	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  02eb0	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  02eb4	83 eb 04	 sub	 ebx, 4
  02eb7	83 ee 08	 sub	 esi, 8
  02eba	89 03		 mov	 DWORD PTR [ebx], eax
  02ebc	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  02ec0	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02ec6	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  02ecc	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  02ed0	89 16		 mov	 DWORD PTR [esi], edx
  02ed2	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 652  : 	type( ascr+1, (cell)*ascr );

  02ed5	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02ed8	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  02ede	33 c9		 xor	 ecx, ecx
  02ee0	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02ee6	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  02eec	8a 08		 mov	 cl, BYTE PTR [eax]
  02eee	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  02ef1	8b d1		 mov	 edx, ecx
  02ef3	49		 dec	 ecx
  02ef4	85 d2		 test	 edx, edx
  02ef6	74 15		 je	 SHORT $L61533

; 648  : 
; 649  :     case P_DOT_QUOTE:
; 650  : 	ascr = (u_char *)ip;

  02ef8	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]

; 652  : 	type( ascr+1, (cell)*ascr );

$L61532:
  02efb	8a 06		 mov	 al, BYTE PTR [esi]
  02efd	46		 inc	 esi
  02efe	50		 push	 eax
  02eff	e8 00 00 00 00	 call	 _emit
  02f04	83 c4 04	 add	 esp, 4
  02f07	4f		 dec	 edi
  02f08	75 f1		 jne	 SHORT $L61532
  02f0a	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
$L61533:

; 653  : 	RESTORE_XCONTEXT

  02f0d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  02f13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  02f19	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  02f1f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  02f25	8b 16		 mov	 edx, DWORD PTR [esi]
  02f27	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  02f2b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02f2e	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  02f32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  02f38	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  02f3c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02f3e	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx

; 654  : 	ip = aligned( ascr + *ascr + 1 );

  02f42	33 d2		 xor	 edx, edx
  02f44	83 c6 08	 add	 esi, 8
  02f47	8a 10		 mov	 dl, BYTE PTR [eax]
  02f49	83 c3 04	 add	 ebx, 4
  02f4c	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  02f50	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  02f54	8d 44 02 04	 lea	 eax, DWORD PTR [edx+eax+4]
  02f58	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  02f5c	24 fc		 and	 al, -4			; fffffffcH
  02f5e	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 655  : 	next;

  02f61	e9 00 d1 ff ff	 jmp	 $L58091
$L58573:

; 656  :     case PAREN_ABORT_QUOTE:
; 657  : 	ascr = (u_char *)ip;
; 658  : 	if (tos != 0) {

  02f66	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  02f6a	85 c0		 test	 eax, eax
  02f6c	0f 84 87 00 00
	00		 je	 $L58575

; 659  : 	    SAVE_XCONTEXT

  02f72	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  02f76	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  02f7a	83 eb 04	 sub	 ebx, 4
  02f7d	83 ee 08	 sub	 esi, 8
  02f80	89 03		 mov	 DWORD PTR [ebx], eax
  02f82	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  02f86	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  02f8c	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  02f92	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  02f96	89 16		 mov	 DWORD PTR [esi], edx
  02f98	89 46 04	 mov	 DWORD PTR [esi+4], eax
  02f9b	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi

; 660  : 	    type(ascr+1, (cell)*ascr);

  02fa1	8b 7d 08	 mov	 edi, DWORD PTR _ip$[ebp]
  02fa4	33 c0		 xor	 eax, eax
  02fa6	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  02fac	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  02fb2	8a 07		 mov	 al, BYTE PTR [edi]
  02fb4	47		 inc	 edi
  02fb5	8b d0		 mov	 edx, eax
  02fb7	48		 dec	 eax
  02fb8	85 d2		 test	 edx, edx
  02fba	74 18		 je	 SHORT $L61543

; 659  : 	    SAVE_XCONTEXT

  02fbc	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 660  : 	    type(ascr+1, (cell)*ascr);

$L61542:
  02fbf	8a 07		 mov	 al, BYTE PTR [edi]
  02fc1	47		 inc	 edi
  02fc2	50		 push	 eax
  02fc3	e8 00 00 00 00	 call	 _emit
  02fc8	83 c4 04	 add	 esp, 4
  02fcb	4e		 dec	 esi
  02fcc	75 f1		 jne	 SHORT $L61542
  02fce	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
$L61543:

; 661  : 	    RESTORE_XCONTEXT

  02fd4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xsp
  02fda	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  02fe0	8b 06		 mov	 eax, DWORD PTR [esi]
  02fe2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  02fe5	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  02fe9	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  02fed	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  02ff1	8d 5a 04	 lea	 ebx, DWORD PTR [edx+4]

; 662  : 	    tos = *sp++;
; 663  : 	    goto abort;

  02ff4	e9 f6 00 00 00	 jmp	 $L61971
$L58575:

; 664  : 	}
; 665  : 	tos = *sp++;
; 666  : 	ip = aligned( ascr + *ascr + 1 );

  02ff9	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  02ffc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  02ffe	33 d2		 xor	 edx, edx
  03000	83 c3 04	 add	 ebx, 4
  03003	8a 10		 mov	 dl, BYTE PTR [eax]
  03005	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  03009	8d 44 02 04	 lea	 eax, DWORD PTR [edx+eax+4]
  0300d	24 fc		 and	 al, -4			; fffffffcH
  0300f	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 667  : 	next;

  03012	e9 4f d0 ff ff	 jmp	 $L58091
$L58577:

; 668  :     case PAREN_COMPILE: SAVE_XCONTEXT xcompile(*ip++); RESTORE_XCONTEXT next;

  03017	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0301b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0301f	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  03023	83 eb 04	 sub	 ebx, 4
  03026	83 ee 08	 sub	 esi, 8
  03029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0302b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0302f	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  03035	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  0303b	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  0303f	89 06		 mov	 DWORD PTR [esi], eax
  03041	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  03044	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0304a	8b 55 08	 mov	 edx, DWORD PTR _ip$[ebp]
  0304d	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  03053	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  03059	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0305c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0305e	83 c2 04	 add	 edx, 4
  03061	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx
  03064	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  03067	50		 push	 eax
  03068	51		 push	 ecx
  03069	89 57 70	 mov	 DWORD PTR [edi+112], edx
  0306c	e8 00 00 00 00	 call	 _tokstore
  03071	83 c4 08	 add	 esp, 8
  03074	e9 c5 d6 ff ff	 jmp	 $L60780
$L58580:

; 669  :     case BYE:
; 670  : 	ExitMeme(MEMESUCCESSFULSTATUS);

  03079	6a 00		 push	 0
  0307b	e8 00 00 00 00	 call	 _ExitMeme
  03080	83 c4 04	 add	 esp, 4
$L58581:

; 671  :     case LOSE: SAVE_XCONTEXT error("Undefined word encountered\n");  

  03083	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03087	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  0308b	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  0308f	83 eb 04	 sub	 ebx, 4
  03092	83 ee 08	 sub	 esi, 8
  03095	68 00 00 00 00	 push	 OFFSET FLAT:$SG58582
  0309a	89 13		 mov	 DWORD PTR [ebx], edx
  0309c	8b 54 24 18	 mov	 edx, DWORD PTR _ftos$[esp+312]
  030a0	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  030a6	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  030ab	8b 44 24 24	 mov	 eax, DWORD PTR _frp$[esp+308]
  030af	89 0e		 mov	 DWORD PTR [esi], ecx
  030b1	89 56 04	 mov	 DWORD PTR [esi+4], edx
  030b4	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  030ba	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  030c0	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  030c5	e8 00 00 00 00	 call	 _error

; 672  : 		RESTORE_XCONTEXT goto abort;

  030ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfsp
  030cf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  030d5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  030db	83 c4 04	 add	 esp, 4
  030de	8b 08		 mov	 ecx, DWORD PTR [eax]
  030e0	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  030e3	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  030e7	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  030eb	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
$L61971:
  030ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  030f1	83 c3 04	 add	 ebx, 4
  030f4	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
$abort$58103:
  030f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  030fd	85 c0		 test	 eax, eax
  030ff	74 09		 je	 SHORT $L58284
  03101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _saved_dp
  03107	89 4f 70	 mov	 DWORD PTR [edi+112], ecx
$L58284:
  0310a	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0310e	83 eb 04	 sub	 ebx, 4
  03111	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _comp_level, 0
  0311b	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  03123	89 13		 mov	 DWORD PTR [ebx], edx
  03125	eb 0c		 jmp	 SHORT $L61858
$L58287:

; 366  : #endif
; 367  : 			case ABORT:
; 368  : abort:
; 369  : 				if (comp_level) V_DP = (cell) saved_dp;
; 370  : 				comp_level = 0;
; 371  : 				push (-1);
; 372  : 				/* Fall through */
; 373  : 
; 374  : 			case THROW:
; 375  : 				if (tos != 0) {

  03127	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0312b	85 c0		 test	 eax, eax
  0312d	0f 84 f8 d1 ff
	ff		 je	 $L58288
$L61858:

; 376  : 					if (V_HANDLER == 0) {

  03133	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  03136	85 c0		 test	 eax, eax
  03138	75 31		 jne	 SHORT $L58289

; 377  : 						/* Modified for background tasks */
; 378  : 						rp = (token_t **)V_RPZERO;
; 379  : 						sp = ( (cell *)V_SPZERO ) + 1;

  0313a	8b 5f 24	 mov	 ebx, DWORD PTR [edi+36]
  0313d	8b 47 28	 mov	 eax, DWORD PTR [edi+40]

; 380  : 						fsp = ( (double *)V_FPZERO ) + 1;

  03140	8b b7 98 00 00
	00		 mov	 esi, DWORD PTR [edi+152]
  03146	83 c3 04	 add	 ebx, 4
  03149	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  0314d	83 c6 08	 add	 esi, 8

; 381  : 						frp = (cell *)0;

  03150	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _frp$[esp+304], 0
$throwexit$58294:

; 400  : 					tos = *sp++;
; 401  : 				}
; 402  : /* End of added code */
; 403  : 				next;
; 404  : 	    
; 405  : 			case QUIT:
; 406  : 				/* Don't let the inner interpreter exit unless we have
; 407  : 				 * the same task context as we had on entry.
; 408  : 				 */
; 409  : throwexit:
; 410  : 				if (entrycontext != up) {

  03158	39 7c 24 7c	 cmp	 DWORD PTR _entrycontext$[esp+304], edi
  0315c	0f 84 03 47 00
	00		 je	 $L58304

; 411  : 					--ip;	/* FIX: doesn't work with EXECUTE */

  03162	83 6d 08 04	 sub	 DWORD PTR _ip$[ebp], 4

; 412  : 					goto pause;

  03166	e9 c8 40 00 00	 jmp	 $pause$58247
$L58289:

; 382  : 						goto throwexit;
; 383  : 					}
; 384  : 					rp = (token_t **)V_HANDLER;
; 385  : 					V_HANDLER = (cell)*rp++;

  0316b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0316d	83 c0 04	 add	 eax, 4
  03170	89 4f 54	 mov	 DWORD PTR [edi+84], ecx

; 386  : /* NEW */
; 387  : 					frp = *(cell **)rp++;		/* Restore frame pointer */

  03173	8b 10		 mov	 edx, DWORD PTR [eax]

; 388  : 					fsp = *(double **)rp++;		/* Restore float stack ptr */
; 389  : 
; 390  : 					ulongp = (unsigned long *)rp;
; 391  : 					fbits.fb_long[1] = ulongp[0];

  03175	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  03178	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0317b	83 c0 04	 add	 eax, 4
  0317e	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  03182	89 0d 04 00 00
	00		 mov	 DWORD PTR _fbits+4, ecx

; 392  : 					fbits.fb_long[0] = ulongp[1];

  03188	8b 50 08	 mov	 edx, DWORD PTR [eax+8]

; 393  : 					rp = (token_t **)(ulongp+2);

  0318b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0318e	89 15 00 00 00
	00		 mov	 DWORD PTR _fbits, edx

; 394  : 					ftos = fbits.fb_float;		/* Restore float top of stk */

  03194	8b ca		 mov	 ecx, edx

; 395  : /* End NEW */
; 396  : 					sp = ((cell *)*rp++)+1;	    /* Err number remains in tos */

  03196	8b 18		 mov	 ebx, DWORD PTR [eax]
  03198	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _fbits+4
  0319e	83 c0 04	 add	 eax, 4
  031a1	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  031a5	83 c3 04	 add	 ebx, 4
  031a8	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 397  : 					ip = *rp++;

  031ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  031ae	83 c0 04	 add	 eax, 4
  031b1	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  031b5	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx
  031b8	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax

; 398  : /* Added this because THROW was leaving the zero on the stack */
; 399  : 				} else {

  031bc	e9 a5 ce ff ff	 jmp	 $L58091
$L58583:

; 673  : 
; 674  :     /* Don't need to modify sp to account for the top of stack being */
; 675  :     /* in a register because push has already put tos on the stack */
; 676  :     /* before the argument ( sp ) is evaluated */
; 677  : 
; 678  :     case SPFETCH:    push ( sp );	      next;

  031c1	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  031c5	83 eb 04	 sub	 ebx, 4
  031c8	89 5c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ebx
  031cc	89 03		 mov	 DWORD PTR [ebx], eax
  031ce	e9 93 ce ff ff	 jmp	 $L58091
$L58585:

; 679  :     case SPSTORE:    scr = pop;	 sp = (cell *)scr;  (void)pop;  next;

  031d3	8b 5c 24 0c	 mov	 ebx, DWORD PTR _tos$[esp+304]
  031d7	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2553 : 				RESTORE_XCONTEXT

  031d9	83 c3 04	 add	 ebx, 4
  031dc	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2554 : 			} next;

  031e0	e9 81 ce ff ff	 jmp	 $L58091
$L58588:

; 680  :     case RPFETCH:    push ( rp );	      next;

  031e5	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  031e9	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  031ed	83 eb 04	 sub	 ebx, 4

; 2298 : 				push(scr);

  031f0	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  031f4	89 13		 mov	 DWORD PTR [ebx], edx

; 2299 : 				next;

  031f6	e9 6b ce ff ff	 jmp	 $L58091
$L58590:

; 681  :     case RPSTORE:    rp = (token_t **)pop;    next;

  031fb	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  031ff	8b 13		 mov	 edx, DWORD PTR [ebx]
  03201	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  03205	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2553 : 				RESTORE_XCONTEXT

  03209	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  0320c	e9 55 ce ff ff	 jmp	 $L58091
$L58592:

; 682  :     case UPFETCH:    push ( up );	      next;

  03211	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03215	83 eb 04	 sub	 ebx, 4
  03218	89 7c 24 0c	 mov	 DWORD PTR _tos$[esp+304], edi
  0321c	89 03		 mov	 DWORD PTR [ebx], eax
  0321e	e9 43 ce ff ff	 jmp	 $L58091
$L58594:

; 683  :     case UPSTORE:    up = (cell *)pop;      next;

  03223	8b 7c 24 0c	 mov	 edi, DWORD PTR _tos$[esp+304]
  03227	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03229	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  0322d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2553 : 				RESTORE_XCONTEXT

  03231	83 c3 04	 add	 ebx, 4

; 2554 : 			} next;

  03234	e9 2d ce ff ff	 jmp	 $L58091
$L58596:

; 684  :     case TICK_WORD:  push ( &wordbuf[0] );    next;

  03239	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0323d	83 eb 04	 sub	 ebx, 4
  03240	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], OFFSET FLAT:_wordbuf
  03248	89 13		 mov	 DWORD PTR [ebx], edx
  0324a	e9 17 ce ff ff	 jmp	 $L58091
$L58598:

; 685  :     case DIVIDE_MOD: scr = *sp; *sp = scr%tos;

  0324f	8b 33		 mov	 esi, DWORD PTR [ebx]
  03251	8b c6		 mov	 eax, esi
  03253	99		 cdq
  03254	f7 7c 24 0c	 idiv	 DWORD PTR _tos$[esp+304]

; 686  : 		     if (((scr < 0) ^ (tos < 0))  &&  *sp != 0) {

  03258	33 c0		 xor	 eax, eax
  0325a	85 f6		 test	 esi, esi
  0325c	0f 9c c0	 setl	 al
  0325f	33 c9		 xor	 ecx, ecx
  03261	8b fa		 mov	 edi, edx
  03263	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03267	85 d2		 test	 edx, edx
  03269	0f 9c c1	 setl	 cl
  0326c	33 c1		 xor	 eax, ecx
  0326e	89 3b		 mov	 DWORD PTR [ebx], edi
  03270	74 19		 je	 SHORT $L58599
  03272	85 ff		 test	 edi, edi
  03274	74 15		 je	 SHORT $L58599

; 687  : 			    *sp += tos;
; 688  : 			    tos = (scr/tos) - 1;

  03276	8b c6		 mov	 eax, esi
  03278	8b ca		 mov	 ecx, edx
  0327a	99		 cdq
  0327b	f7 f9		 idiv	 ecx
  0327d	03 f9		 add	 edi, ecx
  0327f	89 3b		 mov	 DWORD PTR [ebx], edi
  03281	48		 dec	 eax
  03282	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 689  : 			    next;

  03286	e9 d3 cd ff ff	 jmp	 $L61881
$L58599:

; 690  : 		     }
; 691  : 		     tos = scr/tos; next;

  0328b	8b c6		 mov	 eax, esi
  0328d	99		 cdq
  0328e	f7 7c 24 0c	 idiv	 DWORD PTR _tos$[esp+304]
  03292	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03296	e9 c3 cd ff ff	 jmp	 $L61881
$L58600:

; 692  : 
; 693  :     case DNEGATE:   tos = ~tos + ((*sp = -*sp) == 0);	/* 2's complement */

  0329b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0329d	ba 00 00 00 00	 mov	 edx, 0
  032a2	f7 d8		 neg	 eax
  032a4	89 03		 mov	 DWORD PTR [ebx], eax
  032a6	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  032aa	0f 94 c2	 sete	 dl
  032ad	f7 d0		 not	 eax
  032af	03 d0		 add	 edx, eax
  032b1	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 694  : 		    next;

  032b5	e9 ac cd ff ff	 jmp	 $L58091
$L58601:

; 695  : 
; 696  :     case DMINUS:
; 697  : /* Borrow calculation assumes 2's complement arithmetic */
; 698  : #define BORROW(a,b)  ((u_cell)a < (u_cell)b)
; 699  : 
; 700  : #define al scr
; 701  : #define bl tos
; 702  : 		    {
; 703  : 			cell ah, bh;
; 704  :                         bh  = tos;      bl  = *sp++;

  032ba	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 705  :                         ah  = *sp++;    al  = *sp;

  032be	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  032c1	89 4c 24 40	 mov	 DWORD PTR _bh$58603[esp+304], ecx
  032c5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  032c7	83 c3 04	 add	 ebx, 4
  032ca	83 c3 04	 add	 ebx, 4
  032cd	8b 13		 mov	 edx, DWORD PTR [ebx]
  032cf	89 54 24 30	 mov	 DWORD PTR _scr$[esp+304], edx

; 706  : 			*sp = al - bl;  tos = ah - bh - BORROW(al, bl);

  032d3	2b d1		 sub	 edx, ecx
  032d5	89 13		 mov	 DWORD PTR [ebx], edx
  032d7	8b 54 24 30	 mov	 edx, DWORD PTR _scr$[esp+304]
  032db	3b d1		 cmp	 edx, ecx
  032dd	8b 4c 24 40	 mov	 ecx, DWORD PTR _bh$58603[esp+304]
  032e1	1b d2		 sbb	 edx, edx
  032e3	f7 da		 neg	 edx
  032e5	2b c2		 sub	 eax, edx
  032e7	2b c1		 sub	 eax, ecx

; 2298 : 				push(scr);

  032e9	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  032ed	e9 74 cd ff ff	 jmp	 $L58091
$L58606:

; 707  : 		    }
; 708  : #undef al
; 709  : #undef bl
; 710  : #undef BORROW
; 711  : 		    next;
; 712  :     case DPLUS:
; 713  : 
; 714  : /* Carry calculation assumes 2's complement arithmetic. */
; 715  : #define CARRY(res,b)  ((u_cell)res < (u_cell)b)
; 716  : #define al scr
; 717  : #define bl tos
; 718  : 		    {
; 719  : 			cell ah, bh;
; 720  : 
; 721  : 			bh  = tos;      bl  = *sp++;

  032f2	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 722  : 			ah  = *sp++;    al  = *sp;

  032f4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  032f7	83 c3 04	 add	 ebx, 4
  032fa	89 44 24 40	 mov	 DWORD PTR _ah$58607[esp+304], eax
  032fe	83 c3 04	 add	 ebx, 4
  03301	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]

; 723  : 			*sp = al += bl;  tos = ah + bh + CARRY(al, bl);

  03305	8b 03		 mov	 eax, DWORD PTR [ebx]
  03307	03 c1		 add	 eax, ecx
  03309	3b c1		 cmp	 eax, ecx
  0330b	89 03		 mov	 DWORD PTR [ebx], eax
  0330d	8b 44 24 40	 mov	 eax, DWORD PTR _ah$58607[esp+304]
  03311	1b c9		 sbb	 ecx, ecx
  03313	f7 d9		 neg	 ecx
  03315	03 c8		 add	 ecx, eax
  03317	03 ca		 add	 ecx, edx
  03319	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 724  : 		    }
; 725  : #undef al
; 726  : #undef bl
; 727  : #undef CARRY
; 728  : 		    next;

  0331d	e9 44 cd ff ff	 jmp	 $L58091
$L58611:

; 729  : 
; 730  :     case U_M_DIVIDE_MOD:
; 731  : 		     lscr = (long)*++sp;	/* Ignore upper half */

  03322	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  03325	83 c3 04	 add	 ebx, 4

; 732  :        		     *sp  = (cell)((unsigned long)lscr % (u_cell)tos);

  03328	8b c6		 mov	 eax, esi
  0332a	33 d2		 xor	 edx, edx
  0332c	f7 74 24 0c	 div	 DWORD PTR _tos$[esp+304]

; 733  : 		     tos  = (long)((unsigned long)lscr / (u_cell)tos);

  03330	8b c6		 mov	 eax, esi
  03332	89 13		 mov	 DWORD PTR [ebx], edx
  03334	33 d2		 xor	 edx, edx
  03336	f7 74 24 0c	 div	 DWORD PTR _tos$[esp+304]
  0333a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 734  : 		     next;

  0333e	e9 1b cd ff ff	 jmp	 $L61881
$L58619:

; 735  : 
; 736  :     case DIGIT:	     if ( (scr = digit ( tos, (u_char)*sp )) >= 0 ) {

  03343	8a 03		 mov	 al, BYTE PTR [ebx]
  03345	3c 30		 cmp	 al, 48			; 00000030H
  03347	88 44 24 78	 mov	 BYTE PTR $T61563[esp+304], al
  0334b	72 12		 jb	 SHORT $L61557
  0334d	3c 39		 cmp	 al, 57			; 00000039H
  0334f	77 0e		 ja	 SHORT $L61557
  03351	8b 44 24 78	 mov	 eax, DWORD PTR $T61563[esp+304]
  03355	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0335a	83 e8 30	 sub	 eax, 48			; 00000030H
  0335d	eb 2f		 jmp	 SHORT $L61562
$L61557:
  0335f	3c 61		 cmp	 al, 97			; 00000061H
  03361	72 12		 jb	 SHORT $L61559
  03363	3c 7a		 cmp	 al, 122			; 0000007aH
  03365	77 0e		 ja	 SHORT $L61559
  03367	8b 44 24 78	 mov	 eax, DWORD PTR $T61563[esp+304]
  0336b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03370	83 e8 57	 sub	 eax, 87			; 00000057H
  03373	eb 19		 jmp	 SHORT $L61562
$L61559:
  03375	3c 41		 cmp	 al, 65			; 00000041H
  03377	72 12		 jb	 SHORT $L61561
  03379	3c 5a		 cmp	 al, 90			; 0000005aH
  0337b	77 0e		 ja	 SHORT $L61561
  0337d	8b 44 24 78	 mov	 eax, DWORD PTR $T61563[esp+304]
  03381	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03386	83 e8 37	 sub	 eax, 55			; 00000037H
  03389	eb 03		 jmp	 SHORT $L61562
$L61561:
  0338b	83 c8 ff	 or	 eax, -1
$L61562:
  0338e	3b 44 24 0c	 cmp	 eax, DWORD PTR _tos$[esp+304]
  03392	0f 8d fd 1e 00
	00		 jge	 $L58621
  03398	85 c0		 test	 eax, eax
  0339a	0f 8c f5 1e 00
	00		 jl	 $L58621

; 737  : 			*sp = scr; tos = -1;

  033a0	89 03		 mov	 DWORD PTR [ebx], eax
  033a2	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1

; 738  : 		     } else

  033aa	e9 b7 cc ff ff	 jmp	 $L58091
$L58623:

; 739  : 			tos = 0;
; 740  : 		     next;
; 741  :     case NUM_QUESTION: {
; 742  : 	cell scr1;
; 743  : 	cell rtnval;
; 744  : 	scr = pop;

  033af	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 745  : 	SAVE_XCONTEXT

  033b1	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  033b5	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  033b9	89 0b		 mov	 DWORD PTR [ebx], ecx
  033bb	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  033bf	83 ee 08	 sub	 esi, 8
  033c2	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  033c8	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  033cc	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  033d2	89 0e		 mov	 DWORD PTR [esi], ecx
  033d4	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  033d8	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 746  : 	rtnval = number ( (u_char *) scr, (long *)&scr1 );

  033db	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR _scr1$58624[esp+304]
  033e2	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  033e8	52		 push	 edx
  033e9	50		 push	 eax
  033ea	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  033f0	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  033f6	e8 00 00 00 00	 call	 _number

; 747  : 	RESTORE_XCONTEXT

  033fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  03401	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  03407	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  0340d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  03413	8b 16		 mov	 edx, DWORD PTR [esi]
  03415	89 4c 24 28	 mov	 DWORD PTR _frp$[esp+312], ecx
  03419	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0341c	89 54 24 18	 mov	 DWORD PTR _ftos$[esp+312], edx
  03420	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  03426	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  0342a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0342c	83 c4 08	 add	 esp, 8

; 748  : 	push(scr1);

  0342f	89 0b		 mov	 DWORD PTR [ebx], ecx

; 749  : 	push(rtnval ? -1 : 0);

  03431	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR _scr1$58624[esp+304]
  03438	83 c6 08	 add	 esi, 8
  0343b	83 eb 04	 sub	 ebx, 4
  0343e	f7 d8		 neg	 eax
  03440	1b c0		 sbb	 eax, eax
  03442	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  03446	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0344a	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  0344e	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2298 : 				push(scr);

  03450	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  03454	e9 0d cc ff ff	 jmp	 $L58091
$L58630:

; 750  :     } next;
; 751  :     case HIDE: SAVE_XCONTEXT hide(); RESTORE_XCONTEXT next;

  03459	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0345d	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  03461	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  03465	83 eb 04	 sub	 ebx, 4
  03468	83 ee 08	 sub	 esi, 8
  0346b	89 13		 mov	 DWORD PTR [ebx], edx
  0346d	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  03471	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  03477	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  0347c	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  03480	89 0e		 mov	 DWORD PTR [esi], ecx
  03482	89 56 04	 mov	 DWORD PTR [esi+4], edx
  03485	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0348b	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  03491	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  03496	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  03499	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  0349c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0349e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  034a1	e9 cc d4 ff ff	 jmp	 $L61519
$L58631:

; 752  :     case REVEAL: SAVE_XCONTEXT reveal(); RESTORE_XCONTEXT next;

  034a6	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  034aa	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  034ae	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  034b2	83 eb 04	 sub	 ebx, 4
  034b5	83 ee 08	 sub	 esi, 8
  034b8	89 03		 mov	 DWORD PTR [ebx], eax
  034ba	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  034be	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  034c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  034ca	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  034ce	89 16		 mov	 DWORD PTR [esi], edx
  034d0	89 46 04	 mov	 DWORD PTR [esi+4], eax
  034d3	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  034d9	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  034df	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  034e5	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  034e8	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  034eb	89 42 04	 mov	 DWORD PTR [edx+4], eax
  034ee	e9 7f d4 ff ff	 jmp	 $L61519
$L58632:

; 753  :     case INPUT_FILE_NAME: push (input_name); next;

  034f3	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  034f7	83 eb 04	 sub	 ebx, 4
  034fa	89 03		 mov	 DWORD PTR [ebx], eax
  034fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _input_name
  03502	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  03506	e9 5b cb ff ff	 jmp	 $L58091
$L58634:

; 754  :     case QUOTE_LOAD: ascr = apop; SAVE_XCONTEXT load(ascr);	RESTORE_XCONTEXT next;

  0350b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0350d	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  03511	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03515	89 0b		 mov	 DWORD PTR [ebx], ecx
  03517	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  0351b	83 ee 08	 sub	 esi, 8
  0351e	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  03524	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  0352a	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0352e	89 0e		 mov	 DWORD PTR [esi], ecx
  03530	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  03534	89 56 04	 mov	 DWORD PTR [esi+4], edx
  03537	50		 push	 eax
  03538	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0353e	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  03544	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  0354a	e8 00 00 00 00	 call	 _load
  0354f	83 c4 04	 add	 esp, 4
  03552	e9 4c 40 00 00	 jmp	 $L60948
$L58636:

; 755  :     case FLOAD: SAVE_XCONTEXT load(blword());  RESTORE_XCONTEXT next;

  03557	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0355b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0355f	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  03563	83 eb 04	 sub	 ebx, 4
  03566	83 ee 08	 sub	 esi, 8
  03569	89 0b		 mov	 DWORD PTR [ebx], ecx
  0356b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0356f	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  03575	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  0357b	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  0357f	89 06		 mov	 DWORD PTR [esi], eax
  03581	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  03584	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0358a	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  03590	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  03596	e8 00 00 00 00	 call	 _blword
  0359b	50		 push	 eax
  0359c	e8 00 00 00 00	 call	 _load
  035a1	83 c4 04	 add	 esp, 4
  035a4	e9 cb 3a 00 00	 jmp	 $L61693
$L58637:

; 756  :     case SEMI_S:       load_pop();  next;

  035a9	e8 00 00 00 00	 call	 _load_pop
  035ae	e9 b3 ca ff ff	 jmp	 $L58091
$L58638:

; 757  :     case ORIGIN:       push( origin );	next;

  035b3	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  035b7	83 eb 04	 sub	 ebx, 4
  035ba	89 13		 mov	 DWORD PTR [ebx], edx
  035bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin

; 2298 : 				push(scr);

  035c1	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  035c5	e9 9c ca ff ff	 jmp	 $L58091
$L58640:

; 758  :     case CANONICAL:    (void)canonical((u_char *)tos); next;

  035ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  035d0	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  035d3	85 c0		 test	 eax, eax
  035d5	0f 84 8b ca ff
	ff		 je	 $L58091
  035db	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  035df	33 c0		 xor	 eax, eax
  035e1	8a 01		 mov	 al, BYTE PTR [ecx]
  035e3	41		 inc	 ecx
  035e4	8b d0		 mov	 edx, eax
  035e6	48		 dec	 eax
  035e7	85 d2		 test	 edx, edx
  035e9	0f 84 77 ca ff
	ff		 je	 $L58091
  035ef	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L61579:
  035f2	8a 01		 mov	 al, BYTE PTR [ecx]
  035f4	3c 41		 cmp	 al, 65			; 00000041H
  035f6	7c 08		 jl	 SHORT $L61580
  035f8	3c 5a		 cmp	 al, 90			; 0000005aH
  035fa	7f 04		 jg	 SHORT $L61580
  035fc	04 20		 add	 al, 32			; 00000020H
  035fe	88 01		 mov	 BYTE PTR [ecx], al
$L61580:
  03600	41		 inc	 ecx
  03601	4a		 dec	 edx
  03602	75 ee		 jne	 SHORT $L61579
  03604	e9 5d ca ff ff	 jmp	 $L58091
$L58643:

; 759  :     case MAXDP:        push( dict_end );next;

  03609	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0360d	83 eb 04	 sub	 ebx, 4
  03610	89 03		 mov	 DWORD PTR [ebx], eax
  03612	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dict_end
  03618	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0361c	e9 45 ca ff ff	 jmp	 $L58091
$L58645:

; 760  :     case MAXPRIMITIVE: push( MAXPRIM ); next;

  03621	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03625	83 eb 04	 sub	 ebx, 4
  03628	c7 44 24 0c 90
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 400 ; 00000190H
  03630	89 13		 mov	 DWORD PTR [ebx], edx
  03632	e9 2f ca ff ff	 jmp	 $L58091
$L58647:

; 761  :     case PER_N:        push( sizeof(cell) ); next;

  03637	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0363b	83 eb 04	 sub	 ebx, 4
  0363e	c7 44 24 0c 04
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 4
  03646	89 03		 mov	 DWORD PTR [ebx], eax
  03648	e9 19 ca ff ff	 jmp	 $L58091
$L58651:

; 762  :     case THIRTY_TWO_BACKSLASH:
; 763  : 			next;
; 764  :     case SIXTEEN_BACKSLASH:
; 765  : 			if (V_DELIMITER != '\n') {

  0364d	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  03650	8d 57 20	 lea	 edx, DWORD PTR [edi+32]
  03653	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  03656	0f 84 0a ca ff
	ff		 je	 $L58091

; 766  : 				SAVE_XCONTEXT

  0365c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  03660	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  03664	83 eb 04	 sub	 ebx, 4
  03667	83 ee 08	 sub	 esi, 8
  0366a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0366c	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  03670	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  03676	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  0367b	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  0367f	89 0e		 mov	 DWORD PTR [esi], ecx
  03681	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  03685	89 46 04	 mov	 DWORD PTR [esi+4], eax
  03688	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0368e	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  03694	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx

; 767  : 				(void)word('\n'); 

  0369a	8b 87 8c 00 00
	00		 mov	 eax, DWORD PTR [edi+140]
  036a0	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  036a3	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  036a6	03 c8		 add	 ecx, eax
  036a8	03 f8		 add	 edi, eax
  036aa	3b f9		 cmp	 edi, ecx
  036ac	b8 01 00 00 00	 mov	 eax, 1
  036b1	73 1c		 jae	 SHORT $L61797
$L61591:
  036b3	33 db		 xor	 ebx, ebx
  036b5	8a 1f		 mov	 bl, BYTE PTR [edi]
  036b7	47		 inc	 edi
  036b8	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  036bb	74 1a		 je	 SHORT $L61798
  036bd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  036c2	7d 07		 jge	 SHORT $L61596
  036c4	88 98 00 00 00
	00		 mov	 BYTE PTR _wordbuf[eax], bl
  036ca	40		 inc	 eax
$L61596:
  036cb	3b f9		 cmp	 edi, ecx
  036cd	72 e4		 jb	 SHORT $L61591
$L61797:
  036cf	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1
  036d5	eb 02		 jmp	 SHORT $finish$61594
$L61798:
  036d7	89 1a		 mov	 DWORD PTR [edx], ebx
$finish$61594:
  036d9	8a d0		 mov	 dl, al
  036db	fe ca		 dec	 dl
  036dd	88 15 00 00 00
	00		 mov	 BYTE PTR _wordbuf, dl
  036e3	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[eax], 0
  036ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  036ef	2b b8 8c 00 00
	00		 sub	 edi, DWORD PTR [eax+140]
  036f5	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 768  : 				RESTORE_XCONTEXT
; 769  : 			} next;

  036f8	e9 77 39 00 00	 jmp	 $L61693
$L58654:

; 770  :     case SYSCALL:  scr = pop; ascr1 = (u_char *)sp;

  036fd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  036ff	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 771  : 		   tos = dosyscall (scr, (u_char *)tos, (cell **)&ascr1);

  03703	8d 54 24 3c	 lea	 edx, DWORD PTR _ascr1$[esp+304]
  03707	83 c3 04	 add	 ebx, 4
  0370a	52		 push	 edx
  0370b	51		 push	 ecx
  0370c	50		 push	 eax
  0370d	89 5c 24 48	 mov	 DWORD PTR _ascr1$[esp+316], ebx
  03711	e8 00 00 00 00	 call	 _dosyscall

; 772  : 		   sp = (cell *)ascr1; next;	/* Pointer alignment */

  03716	8b 5c 24 48	 mov	 ebx, DWORD PTR _ascr1$[esp+316]
  0371a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0371d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03721	e9 40 c9 ff ff	 jmp	 $L58091
$L58659:

; 773  : 
; 774  :     case CCALL:    scr = pop; ascr1 = (u_char *)sp;

  03726	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03728	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 775  : 		   tos = doccall (scr, (u_char *)tos, (cell **)&ascr1);

  0372c	8d 54 24 3c	 lea	 edx, DWORD PTR _ascr1$[esp+304]
  03730	83 c3 04	 add	 ebx, 4
  03733	52		 push	 edx
  03734	51		 push	 ecx
  03735	50		 push	 eax
  03736	89 5c 24 48	 mov	 DWORD PTR _ascr1$[esp+316], ebx
  0373a	e8 00 00 00 00	 call	 _doccall

; 776  : 		   sp = (cell *)ascr1; next;	/* Pointer alignment */

  0373f	8b 5c 24 48	 mov	 ebx, DWORD PTR _ascr1$[esp+316]
  03743	83 c4 0c	 add	 esp, 12			; 0000000cH
  03746	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  0374a	e9 17 c9 ff ff	 jmp	 $L58091
$L58664:

; 777  : 
; 778  :     case COMMAND:  ascr = apop; ascr = (u_char *)tocstr(ascr);

  0374f	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03753	8b 03		 mov	 eax, DWORD PTR [ebx]
  03755	33 c9		 xor	 ecx, ecx
  03757	83 c3 04	 add	 ebx, 4
  0375a	8a 0a		 mov	 cl, BYTE PTR [edx]
  0375c	42		 inc	 edx
  0375d	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  03761	8b d1		 mov	 edx, ecx
  03763	49		 dec	 ecx
  03764	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03768	85 d2		 test	 edx, edx
  0376a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  0376f	74 1c		 je	 SHORT $L61603
  03771	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  03775	2b d0		 sub	 edx, eax
  03777	41		 inc	 ecx
  03778	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
$L61602:
  0377c	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  0377f	88 08		 mov	 BYTE PTR [eax], cl
  03781	8b 4c 24 38	 mov	 ecx, DWORD PTR -248+[esp+304]
  03785	40		 inc	 eax
  03786	49		 dec	 ecx
  03787	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
  0378b	75 ef		 jne	 SHORT $L61602
$L61603:

; 779  : 		   push(system((char *)ascr));

  0378d	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03791	83 eb 04	 sub	 ebx, 4
  03794	c6 00 00	 mov	 BYTE PTR [eax], 0
  03797	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  0379c	89 13		 mov	 DWORD PTR [ebx], edx
  0379e	e8 00 00 00 00	 call	 _system
  037a3	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  037a6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  037aa	e9 b7 c8 ff ff	 jmp	 $L58091
$L58669:

; 780  : 		   next;
; 781  :     case CHDIR:	   ascr = apop; ascr = (u_char *)tocstr(ascr);

  037af	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  037b3	8b 03		 mov	 eax, DWORD PTR [ebx]
  037b5	33 c9		 xor	 ecx, ecx
  037b7	83 c3 04	 add	 ebx, 4
  037ba	8a 0a		 mov	 cl, BYTE PTR [edx]
  037bc	42		 inc	 edx
  037bd	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  037c1	8b d1		 mov	 edx, ecx
  037c3	49		 dec	 ecx
  037c4	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  037c8	85 d2		 test	 edx, edx
  037ca	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  037cf	74 1c		 je	 SHORT $L61611
  037d1	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  037d5	2b d0		 sub	 edx, eax
  037d7	41		 inc	 ecx
  037d8	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
$L61610:
  037dc	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  037df	88 08		 mov	 BYTE PTR [eax], cl
  037e1	8b 4c 24 38	 mov	 ecx, DWORD PTR -248+[esp+304]
  037e5	40		 inc	 eax
  037e6	49		 dec	 ecx
  037e7	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
  037eb	75 ef		 jne	 SHORT $L61610
$L61611:

; 782  : 		   push(chdir((char *)ascr));

  037ed	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  037f1	83 eb 04	 sub	 ebx, 4
  037f4	c6 00 00	 mov	 BYTE PTR [eax], 0
  037f7	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  037fc	89 13		 mov	 DWORD PTR [ebx], edx
  037fe	e8 00 00 00 00	 call	 _chdir
  03803	83 c4 04	 add	 esp, 4

; 783  : 		   seterror;

  03806	33 c9		 xor	 ecx, ecx
  03808	85 c0		 test	 eax, eax
  0380a	0f 9d c1	 setge	 cl
  0380d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03811	a1 00 00 00 00	 mov	 eax, DWORD PTR _errno
  03816	49		 dec	 ecx
  03817	23 c8		 and	 ecx, eax
  03819	89 4f 4c	 mov	 DWORD PTR [edi+76], ecx

; 784  : 		   next;

  0381c	e9 45 c8 ff ff	 jmp	 $L58091
$L58674:

; 785  :     case ERRNO:		push( V_ERRNO ); next;	/* Self fetching */

  03821	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03825	83 eb 04	 sub	 ebx, 4
  03828	89 13		 mov	 DWORD PTR [ebx], edx
  0382a	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]

; 2298 : 				push(scr);

  0382d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  03831	e9 30 c8 ff ff	 jmp	 $L58091
$L58676:

; 786  : 	case WHY:		strcpy(errMsg, _sys_errlist[errno]); error(errMsg); next;

  03836	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _errno
  0383c	33 c0		 xor	 eax, eax
  0383e	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  03843	8b 3c 8d 00 00
	00 00		 mov	 edi, DWORD PTR __sys_errlist[ecx*4]
  0384a	83 c9 ff	 or	 ecx, -1
  0384d	f2 ae		 repne scasb
  0384f	f7 d1		 not	 ecx
  03851	2b f9		 sub	 edi, ecx
  03853	8b d1		 mov	 edx, ecx
  03855	8b f7		 mov	 esi, edi
  03857	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0385c	c1 e9 02	 shr	 ecx, 2
  0385f	f3 a5		 rep movsd
  03861	8b ca		 mov	 ecx, edx
  03863	83 e1 03	 and	 ecx, 3
  03866	f3 a4		 rep movsb
  03868	e8 00 00 00 00	 call	 _error
  0386d	83 c4 04	 add	 esp, 4
  03870	e9 e9 c7 ff ff	 jmp	 $L61881
$L58677:

; 787  :     case BL:		push(' '); next;

  03875	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03879	83 eb 04	 sub	 ebx, 4
  0387c	c7 44 24 0c 20
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 32 ; 00000020H
  03884	89 03		 mov	 DWORD PTR [ebx], eax
  03886	e9 db c7 ff ff	 jmp	 $L58091
$L58679:

; 788  :     case SINDEX:    /* adr1 len1 adr2 len2 -- n */
; 789  : 		    /* len2 in tos */  ascr  = (u_char *)*sp++;

  0388b	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 790  : 		    scr = *sp++;       ascr1 = (u_char *)*sp++;
; 791  : 		    tos = strindex(ascr1, scr, ascr, tos);

  0388d	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03891	83 c3 04	 add	 ebx, 4
  03894	89 4c 24 34	 mov	 DWORD PTR _ascr$[esp+304], ecx
  03898	89 54 24 5c	 mov	 DWORD PTR $T61628[esp+304], edx
  0389c	8b 54 24 34	 mov	 edx, DWORD PTR _ascr$[esp+304]
  038a0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  038a2	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  038a5	83 c3 04	 add	 ebx, 4
  038a8	89 54 24 2c	 mov	 DWORD PTR $T61627[esp+304], edx
  038ac	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  038b0	83 c3 04	 add	 ebx, 4
  038b3	3b d1		 cmp	 edx, ecx
  038b5	89 4c 24 30	 mov	 DWORD PTR _scr$[esp+304], ecx
  038b9	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  038bd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _n$61616[esp+304], 0
  038c5	0f 8c 20 2a 00
	00		 jl	 $L61622
  038cb	eb 04		 jmp	 SHORT $L61620
$L61912:
  038cd	8b 44 24 3c	 mov	 eax, DWORD PTR _ascr1$[esp+304]
$L61620:
  038d1	89 4c 24 38	 mov	 DWORD PTR _i$61619[esp+304], ecx
  038d5	8b 4c 24 2c	 mov	 ecx, DWORD PTR $T61627[esp+304]
  038d9	2b c8		 sub	 ecx, eax
  038db	89 4c 24 40	 mov	 DWORD PTR -240+[esp+304], ecx
$L61623:
  038df	8b 4c 24 38	 mov	 ecx, DWORD PTR _i$61619[esp+304]
  038e3	8b d1		 mov	 edx, ecx
  038e5	49		 dec	 ecx
  038e6	85 d2		 test	 edx, edx
  038e8	89 4c 24 38	 mov	 DWORD PTR _i$61619[esp+304], ecx
  038ec	7e 3e		 jle	 SHORT $L61624
  038ee	8b 54 24 40	 mov	 edx, DWORD PTR -240+[esp+304]
  038f2	8a 08		 mov	 cl, BYTE PTR [eax]
  038f4	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  038f7	40		 inc	 eax
  038f8	3a ca		 cmp	 cl, dl
  038fa	74 e3		 je	 SHORT $L61623
  038fc	8b 44 24 2c	 mov	 eax, DWORD PTR $T61627[esp+304]
  03900	8b 4c 24 34	 mov	 ecx, DWORD PTR _n$61616[esp+304]
  03904	40		 inc	 eax
  03905	89 44 24 2c	 mov	 DWORD PTR $T61627[esp+304], eax
  03909	8b 44 24 5c	 mov	 eax, DWORD PTR $T61628[esp+304]
  0390d	48		 dec	 eax
  0390e	41		 inc	 ecx
  0390f	89 4c 24 34	 mov	 DWORD PTR _n$61616[esp+304], ecx
  03913	8b 4c 24 30	 mov	 ecx, DWORD PTR _scr$[esp+304]
  03917	3b c1		 cmp	 eax, ecx
  03919	89 44 24 5c	 mov	 DWORD PTR $T61628[esp+304], eax
$tryagain$61626:
  0391d	7d ae		 jge	 SHORT $L61912

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  0391f	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  03927	e9 3a c7 ff ff	 jmp	 $L58091

; 790  : 		    scr = *sp++;       ascr1 = (u_char *)*sp++;
; 791  : 		    tos = strindex(ascr1, scr, ascr, tos);

$L61624:
  0392c	8b 44 24 34	 mov	 eax, DWORD PTR _n$61616[esp+304]
  03930	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03934	e9 2d c7 ff ff	 jmp	 $L58091
$L58682:

; 792  : 		    next;
; 793  : /*
; 794  :  * Why are FOPEN and FCLOSE outside the NOFILEIO conditional compilation? -MdG
; 795  :  * (Maybe it's to support stdio open and close of stdin, stdout, and stderr)
; 796  :  */
; 797  : 	/* ( pstring mode -- fd ) */
; 798  :     case FOPEN:	scr = pop;

  03939	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0393d	8b 13		 mov	 edx, DWORD PTR [ebx]

; 799  : 		switch((int)scr) {

  0393f	8b c1		 mov	 eax, ecx
  03941	83 c3 04	 add	 ebx, 4
  03944	83 e8 00	 sub	 eax, 0
  03947	74 20		 je	 SHORT $L58688
  03949	48		 dec	 eax
  0394a	74 13		 je	 SHORT $L58691
  0394c	48		 dec	 eax
  0394d	74 06		 je	 SHORT $L58694

; 803  : 		    default: ascr1 = (u_char *)scr; break;

  0394f	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx
  03953	eb 1c		 jmp	 SHORT $L58685
$L58694:

; 802  : 		    case 2: ascr1 = (u_char *)MODIFY_MODE; break;

  03955	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _ascr1$[esp+304], OFFSET FLAT:$SG58696
  0395d	eb 12		 jmp	 SHORT $L58685
$L58691:

; 801  : 		    case 1: ascr1 = (u_char *)WRITE_MODE; break;

  0395f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _ascr1$[esp+304], OFFSET FLAT:$SG58693
  03967	eb 08		 jmp	 SHORT $L58685
$L58688:

; 800  : 		    case 0: ascr1 = (u_char *)READ_MODE; break;

  03969	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _ascr1$[esp+304], OFFSET FLAT:$SG58690
$L58685:

; 804  : 		}
; 805  : 		ascr = (u_char *)tocstr((u_char *)tos);

  03971	33 c9		 xor	 ecx, ecx
  03973	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  03978	8a 0a		 mov	 cl, BYTE PTR [edx]
  0397a	42		 inc	 edx
  0397b	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  0397f	8b d1		 mov	 edx, ecx
  03981	49		 dec	 ecx
  03982	85 d2		 test	 edx, edx
  03984	74 1c		 je	 SHORT $L61635
  03986	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  0398a	2b d0		 sub	 edx, eax
  0398c	41		 inc	 ecx
  0398d	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
$L61634:
  03991	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  03994	88 08		 mov	 BYTE PTR [eax], cl
  03996	8b 4c 24 38	 mov	 ecx, DWORD PTR -248+[esp+304]
  0399a	40		 inc	 eax
  0399b	49		 dec	 ecx
  0399c	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
  039a0	75 ef		 jne	 SHORT $L61634
$L61635:
  039a2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 806  : 		tos = (cell) fopen((char *)ascr, (char *)ascr1); next;

  039a5	8b 54 24 3c	 mov	 edx, DWORD PTR _ascr1$[esp+304]
  039a9	52		 push	 edx
  039aa	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  039af	e8 00 00 00 00	 call	 _fopen
  039b4	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  039b7	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  039bb	e9 a6 c6 ff ff	 jmp	 $L58091
$L58704:

; 807  : 	/* ( fd -- ) */
; 808  :     case FCLOSE:file = fpop; (void)fclose(file); next;

  039c0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  039c4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  039c6	50		 push	 eax
  039c7	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  039cb	83 c3 04	 add	 ebx, 4
  039ce	e8 00 00 00 00	 call	 _fclose
  039d3	83 c4 04	 add	 esp, 4
  039d6	e9 8b c6 ff ff	 jmp	 $L58091
$L58707:

; 809  : #ifdef NOFILEIO
; 810  : 	case FGETC:
; 811  :     case FGETS:	
; 812  :     case FPUTC:	
; 813  :     case FPUTS: file = fpop;  scr = pop;  ascr1 = apop;
; 814  : 		(void)fwrite((char *)ascr1, 1, scr, file);
; 815  : 		next;
; 816  :     case FGETLINE: 
; 817  :     case FCR:	
; 818  :     case FSEEK: 
; 819  :     case FTELL: 
; 820  :     case FSIZE: 
; 821  :     case FFLUSH:  
; 822  :     case FUNGETC: 
; 823  : 		error("File I/O support is not enabled\n");
; 824  : 		next;
; 825  : #else
; 826  : 	/* ( fd -- char TRUE )
; 827  : 	 * ( fd -- FALSE )			FALSE if EOF 
; 828  : 	 */
; 829  : 	case FGETC:
; 830  : 		tos = fgetc( (FILE *)tos );

  039db	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  039df	52		 push	 edx
  039e0	e8 00 00 00 00	 call	 _fgetc
  039e5	83 c4 04	 add	 esp, 4

; 831  : 		if (tos >= 0) {

  039e8	85 c0		 test	 eax, eax
  039ea	0f 8c a5 18 00
	00		 jl	 $L58621

; 832  : 			push( (cell)-1 );

  039f0	83 eb 04	 sub	 ebx, 4
  039f3	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  039fb	89 03		 mov	 DWORD PTR [ebx], eax

; 833  : 			next;

  039fd	e9 64 c6 ff ff	 jmp	 $L58091
$L58712:

; 834  : 		}
; 835  : 		tos = 0;
; 836  : 		next;
; 837  : 	/* ( addr len file -- actual ) */
; 838  :     case FGETS:	file = fpop; scr = pop;

  03a02	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03a04	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03a08	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03a0b	83 c3 04	 add	 ebx, 4

; 839  : 		tos = pfgets((u_char *)tos, scr, file);

  03a0e	50		 push	 eax
  03a0f	51		 push	 ecx
  03a10	52		 push	 edx
  03a11	83 c3 04	 add	 ebx, 4
  03a14	e8 00 00 00 00	 call	 _pfgets
  03a19	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2298 : 				push(scr);

  03a1c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  03a20	e9 41 c6 ff ff	 jmp	 $L58091
$L58715:

; 840  : 		next;
; 841  : 	/* ( char fd -- ) */
; 842  :     case FPUTC:	file = fpop;  scr = pop;  (void)putc((char)scr, file);  next;

  03a25	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03a27	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03a2b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03a2e	83 c3 04	 add	 ebx, 4
  03a31	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  03a35	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03a38	83 c3 04	 add	 ebx, 4
  03a3b	4a		 dec	 edx
  03a3c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  03a3f	78 0e		 js	 SHORT $L60665
  03a41	8b 10		 mov	 edx, DWORD PTR [eax]
  03a43	88 0a		 mov	 BYTE PTR [edx], cl
  03a45	8b 08		 mov	 ecx, DWORD PTR [eax]
  03a47	41		 inc	 ecx
  03a48	89 08		 mov	 DWORD PTR [eax], ecx
  03a4a	e9 17 c6 ff ff	 jmp	 $L58091
$L60665:
  03a4f	50		 push	 eax
  03a50	0f be c1	 movsx	 eax, cl
  03a53	50		 push	 eax
  03a54	e8 00 00 00 00	 call	 __flsbuf

; 2416 : 							free(rq);

  03a59	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  03a5c	e9 05 c6 ff ff	 jmp	 $L58091
$L58721:

; 843  : 	/* ( addr len fd -- ) */
; 844  :     case FPUTS: file = fpop;  scr = pop;  ascr1 = apop;

  03a61	8b 03		 mov	 eax, DWORD PTR [ebx]
  03a63	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03a66	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  03a6a	83 c3 04	 add	 ebx, 4
  03a6d	83 c3 04	 add	 ebx, 4
  03a70	89 54 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], edx
  03a74	89 4c 24 2c	 mov	 DWORD PTR _file$[esp+304], ecx
  03a78	8b 13		 mov	 edx, DWORD PTR [ebx]
  03a7a	83 c3 04	 add	 ebx, 4
  03a7d	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 845  : 		while (scr--)

  03a81	8b d0		 mov	 edx, eax
  03a83	48		 dec	 eax
  03a84	85 d2		 test	 edx, edx
  03a86	0f 84 da c5 ff
	ff		 je	 $L58091
  03a8c	40		 inc	 eax
  03a8d	89 44 24 38	 mov	 DWORD PTR -248+[esp+304], eax
$L58725:

; 846  : 			(void)putc((char)*ascr1++, file);

  03a91	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  03a94	48		 dec	 eax
  03a95	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  03a98	78 1a		 js	 SHORT $L60667
  03a9a	8b 54 24 3c	 mov	 edx, DWORD PTR _ascr1$[esp+304]
  03a9e	8b 01		 mov	 eax, DWORD PTR [ecx]
  03aa0	8a 12		 mov	 dl, BYTE PTR [edx]
  03aa2	88 10		 mov	 BYTE PTR [eax], dl
  03aa4	8b 11		 mov	 edx, DWORD PTR [ecx]
  03aa6	42		 inc	 edx
  03aa7	89 11		 mov	 DWORD PTR [ecx], edx
  03aa9	8b 44 24 3c	 mov	 eax, DWORD PTR _ascr1$[esp+304]
  03aad	40		 inc	 eax
  03aae	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  03ab2	eb 1e		 jmp	 SHORT $L60668
$L60667:
  03ab4	8b 44 24 3c	 mov	 eax, DWORD PTR _ascr1$[esp+304]
  03ab8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  03abb	40		 inc	 eax
  03abc	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  03ac0	8b 44 24 2c	 mov	 eax, DWORD PTR _file$[esp+304]
  03ac4	50		 push	 eax
  03ac5	51		 push	 ecx
  03ac6	e8 00 00 00 00	 call	 __flsbuf
  03acb	8b 4c 24 34	 mov	 ecx, DWORD PTR _file$[esp+312]
  03acf	83 c4 08	 add	 esp, 8
$L60668:
  03ad2	8b 44 24 38	 mov	 eax, DWORD PTR -248+[esp+304]
  03ad6	48		 dec	 eax
  03ad7	89 44 24 38	 mov	 DWORD PTR -248+[esp+304], eax
  03adb	75 b4		 jne	 SHORT $L58725

; 847  : 		next;

  03add	e9 84 c5 ff ff	 jmp	 $L58091
$L58731:

; 848  : 	/* ( addr fd -- fd eofbool ) eofbool=0 if end of file */
; 849  : 	/* Reads a pstring from the file to the address */
; 850  :     case FGETLINE: file = fpop;  ascr1 = apop;

  03ae2	8b 03		 mov	 eax, DWORD PTR [ebx]
  03ae4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  03ae8	83 c3 04	 add	 ebx, 4
  03aeb	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax

; 851  : 		   scr = pfgetline((u_char *)ascr1, file);

  03aef	51		 push	 ecx
  03af0	50		 push	 eax
  03af1	8b 13		 mov	 edx, DWORD PTR [ebx]
  03af3	89 4c 24 34	 mov	 DWORD PTR _file$[esp+312], ecx
  03af7	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  03afb	e8 00 00 00 00	 call	 _pfgetline

; 852  : 		   push(file);  push(scr);  next;

  03b00	8b 4c 24 14	 mov	 ecx, DWORD PTR _tos$[esp+312]
  03b04	8b 54 24 34	 mov	 edx, DWORD PTR _file$[esp+312]
  03b08	83 c4 08	 add	 esp, 8
  03b0b	89 0b		 mov	 DWORD PTR [ebx], ecx
  03b0d	83 eb 04	 sub	 ebx, 4

; 2298 : 				push(scr);

  03b10	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  03b14	89 13		 mov	 DWORD PTR [ebx], edx

; 2299 : 				next;

  03b16	e9 4b c5 ff ff	 jmp	 $L58091
$L58737:

; 853  : 	/* ( fd -- ) */
; 854  :     case FCR:	file = fpop;  (void)fputs(SNEWLINE, file);  next;

  03b1b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03b1f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03b21	50		 push	 eax
  03b22	68 00 00 00 00	 push	 OFFSET FLAT:$SG58740
  03b27	89 4c 24 14	 mov	 DWORD PTR _tos$[esp+312], ecx
  03b2b	83 c3 04	 add	 ebx, 4
  03b2e	e8 00 00 00 00	 call	 _fputs

; 2416 : 							free(rq);

  03b33	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  03b36	e9 2b c5 ff ff	 jmp	 $L58091
$L58741:

; 855  : 	/* ( pos fd -- ) */
; 856  :     case FSEEK: file = fpop;

  03b3b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03b3d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 857  : 		lscr = (long)pop;

  03b41	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03b44	83 c3 04	 add	 ebx, 4

; 858  : 		(void)fseek(file, lscr, 0);

  03b47	6a 00		 push	 0
  03b49	51		 push	 ecx
  03b4a	50		 push	 eax
  03b4b	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  03b4f	83 c3 04	 add	 ebx, 4
  03b52	e8 00 00 00 00	 call	 _fseek
  03b57	83 c4 0c	 add	 esp, 12			; 0000000cH

; 859  : 		next;

  03b5a	e9 07 c5 ff ff	 jmp	 $L58091
$L58745:

; 860  : 	/* ( fd -- pos ) */
; 861  :     case FTELL: file = fpop;  lscr = ftell(file);

  03b5f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03b63	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03b65	50		 push	 eax
  03b66	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  03b6a	e8 00 00 00 00	 call	 _ftell

; 862  : 		push(lscr);

  03b6f	8b 54 24 10	 mov	 edx, DWORD PTR _tos$[esp+308]
  03b73	83 c4 04	 add	 esp, 4
  03b76	89 13		 mov	 DWORD PTR [ebx], edx

; 2298 : 				push(scr);

  03b78	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  03b7c	e9 e5 c4 ff ff	 jmp	 $L58091
$L58748:

; 863  : 		next;
; 864  : 	/* ( fd -- size ) */
; 865  :     case FSIZE: file = fpop;

  03b81	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03b85	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 866  : 		lscr1 = ftell(file);		/* Save position */

  03b87	50		 push	 eax
  03b88	89 44 24 30	 mov	 DWORD PTR _file$[esp+308], eax
  03b8c	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  03b90	e8 00 00 00 00	 call	 _ftell

; 867  : 		(void)fseek(file, 0L, 2);	/* End of file */

  03b95	8b 54 24 30	 mov	 edx, DWORD PTR _file$[esp+308]
  03b99	6a 02		 push	 2
  03b9b	6a 00		 push	 0
  03b9d	52		 push	 edx
  03b9e	89 44 24 50	 mov	 DWORD PTR _lscr1$[esp+320], eax
  03ba2	e8 00 00 00 00	 call	 _fseek

; 868  : 		lscr = ftell(file);

  03ba7	8b 44 24 3c	 mov	 eax, DWORD PTR _file$[esp+320]
  03bab	50		 push	 eax
  03bac	e8 00 00 00 00	 call	 _ftell

; 869  : 		(void)fseek(file, lscr1, 0);	/* Return */

  03bb1	8b 4c 24 54	 mov	 ecx, DWORD PTR _lscr1$[esp+324]
  03bb5	8b 54 24 40	 mov	 edx, DWORD PTR _file$[esp+324]
  03bb9	6a 00		 push	 0
  03bbb	51		 push	 ecx
  03bbc	52		 push	 edx
  03bbd	89 44 24 70	 mov	 DWORD PTR _lscr$[esp+336], eax
  03bc1	e8 00 00 00 00	 call	 _fseek

; 870  : 		push(lscr);

  03bc6	8b 44 24 2c	 mov	 eax, DWORD PTR _tos$[esp+336]
  03bca	8b 4c 24 70	 mov	 ecx, DWORD PTR _lscr$[esp+336]
  03bce	83 c4 20	 add	 esp, 32			; 00000020H
  03bd1	89 03		 mov	 DWORD PTR [ebx], eax
  03bd3	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 871  : 		next;

  03bd7	e9 8a c4 ff ff	 jmp	 $L58091
$L58753:

; 872  : 	/* ( fd -- ) */
; 873  :     case FFLUSH:  file = fpop;  (void)fflush(file);  next;

  03bdc	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03be0	8b 13		 mov	 edx, DWORD PTR [ebx]
  03be2	50		 push	 eax
  03be3	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  03be7	83 c3 04	 add	 ebx, 4
  03bea	e8 00 00 00 00	 call	 _fflush
  03bef	83 c4 04	 add	 esp, 4
  03bf2	e9 6f c4 ff ff	 jmp	 $L58091
$L58756:

; 874  : 	/* ( char fd -- ) */
; 875  :     case FUNGETC: file = fpop; scr = pop; (void)ungetc((char)scr, file); next;

  03bf7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03bfb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03bfd	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  03c00	50		 push	 eax
  03c01	83 c3 04	 add	 ebx, 4
  03c04	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  03c08	0f be c1	 movsx	 eax, cl
  03c0b	50		 push	 eax
  03c0c	83 c3 04	 add	 ebx, 4
  03c0f	e8 00 00 00 00	 call	 _ungetc

; 2416 : 							free(rq);

  03c14	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  03c17	e9 4a c4 ff ff	 jmp	 $L58091
$L58760:

; 876  : #endif /* NOFILEIO */
; 877  : 	/* ( -- newline ) */
; 878  :     case FNEWLINE: push(CNEWLINE); next;

  03c1c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  03c20	83 eb 04	 sub	 ebx, 4
  03c23	c7 44 24 0c 0a
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 10 ; 0000000aH
  03c2b	89 0b		 mov	 DWORD PTR [ebx], ecx
  03c2d	e9 34 c4 ff ff	 jmp	 $L58091
$L58762:

; 879  : 
; 880  :     case TORELBIT:
; 881  : #ifdef RELOCATE
; 882  : 		/*
; 883  : 		 * If address is in dictionary, return address in dictionary
; 884  : 		 * relocation map.
; 885  : 		 */
; 886  : 		if (tos >= (cell)origin && 
; 887  : 					tos < ((cell)origin + DICT_SIZE)) {

  03c32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _origin
  03c38	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  03c3c	3b c1		 cmp	 eax, ecx
  03c3e	7c 35		 jl	 SHORT $L58765
  03c40	8d 91 00 00 04
	00		 lea	 edx, DWORD PTR [ecx+262144]
  03c46	3b c2		 cmp	 eax, edx
  03c48	7d 2b		 jge	 SHORT $L58765

; 888  : 			scr = (cell)((cell *)tos - origin);
; 889  : 			ascr = &relmap[scr>>3];

  03c4a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _relmap
  03c50	2b c1		 sub	 eax, ecx
  03c52	c1 f8 02	 sar	 eax, 2
  03c55	8b c8		 mov	 ecx, eax

; 890  : 			tos = (cell)ascr;
; 891  : 		    push(bit[scr & 7]);

  03c57	83 eb 04	 sub	 ebx, 4
  03c5a	c1 f9 03	 sar	 ecx, 3
  03c5d	03 ca		 add	 ecx, edx
  03c5f	83 e0 07	 and	 eax, 7
  03c62	33 d2		 xor	 edx, edx
  03c64	89 0b		 mov	 DWORD PTR [ebx], ecx
  03c66	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _bit[eax]
  03c6c	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 892  : 		    next;

  03c70	e9 f1 c3 ff ff	 jmp	 $L58091
$L58765:

; 893  : 		}
; 894  : 		/*
; 895  : 		 * If address is in user area, return address in user area
; 896  : 		 * relocation map.
; 897  : 		 */
; 898  : 		if ((unsigned cell)tos >= (unsigned cell)up &&
; 899  : 				(unsigned cell)tos < ((unsigned cell)up + MAXUSER*sizeof(cell))) {

  03c75	3b c7		 cmp	 eax, edi
  03c77	72 35		 jb	 SHORT $L58776
  03c79	8d 8f 00 20 00
	00		 lea	 ecx, DWORD PTR [edi+8192]
  03c7f	3b c1		 cmp	 eax, ecx
  03c81	73 2b		 jae	 SHORT $L58776

; 900  : 			scr = (cell)((cell *)tos - up);
; 901  : 			ascr = &urelmap[scr>>3];

  03c83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _urelmap
  03c89	2b c7		 sub	 eax, edi
  03c8b	c1 f8 02	 sar	 eax, 2
  03c8e	8b d0		 mov	 edx, eax

; 902  : 			tos = (cell)ascr;
; 903  : 			push(bit[scr & 7]);

  03c90	83 eb 04	 sub	 ebx, 4
  03c93	c1 fa 03	 sar	 edx, 3
  03c96	03 d1		 add	 edx, ecx
  03c98	83 e0 07	 and	 eax, 7
  03c9b	33 c9		 xor	 ecx, ecx
  03c9d	89 13		 mov	 DWORD PTR [ebx], edx
  03c9f	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _bit[eax]
  03ca5	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 904  : 			next;

  03ca9	e9 b8 c3 ff ff	 jmp	 $L58091
$L58776:

; 905  : 		}
; 906  : #endif
; 907  : 		/*
; 908  : 		 * Otherwise, return a "safe" address and a 0 bitmask.
; 909  : 		 */
; 910  : 		tos = (cell)nullrelmap;
; 911  : 		push(0);

  03cae	83 eb 04	 sub	 ebx, 4

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  03cb1	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  03cb9	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:_nullrelmap

; 2022 : 				next;

  03cbf	e9 a2 c3 ff ff	 jmp	 $L58091
$L58783:

; 912  : 		next;
; 913  : 
; 914  : 	/* Binary Floating Point Operators */
; 915  : 	case FPLUS:	ftos = *fsp++ + ftos;		next;

  03cc4	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03cc8	dc 06		 fadd	 QWORD PTR [esi]

; 2258 : 				*(double *)&frp[scr] = flpop;

  03cca	83 c6 08	 add	 esi, 8
  03ccd	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03cd1	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]

; 2259 : 				next;

  03cd5	e9 8c c3 ff ff	 jmp	 $L58091
$L58784:

; 916  : 	case FMINUS:	ftos = *fsp++ - ftos;		next;

  03cda	dd 06		 fld	 QWORD PTR [esi]
  03cdc	dc 64 24 10	 fsub	 QWORD PTR _ftos$[esp+304]

; 2258 : 				*(double *)&frp[scr] = flpop;

  03ce0	83 c6 08	 add	 esi, 8
  03ce3	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03ce7	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]

; 2259 : 				next;

  03ceb	e9 76 c3 ff ff	 jmp	 $L58091
$L58785:

; 917  : 	case FTIMES:	ftos = *fsp++ * ftos;		next;

  03cf0	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03cf4	dc 0e		 fmul	 QWORD PTR [esi]

; 2258 : 				*(double *)&frp[scr] = flpop;

  03cf6	83 c6 08	 add	 esi, 8
  03cf9	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03cfd	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]

; 2259 : 				next;

  03d01	e9 60 c3 ff ff	 jmp	 $L58091
$L58786:

; 918  : 	case FDIVIDE:	ftos = *fsp++ / ftos;		next;

  03d06	dd 06		 fld	 QWORD PTR [esi]
  03d08	dc 74 24 10	 fdiv	 QWORD PTR _ftos$[esp+304]

; 2258 : 				*(double *)&frp[scr] = flpop;

  03d0c	83 c6 08	 add	 esi, 8
  03d0f	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03d13	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]

; 2259 : 				next;

  03d17	e9 4a c3 ff ff	 jmp	 $L58091
$L58787:

; 919  : 
; 920  : /* On some systems, "fmod()" may need to be replaced by "drem()" */
; 921  : 	case FMOD:	ftos = fmod(*fsp++, ftos);	next;

  03d1c	8b 16		 mov	 edx, DWORD PTR [esi]
  03d1e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  03d21	89 94 24 08 01
	00 00		 mov	 DWORD PTR -40+[esp+304], edx
  03d28	89 84 24 0c 01
	00 00		 mov	 DWORD PTR -40+[esp+308], eax
  03d2f	dd 84 24 08 01
	00 00		 fld	 QWORD PTR -40+[esp+304]
  03d36	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d3a	83 c6 08	 add	 esi, 8
  03d3d	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03d41	e8 00 00 00 00	 call	 __CIfmod
  03d46	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d4a	e9 17 c3 ff ff	 jmp	 $L58091
$L58788:

; 922  : 
; 923  : 	/* Unary Floating Point Operators */
; 924  : 	case FNEGATE:	ftos = -ftos;			next;

  03d4f	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d53	d9 e0		 fchs
  03d55	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d59	e9 08 c3 ff ff	 jmp	 $L58091
$L58789:

; 925  : 	case FSIN:	ftos = sin(ftos);		next;

  03d5e	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d62	d9 fe		 fsin
  03d64	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d68	e9 f9 c2 ff ff	 jmp	 $L58091
$L58790:

; 926  : 	case FCOS:	ftos = cos(ftos);		next;

  03d6d	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d71	d9 ff		 fcos
  03d73	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d77	e9 ea c2 ff ff	 jmp	 $L58091
$L58791:

; 927  : 	case FTAN:	ftos = tan(ftos);		next;

  03d7c	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d80	d9 f2		 fptan
  03d82	dd d8		 fstp	 ST(0)
  03d84	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d88	e9 d9 c2 ff ff	 jmp	 $L58091
$L58792:

; 928  : 	case FLOG:	ftos = log10(ftos);		next;

  03d8d	d9 ec		 fldlg2
  03d8f	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03d93	d9 f1		 fyl2x
  03d95	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03d99	e9 c8 c2 ff ff	 jmp	 $L58091
$L58793:

; 929  : 	case FLN:	ftos = log(ftos);		next;

  03d9e	d9 ed		 fldln2
  03da0	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03da4	d9 f1		 fyl2x
  03da6	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03daa	e9 b7 c2 ff ff	 jmp	 $L58091
$L58794:

; 930  : 	case FATAN:	ftos = atan(ftos);		next;

  03daf	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03db3	d9 e8		 fld1
  03db5	d9 f3		 fpatan
  03db7	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03dbb	e9 a6 c2 ff ff	 jmp	 $L58091
$L58795:

; 931  : 	case FATAN2:	ftos = atan2(*fsp++, ftos);	next;

  03dc0	dd 06		 fld	 QWORD PTR [esi]
  03dc2	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03dc6	d9 f3		 fpatan
  03dc8	83 c6 08	 add	 esi, 8
  03dcb	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03dcf	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03dd3	e9 8e c2 ff ff	 jmp	 $L58091
$L58796:

; 932  : 	case FASIN:	ftos = asin(ftos);		next;

  03dd8	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03ddc	e8 00 00 00 00	 call	 __CIasin
  03de1	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03de5	e9 7c c2 ff ff	 jmp	 $L58091
$L58797:

; 933  : 	case FACOS:	ftos = acos(ftos);		next;

  03dea	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03dee	e8 00 00 00 00	 call	 __CIacos
  03df3	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03df7	e9 6a c2 ff ff	 jmp	 $L58091
$L58798:

; 934  : 	case FCEIL:	ftos = ceil(ftos);		next;

  03dfc	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  03e00	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  03e04	51		 push	 ecx
  03e05	52		 push	 edx
  03e06	e8 00 00 00 00	 call	 _ceil
  03e0b	dd 5c 24 18	 fstp	 QWORD PTR _ftos$[esp+312]
  03e0f	83 c4 08	 add	 esp, 8
  03e12	e9 4f c2 ff ff	 jmp	 $L58091
$L58799:

; 935  : 	case FCOSH:	ftos = cosh(ftos);		next;

  03e17	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03e1b	e8 00 00 00 00	 call	 __CIcosh
  03e20	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e24	e9 3d c2 ff ff	 jmp	 $L58091
$L58800:

; 936  : 	case FSINH:	ftos = sinh(ftos);		next;

  03e29	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03e2d	e8 00 00 00 00	 call	 __CIsinh
  03e32	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e36	e9 2b c2 ff ff	 jmp	 $L58091
$L58801:

; 937  : 	case TANH:	ftos = tanh(ftos);		next;

  03e3b	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03e3f	e8 00 00 00 00	 call	 __CItanh
  03e44	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e48	e9 19 c2 ff ff	 jmp	 $L58091
$L58802:

; 938  : 	case FSQRT:	ftos = sqrt(ftos);		next;

  03e4d	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03e51	d9 fa		 fsqrt
  03e53	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e57	e9 0a c2 ff ff	 jmp	 $L58091
$L58803:

; 939  : 	case FEXP:	ftos = exp(ftos);		next;

  03e5c	d9 ea		 fldl2e
  03e5e	dc 4c 24 10	 fmul	 QWORD PTR _ftos$[esp+304]
  03e62	d9 c0		 fld	 ST(0)
  03e64	d9 fc		 frndint
  03e66	d9 c9		 fxch	 ST(1)
  03e68	d8 e1		 fsub	 ST(0), ST(1)
  03e6a	d9 f0		 f2xm1
  03e6c	d9 e8		 fld1
  03e6e	de c1		 faddp	 ST(1), ST(0)
  03e70	d9 fd		 fscale
  03e72	dd d9		 fstp	 ST(1)
  03e74	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e78	e9 e9 c1 ff ff	 jmp	 $L58091
$L58804:

; 940  : 	case FABS:	ftos = fabs(ftos);		next;

  03e7d	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03e81	d9 e1		 fabs
  03e83	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03e87	e9 da c1 ff ff	 jmp	 $L58091
$L58805:

; 941  : 	case FFLOOR:	ftos = floor(ftos);		next;

  03e8c	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  03e90	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  03e94	50		 push	 eax
  03e95	51		 push	 ecx
  03e96	e8 00 00 00 00	 call	 _floor
  03e9b	dd 5c 24 18	 fstp	 QWORD PTR _ftos$[esp+312]
  03e9f	83 c4 08	 add	 esp, 8
  03ea2	e9 bf c1 ff ff	 jmp	 $L58091
$L58806:

; 942  : 	case FPOW:	ftos = pow(*fsp++, ftos);	next;

  03ea7	8b 16		 mov	 edx, DWORD PTR [esi]
  03ea9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  03eac	89 94 24 00 01
	00 00		 mov	 DWORD PTR -48+[esp+304], edx
  03eb3	89 84 24 04 01
	00 00		 mov	 DWORD PTR -48+[esp+308], eax
  03eba	dd 84 24 00 01
	00 00		 fld	 QWORD PTR -48+[esp+304]
  03ec1	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03ec5	83 c6 08	 add	 esi, 8
  03ec8	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03ecc	e8 00 00 00 00	 call	 __CIpow
  03ed1	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  03ed5	e9 8c c1 ff ff	 jmp	 $L58091
$L58807:

; 943  : 	
; 944  : 	/* Floating Point Stack Manipulation */
; 945  : 	case FDUP:	*--fsp = ftos;			next;

  03eda	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  03ede	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  03ee2	83 ee 08	 sub	 esi, 8
  03ee5	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03ee9	89 0e		 mov	 DWORD PTR [esi], ecx
  03eeb	89 56 04	 mov	 DWORD PTR [esi+4], edx
  03eee	e9 73 c1 ff ff	 jmp	 $L58091
$L58809:

; 946  : 	case FDROP:	ftos = *fsp++;			next;
; 947  : 	case FOVER:	*--fsp = ftos; ftos = fsp[1];	next;

  03ef3	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  03ef7	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  03efb	83 ee 08	 sub	 esi, 8
  03efe	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03f02	89 16		 mov	 DWORD PTR [esi], edx
  03f04	89 46 04	 mov	 DWORD PTR [esi+4], eax
  03f07	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  03f0a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  03f0d	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  03f11	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  03f15	e9 4c c1 ff ff	 jmp	 $L58091
$L58810:

; 948  : 	case FSWAP: 	ftemp = ftos; ftos = *fsp; *fsp = ftemp; next;

  03f1a	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  03f1e	dd 54 24 60	 fst	 QWORD PTR _ftemp$[esp+304]
  03f22	8b 06		 mov	 eax, DWORD PTR [esi]
  03f24	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  03f27	dd 1e		 fstp	 QWORD PTR [esi]
  03f29	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  03f2d	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  03f31	e9 30 c1 ff ff	 jmp	 $L58091
$L58811:

; 949  : 	case FROT:	ftemp = ftos; ftos = fsp[1];

  03f36	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  03f3a	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  03f3e	89 54 24 60	 mov	 DWORD PTR _ftemp$[esp+304], edx
  03f42	89 44 24 64	 mov	 DWORD PTR _ftemp$[esp+308], eax
  03f46	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  03f49	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]

; 950  : 			fsp[1] = fsp[0]; fsp[0] = ftemp;

  03f4c	8b c6		 mov	 eax, esi
  03f4e	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  03f52	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  03f56	8b 08		 mov	 ecx, DWORD PTR [eax]
  03f58	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  03f5b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  03f5e	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  03f61	8b 44 24 60	 mov	 eax, DWORD PTR _ftemp$[esp+304]
  03f65	8b 4c 24 64	 mov	 ecx, DWORD PTR _ftemp$[esp+308]
  03f69	89 06		 mov	 DWORD PTR [esi], eax
  03f6b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 951  : 			next;

  03f6e	e9 f3 c0 ff ff	 jmp	 $L58091
$L58812:

; 952  : 	case FMINROT:	ftemp = ftos; ftos = fsp[0]; 

  03f73	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  03f77	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  03f7b	89 54 24 60	 mov	 DWORD PTR _ftemp$[esp+304], edx
  03f7f	89 44 24 64	 mov	 DWORD PTR _ftemp$[esp+308], eax
  03f83	8b 0e		 mov	 ecx, DWORD PTR [esi]
  03f85	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 953  : 			fsp[0] = fsp[1]; fsp[1] = ftemp;

  03f88	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  03f8b	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  03f8f	8b c8		 mov	 ecx, eax
  03f91	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  03f95	8b 11		 mov	 edx, DWORD PTR [ecx]
  03f97	89 16		 mov	 DWORD PTR [esi], edx
  03f99	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  03f9c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  03f9f	8b 54 24 60	 mov	 edx, DWORD PTR _ftemp$[esp+304]
  03fa3	8b 4c 24 64	 mov	 ecx, DWORD PTR _ftemp$[esp+308]
  03fa7	89 10		 mov	 DWORD PTR [eax], edx
  03fa9	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 954  : 			next;

  03fac	e9 b5 c0 ff ff	 jmp	 $L58091
$L58813:

; 955  :     /* Floating Point operations involving the Forth data stack */
; 956  : 	case FDEPTH:
; 957  : 		push( (cell)((double *)V_FPZERO - fsp) + 1 );

  03fb1	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  03fb5	83 eb 04	 sub	 ebx, 4
  03fb8	89 13		 mov	 DWORD PTR [ebx], edx
  03fba	8b 87 98 00 00
	00		 mov	 eax, DWORD PTR [edi+152]
  03fc0	2b c6		 sub	 eax, esi
  03fc2	c1 f8 03	 sar	 eax, 3
  03fc5	40		 inc	 eax

; 2298 : 				push(scr);

  03fc6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  03fca	e9 97 c0 ff ff	 jmp	 $L58091
$L58817:

; 958  : 		next;
; 959  : 	case FPSTORE:	/* Set Floating Point Stack Pointer */
; 960  : 		fsp = (double *)pop;

  03fcf	8b 74 24 0c	 mov	 esi, DWORD PTR _tos$[esp+304]

; 2486 : 					RESTORE_XCONTEXT

  03fd3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  03fd5	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  03fd9	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  03fdd	83 c3 04	 add	 ebx, 4

; 2487 : 					next;

  03fe0	e9 81 c0 ff ff	 jmp	 $L58091
$L58819:

; 961  : 		next;
; 962  : 
; 963  : 	    /* Floating Point Memory Access */
; 964  : 	case FSTORE:
; 965  : 		ulongp = (unsigned long *)pop;

  03fe5	8b 13		 mov	 edx, DWORD PTR [ebx]
  03fe7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 966  : 		fbits.fb_float = ftos;

  03feb	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  03fef	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  03ff3	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  03ff7	89 0d 00 00 00
	00		 mov	 DWORD PTR _fbits, ecx
  03ffd	89 15 04 00 00
	00		 mov	 DWORD PTR _fbits+4, edx

; 967  : 		ftos = *fsp++;

  04003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  04005	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  04008	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx

; 968  : 		*ulongp++ = fbits.fb_long[0];

  0400c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fbits
  04012	83 c3 04	 add	 ebx, 4
  04015	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  04019	89 08		 mov	 DWORD PTR [eax], ecx

; 969  : 		*ulongp++ = fbits.fb_long[1];

  0401b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _fbits+4
  04021	83 c6 08	 add	 esi, 8
  04024	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04028	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 970  : 		next;

  0402b	e9 36 c0 ff ff	 jmp	 $L58091
$L58821:

; 971  : 	case FFETCH:
; 972  : 		ulongp = (unsigned long *)pop;

  04030	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04032	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 973  : 		*--fsp = ftos;

  04036	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  0403a	83 ee 08	 sub	 esi, 8
  0403d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  04041	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  04045	89 16		 mov	 DWORD PTR [esi], edx
  04047	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 974  : 		fbits.fb_long[0] = *ulongp++;

  0404a	8b 10		 mov	 edx, DWORD PTR [eax]
  0404c	83 c3 04	 add	 ebx, 4
  0404f	83 c0 04	 add	 eax, 4
  04052	89 15 00 00 00
	00		 mov	 DWORD PTR _fbits, edx

; 975  : 		fbits.fb_long[1] = *ulongp++;
; 976  : 		ftos = fbits.fb_float;

  04058	8b ca		 mov	 ecx, edx
  0405a	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0405e	8b 00		 mov	 eax, DWORD PTR [eax]
  04060	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  04064	8b d0		 mov	 edx, eax
  04066	a3 04 00 00 00	 mov	 DWORD PTR _fbits+4, eax
  0406b	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 977  : 		next;

  0406f	e9 f2 bf ff ff	 jmp	 $L58091
$L58823:

; 978  : 
; 979  : 	/* Move numbers between Floating Point and Integer Stacks */
; 980  : 	case FINT:	/* Float to Integer */
; 981  : 		if (ftos < (-TWO_31ST)) {

  04074	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  04078	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@c01e8000000000000000
  0407e	df e0		 fnstsw	 ax
  04080	f6 c4 01	 test	 ah, 1
  04083	74 2b		 je	 SHORT $L58824

; 982  : 			push((-TWO_31ST));

  04085	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04089	83 eb 04	 sub	 ebx, 4

; 2258 : 				*(double *)&frp[scr] = flpop;

  0408c	83 c6 08	 add	 esi, 8
  0408f	c7 44 24 0c 00
	00 00 80	 mov	 DWORD PTR _tos$[esp+304], -2147483648 ; 80000000H
  04097	89 03		 mov	 DWORD PTR [ebx], eax
  04099	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  0409c	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  0409f	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  040a3	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  040a7	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2259 : 				next;

  040ab	e9 b6 bf ff ff	 jmp	 $L58091
$L58824:

; 983  : 		} else if (ftos > (TWO_31ST - 1.0)) {

  040b0	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  040b4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@401dfffffffe00000000
  040ba	df e0		 fnstsw	 ax
  040bc	f6 c4 41	 test	 ah, 65			; 00000041H
  040bf	75 2b		 jne	 SHORT $L58827

; 984  : 			push(TWO_31ST - 1.0);

  040c1	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  040c5	83 eb 04	 sub	 ebx, 4

; 2258 : 				*(double *)&frp[scr] = flpop;

  040c8	83 c6 08	 add	 esi, 8
  040cb	c7 44 24 0c ff
	ff ff 7f	 mov	 DWORD PTR _tos$[esp+304], 2147483647 ; 7fffffffH
  040d3	89 0b		 mov	 DWORD PTR [ebx], ecx
  040d5	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  040d8	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  040db	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  040df	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  040e3	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2259 : 				next;

  040e7	e9 7a bf ff ff	 jmp	 $L58091
$L58827:

; 985  : 		} else {
; 986  : 			push( ftos );

  040ec	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  040f0	83 eb 04	 sub	 ebx, 4
  040f3	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  040f7	89 13		 mov	 DWORD PTR [ebx], edx
  040f9	e8 00 00 00 00	 call	 __ftol
  040fe	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
$L58808:

; 987  : 		}
; 988  : 		ftos = *fsp++;

  04102	8b 06		 mov	 eax, DWORD PTR [esi]
  04104	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 2258 : 				*(double *)&frp[scr] = flpop;

  04107	83 c6 08	 add	 esi, 8
  0410a	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  0410e	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  04112	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2259 : 				next;

  04116	e9 4b bf ff ff	 jmp	 $L58091
$L58831:

; 989  : 		next;
; 990  : 	case FFLOAT:	/* Integer to Float */
; 991  : 		*--fsp = ftos;

  0411b	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  0411f	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]

; 992  : 		ftos = (double)pop;

  04123	db 44 24 0c	 fild	 DWORD PTR _tos$[esp+304]
  04127	83 ee 08	 sub	 esi, 8

; 2486 : 					RESTORE_XCONTEXT

  0412a	83 c3 04	 add	 ebx, 4
  0412d	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04131	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  04135	89 16		 mov	 DWORD PTR [esi], edx
  04137	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0413a	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  0413d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2487 : 					next;

  04141	e9 20 bf ff ff	 jmp	 $L58091
$L58833:

; 993  : 		next;
; 994  : 	case FPOP:	/* Move unconverted bits from FP stack to Int stack */
; 995  : 		ulongp = (unsigned long *)sp;
; 996  : 		ulongp -= 2;
; 997  : 		sp = (cell *)ulongp;
; 998  : 		fbits.fb_float = ftos;

  04146	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  0414a	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  0414e	83 c3 f8	 add	 ebx, -8			; fffffff8H

; 999  : 		ulongp[1] = fbits.fb_long[1];

  04151	8b c8		 mov	 ecx, eax
  04153	89 15 00 00 00
	00		 mov	 DWORD PTR _fbits, edx
  04159	a3 04 00 00 00	 mov	 DWORD PTR _fbits+4, eax
  0415e	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 1000 : 		ulongp[0] = fbits.fb_long[0];

  04161	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _fbits
  04167	89 13		 mov	 DWORD PTR [ebx], edx

; 1001 : 		ftos = *fsp++;

  04169	8b 06		 mov	 eax, DWORD PTR [esi]
  0416b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 2258 : 				*(double *)&frp[scr] = flpop;

  0416e	83 c6 08	 add	 esi, 8
  04171	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  04175	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  04179	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2259 : 				next;

  0417d	e9 e4 be ff ff	 jmp	 $L58091
$L58836:

; 1002 : 		next;
; 1003 : 	case FPUSH:	/* Move unconverted bits from Int stack to FP stack */
; 1004 : 		ulongp = (unsigned long *)sp;
; 1005 : 		*--fsp = ftos;

  04182	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  04186	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  0418a	83 ee 08	 sub	 esi, 8

; 1006 : 		fbits.fb_long[1] = ulongp[1];
; 1007 : 		fbits.fb_long[0] = ulongp[0];
; 1008 : 		sp = (cell *)(ulongp+2);

  0418d	83 c3 08	 add	 ebx, 8
  04190	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04194	89 16		 mov	 DWORD PTR [esi], edx
  04196	89 46 04	 mov	 DWORD PTR [esi+4], eax
  04199	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  0419c	89 0d 04 00 00
	00		 mov	 DWORD PTR _fbits+4, ecx
  041a2	8b 53 f8	 mov	 edx, DWORD PTR [ebx-8]

; 1009 : 		ftos = fbits.fb_float;

  041a5	8b c2		 mov	 eax, edx
  041a7	89 15 00 00 00
	00		 mov	 DWORD PTR _fbits, edx
  041ad	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  041b1	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx

; 1010 : 		next;

  041b5	e9 ac be ff ff	 jmp	 $L58091
$L58839:

; 1011 : 
; 1012 : 	/* Floating Point Input and Output */
; 1013 : 	/* Implement F. as FSTRING TYPE , E. as ESTRING TYPE */
; 1014 : 	case FSTRING:
; 1015 : 		(void) sprintf(floatstr, "%.*f", (int)V_FNUMPLACES, ftos); 

  041ba	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  041be	8b 4c 24 28	 mov	 ecx, DWORD PTR _up$[esp+304]
  041c2	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  041c6	52		 push	 edx
  041c7	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  041ca	50		 push	 eax
  041cb	52		 push	 edx
  041cc	68 00 00 00 00	 push	 OFFSET FLAT:$SG58842
  041d1	68 00 00 00 00	 push	 OFFSET FLAT:_floatstr
  041d6	e8 00 00 00 00	 call	 _sprintf

; 1016 : 		push( floatstr );

  041db	8b 44 24 20	 mov	 eax, DWORD PTR _tos$[esp+324]
  041df	83 eb 04	 sub	 ebx, 4

; 1017 : 		push( strlen(floatstr) );

  041e2	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_floatstr
  041e7	83 c9 ff	 or	 ecx, -1
  041ea	89 03		 mov	 DWORD PTR [ebx], eax
  041ec	83 eb 04	 sub	 ebx, 4
  041ef	33 c0		 xor	 eax, eax
  041f1	83 c4 14	 add	 esp, 20			; 00000014H
  041f4	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:_floatstr

; 1018 : 		ftos = *fsp++;

  041fa	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  041fd	f2 ae		 repne scasb
  041ff	f7 d1		 not	 ecx
  04201	49		 dec	 ecx
  04202	83 c6 08	 add	 esi, 8
  04205	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  04209	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  0420c	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  04210	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  04214	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 1019 : 		next;

  04218	e9 45 be ff ff	 jmp	 $L61884
$L58845:

; 1020 : 	case ESTRING:
; 1021 : 		(void) sprintf(floatstr, "%.*e", (int)V_FNUMPLACES, ftos);

  0421d	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  04221	8b 54 24 28	 mov	 edx, DWORD PTR _up$[esp+304]
  04225	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  04229	50		 push	 eax
  0422a	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0422d	51		 push	 ecx
  0422e	50		 push	 eax
  0422f	68 00 00 00 00	 push	 OFFSET FLAT:$SG58848
  04234	68 00 00 00 00	 push	 OFFSET FLAT:_floatstr
  04239	e8 00 00 00 00	 call	 _sprintf

; 1022 : 		push( floatstr );

  0423e	8b 4c 24 20	 mov	 ecx, DWORD PTR _tos$[esp+324]
  04242	83 eb 04	 sub	 ebx, 4

; 1023 : 		push( strlen(floatstr) );

  04245	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_floatstr
  0424a	33 c0		 xor	 eax, eax
  0424c	89 0b		 mov	 DWORD PTR [ebx], ecx
  0424e	83 eb 04	 sub	 ebx, 4
  04251	83 c9 ff	 or	 ecx, -1
  04254	83 c4 14	 add	 esp, 20			; 00000014H
  04257	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:_floatstr

; 1024 : 		ftos = *fsp++;

  0425d	8b 16		 mov	 edx, DWORD PTR [esi]
  0425f	f2 ae		 repne scasb
  04261	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  04264	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  04268	f7 d1		 not	 ecx
  0426a	49		 dec	 ecx
  0426b	83 c6 08	 add	 esi, 8
  0426e	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  04272	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  04276	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 1025 : 		next;

  0427a	e9 e3 bd ff ff	 jmp	 $L61884
$L58851:

; 1026 : 
; 1027 : 	/* Comparisons */
; 1028 : #define flag(boolean)	((boolean) ? -1 : 0)
; 1029 : #define fbincmp(operator) push ( flag(*fsp++ operator ftos) ); ftos = *fsp++;
; 1030 : #define funcmp(operator) push ( flag(ftos operator 0.0) ); ftos = *fsp++;
; 1031 : 
; 1032 : 	case FEQ:		fbincmp(==);			next;

  0427f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04283	83 eb 04	 sub	 ebx, 4
  04286	83 c6 08	 add	 esi, 8
  04289	89 0b		 mov	 DWORD PTR [ebx], ecx
  0428b	dd 46 f8	 fld	 QWORD PTR [esi-8]
  0428e	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  04292	df e0		 fnstsw	 ax
  04294	f6 c4 40	 test	 ah, 64			; 00000040H
  04297	0f 84 c9 01 00
	00		 je	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  0429d	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  042a5	e9 c4 26 00 00	 jmp	 $L60690
$L58853:

; 1033 : 	case FNEQ:		fbincmp(!=);			next;

  042aa	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  042ae	83 eb 04	 sub	 ebx, 4
  042b1	83 c6 08	 add	 esi, 8
  042b4	89 0b		 mov	 DWORD PTR [ebx], ecx
  042b6	dd 46 f8	 fld	 QWORD PTR [esi-8]
  042b9	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  042bd	df e0		 fnstsw	 ax
  042bf	f6 c4 40	 test	 ah, 64			; 00000040H
  042c2	0f 85 9e 01 00
	00		 jne	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  042c8	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  042d0	e9 99 26 00 00	 jmp	 $L60690
$L58855:

; 1034 : 	case FLT:		fbincmp(<);			next;

  042d5	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  042d9	83 eb 04	 sub	 ebx, 4
  042dc	83 c6 08	 add	 esi, 8
  042df	89 0b		 mov	 DWORD PTR [ebx], ecx
  042e1	dd 46 f8	 fld	 QWORD PTR [esi-8]
  042e4	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  042e8	df e0		 fnstsw	 ax
  042ea	f6 c4 01	 test	 ah, 1
  042ed	0f 84 73 01 00
	00		 je	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  042f3	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  042fb	e9 6e 26 00 00	 jmp	 $L60690
$L58857:

; 1035 : 	case FGT:		fbincmp(>);			next;

  04300	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04304	83 eb 04	 sub	 ebx, 4
  04307	83 c6 08	 add	 esi, 8
  0430a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0430c	dd 46 f8	 fld	 QWORD PTR [esi-8]
  0430f	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  04313	df e0		 fnstsw	 ax
  04315	f6 c4 41	 test	 ah, 65			; 00000041H
  04318	0f 85 48 01 00
	00		 jne	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  0431e	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  04326	e9 43 26 00 00	 jmp	 $L60690
$L58859:

; 1036 : 	case FLEQ:		fbincmp(<=);			next;

  0432b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0432f	83 eb 04	 sub	 ebx, 4
  04332	83 c6 08	 add	 esi, 8
  04335	89 0b		 mov	 DWORD PTR [ebx], ecx
  04337	dd 46 f8	 fld	 QWORD PTR [esi-8]
  0433a	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  0433e	df e0		 fnstsw	 ax
  04340	f6 c4 41	 test	 ah, 65			; 00000041H
  04343	0f 84 1d 01 00
	00		 je	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  04349	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  04351	e9 18 26 00 00	 jmp	 $L60690
$L58861:

; 1037 : 	case FGEQ:		fbincmp(>=);			next;

  04356	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0435a	83 eb 04	 sub	 ebx, 4
  0435d	83 c6 08	 add	 esi, 8
  04360	89 0b		 mov	 DWORD PTR [ebx], ecx
  04362	dd 46 f8	 fld	 QWORD PTR [esi-8]
  04365	dc 5c 24 10	 fcomp	 QWORD PTR _ftos$[esp+304]
  04369	df e0		 fnstsw	 ax
  0436b	e9 e4 00 00 00	 jmp	 $L61976
$L58863:

; 1038 : 
; 1039 : 	case FZEQ:		funcmp(==);			next;

  04370	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04374	83 eb 04	 sub	 ebx, 4
  04377	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  0437b	89 0b		 mov	 DWORD PTR [ebx], ecx
  0437d	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04383	df e0		 fnstsw	 ax
  04385	f6 c4 40	 test	 ah, 64			; 00000040H
  04388	0f 84 d8 00 00
	00		 je	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  0438e	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  04396	e9 d3 25 00 00	 jmp	 $L60690
$L58865:

; 1040 : 	case FZNEQ:		funcmp(!=);			next;

  0439b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0439f	83 eb 04	 sub	 ebx, 4
  043a2	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  043a6	89 0b		 mov	 DWORD PTR [ebx], ecx
  043a8	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  043ae	df e0		 fnstsw	 ax
  043b0	f6 c4 40	 test	 ah, 64			; 00000040H
  043b3	0f 85 ad 00 00
	00		 jne	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  043b9	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  043c1	e9 a8 25 00 00	 jmp	 $L60690
$L58867:

; 1041 : 	case FZLT:		funcmp(<);			next;

  043c6	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  043ca	83 eb 04	 sub	 ebx, 4
  043cd	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  043d1	89 0b		 mov	 DWORD PTR [ebx], ecx
  043d3	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  043d9	df e0		 fnstsw	 ax
  043db	f6 c4 01	 test	 ah, 1
  043de	0f 84 82 00 00
	00		 je	 $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  043e4	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  043ec	e9 7d 25 00 00	 jmp	 $L60690
$L58869:

; 1042 : 	case FZGT:		funcmp(>);			next;

  043f1	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  043f5	83 eb 04	 sub	 ebx, 4
  043f8	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  043fc	89 0b		 mov	 DWORD PTR [ebx], ecx
  043fe	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04404	df e0		 fnstsw	 ax
  04406	f6 c4 41	 test	 ah, 65			; 00000041H
  04409	75 5b		 jne	 SHORT $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  0440b	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  04413	e9 56 25 00 00	 jmp	 $L60690
$L58871:

; 1043 : 	case FZLEQ:		funcmp(<=);			next;

  04418	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0441c	83 eb 04	 sub	 ebx, 4
  0441f	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  04423	89 0b		 mov	 DWORD PTR [ebx], ecx
  04425	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  0442b	df e0		 fnstsw	 ax
  0442d	f6 c4 41	 test	 ah, 65			; 00000041H
  04430	74 34		 je	 SHORT $L60689

; 1044 : 	case FZGEQ:		funcmp(>=);			next;

  04432	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  0443a	e9 2f 25 00 00	 jmp	 $L60690
$L58873:
  0443f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04443	83 eb 04	 sub	 ebx, 4
  04446	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  0444a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0444c	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@8@00000000000000000000
  04452	df e0		 fnstsw	 ax
$L61976:
  04454	f6 c4 01	 test	 ah, 1
  04457	75 0d		 jne	 SHORT $L60689
  04459	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  04461	e9 08 25 00 00	 jmp	 $L60690
$L60689:
  04466	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  0446e	e9 fb 24 00 00	 jmp	 $L60690
$L58875:

; 1045 : 
; 1046 : 	case FPICK:
; 1047 : 		*--fsp = ftos;

  04473	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  04477	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]

; 1048 : 		ftos = fsp[tos]; tos = *sp++;

  0447b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0447f	83 ee 08	 sub	 esi, 8
  04482	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2486 : 					RESTORE_XCONTEXT

  04486	83 c3 04	 add	 ebx, 4
  04489	89 0e		 mov	 DWORD PTR [esi], ecx
  0448b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0448e	dd 04 c6	 fld	 QWORD PTR [esi+eax*8]
  04491	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  04494	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  04498	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2487 : 					next;

  0449c	e9 c5 bb ff ff	 jmp	 $L58091
$L58876:

; 1049 : 		next;
; 1050 : 	case FNUMQUES:	/* True if string is a valid floating number */
; 1051 : 		scr = pop;

  044a1	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1052 : 		SAVE_XCONTEXT

  044a3	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  044a7	89 03		 mov	 DWORD PTR [ebx], eax
  044a9	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  044ad	83 ee 08	 sub	 esi, 8
  044b0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  044b4	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  044ba	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  044c0	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  044c4	89 06		 mov	 DWORD PTR [esi], eax
  044c6	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  044ca	89 56 04	 mov	 DWORD PTR [esi+4], edx
  044cd	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  044d3	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  044d9	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax

; 1053 : 		scr = (cell)isfloatnum((unsigned char *)scr);

  044de	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  044e1	33 d2		 xor	 edx, edx
  044e3	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  044e6	74 04		 je	 SHORT $L61642
$L61650:
  044e8	33 c9		 xor	 ecx, ecx
  044ea	eb 3b		 jmp	 SHORT $L61639
$L61642:
  044ec	33 c0		 xor	 eax, eax
  044ee	8a 01		 mov	 al, BYTE PTR [ecx]
  044f0	41		 inc	 ecx
  044f1	85 c0		 test	 eax, eax
  044f3	89 44 24 38	 mov	 DWORD PTR _len$61641[esp+304], eax
  044f7	74 2c		 je	 SHORT $L61645
$L61643:
  044f9	33 c0		 xor	 eax, eax
  044fb	8a 01		 mov	 al, BYTE PTR [ecx]
  044fd	41		 inc	 ecx
  044fe	83 e8 2b	 sub	 eax, 43			; 0000002bH
  04501	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  04504	77 e2		 ja	 SHORT $L61650
  04506	33 db		 xor	 ebx, ebx
  04508	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR $L61989[eax]
  0450e	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $L61990[ebx*4]
$L61649:
  04515	ba 01 00 00 00	 mov	 edx, 1
$L61644:
  0451a	8b 44 24 38	 mov	 eax, DWORD PTR _len$61641[esp+304]
  0451e	48		 dec	 eax
  0451f	89 44 24 38	 mov	 DWORD PTR _len$61641[esp+304], eax
  04523	75 d4		 jne	 SHORT $L61643
$L61645:
  04525	8b ca		 mov	 ecx, edx
$L61639:

; 1054 : 		RESTORE_XCONTEXT

  04527	8b 16		 mov	 edx, DWORD PTR [esi]
  04529	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0452c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  04532	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  04536	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  0453c	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  04540	8b 03		 mov	 eax, DWORD PTR [ebx]
  04542	83 c6 08	 add	 esi, 8
  04545	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04549	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx

; 1055 : 		push(scr);

  0454d	89 03		 mov	 DWORD PTR [ebx], eax
  0454f	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 1056 : 		next;

  04553	e9 0e bb ff ff	 jmp	 $L58091
$L58880:

; 1057 : 	case FNUMBER:	/* Convert string to floating point number */
; 1058 : 		*--fsp = ftos;

  04558	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0455c	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]

; 1059 : 		ftos = atof(tocstr((unsigned char *)tos));

  04560	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04564	83 ee 08	 sub	 esi, 8
  04567	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0456b	89 06		 mov	 DWORD PTR [esi], eax
  0456d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  04570	33 c9		 xor	 ecx, ecx
  04572	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  04577	8a 0a		 mov	 cl, BYTE PTR [edx]
  04579	42		 inc	 edx
  0457a	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  0457e	8b d1		 mov	 edx, ecx
  04580	49		 dec	 ecx
  04581	85 d2		 test	 edx, edx
  04583	74 1c		 je	 SHORT $L61658
  04585	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  04589	2b d0		 sub	 edx, eax
  0458b	41		 inc	 ecx
  0458c	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
$L61657:
  04590	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  04593	88 08		 mov	 BYTE PTR [eax], cl
  04595	8b 4c 24 38	 mov	 ecx, DWORD PTR -248+[esp+304]
  04599	40		 inc	 eax
  0459a	49		 dec	 ecx
  0459b	89 4c 24 38	 mov	 DWORD PTR -248+[esp+304], ecx
  0459f	75 ef		 jne	 SHORT $L61657
$L61658:
  045a1	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  045a6	c6 00 00	 mov	 BYTE PTR [eax], 0
  045a9	e8 00 00 00 00	 call	 _atof

; 1060 : 		tos = *sp++;

  045ae	8b 13		 mov	 edx, DWORD PTR [ebx]
  045b0	83 c4 04	 add	 esp, 4
  045b3	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]
  045b7	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2486 : 					RESTORE_XCONTEXT

  045bb	83 c3 04	 add	 ebx, 4

; 2487 : 					next;

  045be	e9 a3 ba ff ff	 jmp	 $L58091
$L58882:

; 1061 : 		next;
; 1062 :     case FPAREN_LIT:
; 1063 : 	ulongp = (unsigned long *)ip;
; 1064 : 	fbits.fb_long[0] = *ulongp++;

  045c3	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  045c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  045c8	83 c0 04	 add	 eax, 4
  045cb	89 0d 00 00 00
	00		 mov	 DWORD PTR _fbits, ecx

; 1065 : 	fbits.fb_long[1] = *ulongp++;
; 1066 : 	*--fsp = ftos;

  045d1	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  045d5	8b 10		 mov	 edx, DWORD PTR [eax]
  045d7	83 c0 04	 add	 eax, 4
  045da	83 ee 08	 sub	 esi, 8
  045dd	89 15 04 00 00
	00		 mov	 DWORD PTR _fbits+4, edx
  045e3	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  045e7	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  045eb	89 0e		 mov	 DWORD PTR [esi], ecx
  045ed	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1067 : 	ftos = fbits.fb_float;

  045f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fbits
  045f6	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _fbits+4
  045fc	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  04600	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 1068 : 	ip = (token_t *)ulongp;

  04604	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 1069 : 	next;

  04607	e9 5a ba ff ff	 jmp	 $L58091
$L58887:

; 1070 : 			case FPRESENT: push(-1);  next;
; 1071 : #ifdef REMOVE
; 1072 : 			/* #locals -- */
; 1073 : 			case ALLOCLOC:
; 1074 : 				ascr = (u_char *)rp;
; 1075 : 				if (tos > 0) {		/* Init locals in ANS Forth order */
; 1076 : 					rp -= tos;		/* + *sp++ */
; 1077 : 					*--rp = (token_t *)frp;
; 1078 : 					*--rp = (token_t *)ascr;	/* Pointer alignment */
; 1079 : 					frp = (cell *)(rp+2);
; 1080 : 					for (scr = 0; scr < tos; scr++)
; 1081 : 						frp[scr] = *sp++;
; 1082 : 				} else {		/* Init locals in reverse order */
; 1083 : 					rp += tos;		/* + *sp++ */
; 1084 : 					*--rp = (token_t *)frp;
; 1085 : 					*--rp = (token_t *)ascr;	/* Pointer alignment */
; 1086 : 					frp = (cell *)(rp+2);
; 1087 : 					for (tos = (-tos); tos; )
; 1088 : 						frp[--tos] = *sp++;
; 1089 : 				}
; 1090 : 				tos = *sp++;
; 1091 : 				next;
; 1092 : #else
; 1093 : 			/* #flocals #locals -- */
; 1094 : 			case ALLOCLOC:
; 1095 : 				ascr = (u_char *)rp;

  0460c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]

; 1096 : 				scr2 = *sp++;		/* #flocals */

  04610	8b 03		 mov	 eax, DWORD PTR [ebx]
  04612	89 4c 24 34	 mov	 DWORD PTR _ascr$[esp+304], ecx

; 1097 : 				if (tos > 0 || scr2 > 0) { /* Init locals in ANS Forth order */

  04616	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0461a	83 c3 04	 add	 ebx, 4
  0461d	89 44 24 6c	 mov	 DWORD PTR _scr2$[esp+304], eax
  04621	85 c9		 test	 ecx, ecx
  04623	0f 8f a7 00 00
	00		 jg	 $L58890
  04629	85 c0		 test	 eax, eax
  0462b	0f 8f a3 00 00
	00		 jg	 $L61973

; 1113 : 						}
; 1114 : 					}
; 1115 : 				} else {		/* Init locals in reverse order */
; 1116 : 					if (scr2) {

  04631	0f 84 93 00 00
	00		 je	 $L61915

; 1117 : 						rp += scr2;		/* + *sp++ */

  04637	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0463b	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]

; 1118 : 						scr2 /= 2;

  0463e	99		 cdq
  0463f	2b c2		 sub	 eax, edx
  04641	d1 f8		 sar	 eax, 1
  04643	f7 d8		 neg	 eax

; 1119 : 						for (scr2 = (-scr2); scr2; ) {

  04645	89 44 24 6c	 mov	 DWORD PTR _scr2$[esp+304], eax
  04649	74 29		 je	 SHORT $L58907
$L58906:

; 1120 : 							((double *)rp)[--scr2] = flpop;

  0464b	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  0464f	48		 dec	 eax
  04650	83 c6 08	 add	 esi, 8
  04653	89 44 24 6c	 mov	 DWORD PTR _scr2$[esp+304], eax
  04657	dd 1c c1	 fstp	 QWORD PTR [ecx+eax*8]
  0465a	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  0465d	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  04660	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  04664	8b 44 24 6c	 mov	 eax, DWORD PTR _scr2$[esp+304]
  04668	85 c0		 test	 eax, eax
  0466a	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  0466e	75 db		 jne	 SHORT $L58906
  04670	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
$L58907:

; 1121 : 						}
; 1122 : 					}
; 1123 : /* FIX: assumes sizeof double is 2 * sizeof cell */
; 1124 : 					rp += tos;
; 1125 : 					*--rp = (token_t *)frp;

  04674	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04678	8d 44 91 fc	 lea	 eax, DWORD PTR [ecx+edx*4-4]
  0467c	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  04680	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 					*--rp = (token_t *)ascr;	/* Pointer alignment */

  04682	8b 4c 24 34	 mov	 ecx, DWORD PTR _ascr$[esp+304]
  04686	83 e8 04	 sub	 eax, 4
  04689	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  0468d	89 08		 mov	 DWORD PTR [eax], ecx

; 1127 : 					frp = (cell *)(rp+2);

  0468f	83 c0 08	 add	 eax, 8

; 1128 : 					if (tos) {

  04692	85 d2		 test	 edx, edx
  04694	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  04698	0f 84 ce 00 00
	00		 je	 $L58902

; 1129 : 						for (tos = (-tos); tos; ) {

  0469e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  046a2	f7 d9		 neg	 ecx
  046a4	0f 84 c2 00 00
	00		 je	 $L58902
  046aa	8b d0		 mov	 edx, eax
  046ac	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
$L58914:

; 1130 : 							frp[--tos] = *sp++;

  046af	8b 13		 mov	 edx, DWORD PTR [ebx]
  046b1	83 e8 04	 sub	 eax, 4
  046b4	83 c3 04	 add	 ebx, 4
  046b7	49		 dec	 ecx
  046b8	89 10		 mov	 DWORD PTR [eax], edx
  046ba	75 f3		 jne	 SHORT $L58914

; 1131 : 						}
; 1132 : 					}
; 1133 : 				}
; 1134 : 				tos = *sp++;

  046bc	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2486 : 					RESTORE_XCONTEXT

  046be	83 c3 04	 add	 ebx, 4
  046c1	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2487 : 					next;

  046c5	e9 9c b9 ff ff	 jmp	 $L58091
$L61915:

; 1119 : 						for (scr2 = (-scr2); scr2; ) {

  046ca	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  046ce	eb a4		 jmp	 SHORT $L58907
$L58890:

; 1098 : 					if (scr2) {

  046d0	85 c0		 test	 eax, eax
  046d2	74 5b		 je	 SHORT $L61916
$L61973:

; 1099 : 						rp -= scr2;		/* + *sp++ */

  046d4	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  046d8	8b c8		 mov	 ecx, eax
  046da	f7 d9		 neg	 ecx

; 1100 : 						scr2 /= 2;
; 1101 : 						for (scr = 0; scr < scr2; scr++) {

  046dc	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _scr$[esp+304], 0
  046e4	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  046e7	99		 cdq
  046e8	2b c2		 sub	 eax, edx
  046ea	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  046ee	d1 f8		 sar	 eax, 1
  046f0	85 c0		 test	 eax, eax
  046f2	89 44 24 6c	 mov	 DWORD PTR _scr2$[esp+304], eax
  046f6	7e 37		 jle	 SHORT $L61916

; 1099 : 						rp -= scr2;		/* + *sp++ */

  046f8	8b c1		 mov	 eax, ecx
$L58892:

; 1102 : 							((double *)rp)[scr] = flpop;

  046fa	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  046fe	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  04702	89 08		 mov	 DWORD PTR [eax], ecx
  04704	89 50 04	 mov	 DWORD PTR [eax+4], edx
  04707	8b 0e		 mov	 ecx, DWORD PTR [esi]
  04709	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0470c	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  04710	8b 4c 24 30	 mov	 ecx, DWORD PTR _scr$[esp+304]
  04714	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  04718	8b 54 24 6c	 mov	 edx, DWORD PTR _scr2$[esp+304]
  0471c	83 c6 08	 add	 esi, 8
  0471f	41		 inc	 ecx
  04720	83 c0 08	 add	 eax, 8
  04723	3b ca		 cmp	 ecx, edx
  04725	89 4c 24 30	 mov	 DWORD PTR _scr$[esp+304], ecx
  04729	7c cf		 jl	 SHORT $L58892
  0472b	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
$L61916:

; 1100 : 						scr2 /= 2;
; 1101 : 						for (scr = 0; scr < scr2; scr++) {

  0472f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 1103 : 						}
; 1104 : 					}
; 1105 : /* FIX: assumes sizeof double is 2 * sizeof cell */
; 1106 : 					rp -= tos;
; 1107 : 					*--rp = (token_t *)frp;

  04733	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  04737	83 c8 ff	 or	 eax, -1
  0473a	2b c1		 sub	 eax, ecx
  0473c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0473f	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  04743	89 10		 mov	 DWORD PTR [eax], edx

; 1108 : 					*--rp = (token_t *)ascr;	/* Pointer alignment */

  04745	8b 54 24 34	 mov	 edx, DWORD PTR _ascr$[esp+304]
  04749	83 e8 04	 sub	 eax, 4
  0474c	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  04750	89 10		 mov	 DWORD PTR [eax], edx

; 1109 : 					frp = (cell *)(rp+2);

  04752	83 c0 08	 add	 eax, 8

; 1110 : 					if (tos) {

  04755	85 c9		 test	 ecx, ecx
  04757	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  0475b	74 0f		 je	 SHORT $L58902

; 1111 : 						for (scr = 0; scr < tos; scr++) {

  0475d	7e 0d		 jle	 SHORT $L58902
$L58900:

; 1112 : 							frp[scr] = *sp++;

  0475f	8b 13		 mov	 edx, DWORD PTR [ebx]
  04761	83 c3 04	 add	 ebx, 4
  04764	89 10		 mov	 DWORD PTR [eax], edx
  04766	83 c0 04	 add	 eax, 4
  04769	49		 dec	 ecx
  0476a	75 f3		 jne	 SHORT $L58900
$L58902:

; 1131 : 						}
; 1132 : 					}
; 1133 : 				}
; 1134 : 				tos = *sp++;

  0476c	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2486 : 					RESTORE_XCONTEXT

  0476e	83 c3 04	 add	 ebx, 4
  04771	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2487 : 					next;

  04775	e9 ec b8 ff ff	 jmp	 $L58091
$L58916:

; 1135 : 				next;
; 1136 : #endif
; 1137 : 			/* -- */
; 1138 : 			case FREELOC:
; 1139 : 				frp = (cell *)frp[-1];

  0477a	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]

; 1140 : 				rp = *(token_t ***)rp;

  0477e	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  04782	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04785	8b 08		 mov	 ecx, DWORD PTR [eax]
  04787	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  0478b	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx

; 1141 : 				next;

  0478f	e9 d2 b8 ff ff	 jmp	 $L58091
$L58919:

; 1142 : 			/* offset -- value */
; 1143 : 			case GETLOC:
; 1144 : 				tos = frp[tos];

  04794	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  04798	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0479c	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  0479f	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 1145 : 				next;

  047a3	e9 be b8 ff ff	 jmp	 $L58091
$L58920:

; 1146 : 			/* value offset -- */
; 1147 : 			case SETLOC:
; 1148 : 				frp[tos] = *sp++;

  047a8	8b 13		 mov	 edx, DWORD PTR [ebx]
  047aa	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  047ae	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  047b2	83 c3 04	 add	 ebx, 4

; 2486 : 					RESTORE_XCONTEXT

  047b5	83 c3 04	 add	 ebx, 4
  047b8	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  047bb	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]
  047be	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2487 : 					next;

  047c2	e9 9f b8 ff ff	 jmp	 $L58091
$L58921:

; 1149 : 				tos = *sp++;
; 1150 : 				next;
; 1151 : 			/* name-addr name-len data code -- */
; 1152 : 			case LOCNAME:
; 1153 : 				locnames[nlocnames].code = (token_t)tos;

  047c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
  047cd	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]

; 1154 : 				locnames[nlocnames].data = *sp++;

  047d1	83 c3 04	 add	 ebx, 4
  047d4	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]

; 1155 : 				locnames[nlocnames].name[0] = (u_char)*sp++;

  047d7	83 c3 04	 add	 ebx, 4

; 1156 : 				cmove((u_char *)*sp++, (u_char *)(&locnames[nlocnames].name[1]),
; 1157 : 					(cell)(locnames[nlocnames].name[0]));

  047da	83 c3 04	 add	 ebx, 4
  047dd	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  047e0	c1 e0 02	 shl	 eax, 2
  047e3	89 90 24 00 00
	00		 mov	 DWORD PTR _locnames[eax+36], edx
  047e9	8b 53 f4	 mov	 edx, DWORD PTR [ebx-12]
  047ec	89 90 28 00 00
	00		 mov	 DWORD PTR _locnames[eax+40], edx
  047f2	8a 53 f8	 mov	 dl, BYTE PTR [ebx-8]
  047f5	88 90 00 00 00
	00		 mov	 BYTE PTR _locnames[eax], dl
  047fb	33 d2		 xor	 edx, edx
  047fd	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _locnames[eax]
  04803	8d 80 01 00 00
	00		 lea	 eax, DWORD PTR _locnames[eax+1]
  04809	89 44 24 50	 mov	 DWORD PTR $T61666[esp+304], eax
  0480d	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  04810	89 44 24 40	 mov	 DWORD PTR $T61665[esp+304], eax
  04814	8b c2		 mov	 eax, edx
  04816	4a		 dec	 edx
  04817	85 c0		 test	 eax, eax
  04819	74 24		 je	 SHORT $L61664
  0481b	8b 4c 24 40	 mov	 ecx, DWORD PTR $T61665[esp+304]
  0481f	8b 44 24 50	 mov	 eax, DWORD PTR $T61666[esp+304]
  04823	42		 inc	 edx
  04824	89 54 24 38	 mov	 DWORD PTR -248+[esp+304], edx
$L61663:
  04828	8a 11		 mov	 dl, BYTE PTR [ecx]
  0482a	88 10		 mov	 BYTE PTR [eax], dl
  0482c	8b 54 24 38	 mov	 edx, DWORD PTR -248+[esp+304]
  04830	40		 inc	 eax
  04831	41		 inc	 ecx
  04832	4a		 dec	 edx
  04833	89 54 24 38	 mov	 DWORD PTR -248+[esp+304], edx
  04837	75 ef		 jne	 SHORT $L61663
  04839	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nlocnames
$L61664:

; 1158 : 				++nlocnames;

  0483f	41		 inc	 ecx

; 2486 : 					RESTORE_XCONTEXT

  04840	83 c3 04	 add	 ebx, 4
  04843	89 0d 00 00 00
	00		 mov	 DWORD PTR _nlocnames, ecx
  04849	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  0484c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2487 : 					next;

  04850	e9 11 b8 ff ff	 jmp	 $L58091
$L58927:

; 1159 : 				tos = pop;
; 1160 : 				next;
; 1161 : 			/* -- */
; 1162 : 			case FREENAMES:
; 1163 : 				nlocnames = 0;

  04855	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _nlocnames, 0

; 1164 : 				next;

  0485f	e9 02 b8 ff ff	 jmp	 $L58091
$L58949:

; 1183 : 				next;
; 1184 : #else
; 1185 : 			case PAUSE:
; 1186 : pause:			SAVE_XCONTEXT
; 1187 : 				MemeOften();
; 1188 : 				if (multitasking && xup != (cell *) XV_LINK) {
; 1189 : 					SAVE_XTASKCONTEXT
; 1190 : 					do {
; 1191 : 						xup = (cell *) XV_LINK;
; 1192 : task_disp1:				if (XV_TASK_ACTIVE) break;
; 1193 : 						MemeOften();
; 1194 : 					} while (xup != (cell *) XV_LINK) ;
; 1195 : 					RESTORE_XTASKCONTEXT
; 1196 : 				}
; 1197 : 				RESTORE_XCONTEXT
; 1198 : 				next;
; 1199 : task_dispatcher:
; 1200 : 				SAVE_XCONTEXT
; 1201 : 				SAVE_XTASKCONTEXT
; 1202 : 				goto task_disp1;
; 1203 : #endif
; 1204 : 
; 1205 :    case SINGLE:			/* -- */
; 1206 : 		/* disable multitasking */
; 1207 : 		multitasking = 0;

  04864	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _multitasking, 0

; 1208 : 		V_TASK_ACTIVE = -1;

  0486e	c7 47 60 ff ff
	ff ff		 mov	 DWORD PTR [edi+96], -1

; 1209 : 		next;

  04875	e9 ec b7 ff ff	 jmp	 $L58091
$L58950:

; 1210 : 		
; 1211 :    case MULTI:			/* -- */
; 1212 : 		/* enable multitasking */
; 1213 : 		multitasking = -1;

  0487a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _multitasking, -1

; 1214 : 		next;

  04884	e9 dd b7 ff ff	 jmp	 $L58091
$L58951:

; 1215 : 
; 1216 :    case ALLOC_MEM:		/* size -- addr */
; 1217 : 		/* allocate a block of memory */
; 1218 : 		{
; 1219 : 		    unsigned size = pop; 

  04889	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0488d	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1220 : 		    push((cell *) malloc(size));

  0488f	50		 push	 eax
  04890	89 0b		 mov	 DWORD PTR [ebx], ecx
  04892	e8 00 00 00 00	 call	 _malloc
  04897	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  0489a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0489e	e9 c3 b7 ff ff	 jmp	 $L58091
$L58955:

; 1221 : 		    next;
; 1222 : 		}
; 1223 :    
; 1224 :    case FREE_MEM:		/* addr -- */
; 1225 : 		/* release a previously allocated block of memory */
; 1226 : 		{
; 1227 : 		    char *cp = (char *) pop;

  048a3	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  048a7	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1228 : 		    free(cp);

  048a9	50		 push	 eax
  048aa	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  048ae	83 c3 04	 add	 ebx, 4
  048b1	e8 00 00 00 00	 call	 _free
  048b6	83 c4 04	 add	 esp, 4

; 1229 : 		    next;

  048b9	e9 a8 b7 ff ff	 jmp	 $L58091
$L58958:

; 1230 : 		}
; 1231 :     case TOMAINTASK:
; 1232 : 		/* Pass control to the main task directly.  This is
; 1233 : 		 * used by a task that has terminated to pass control
; 1234 : 		 * for the last time.
; 1235 : 		 * Note that context is not saved.
; 1236 : 		 * If the current task is maintask, this code is a no-op.
; 1237 : 		 */
; 1238 : 		if (up != (cell *)main_task) {

  048be	81 ff 00 00 00
	00		 cmp	 edi, OFFSET FLAT:_main_task
  048c4	0f 84 9c b7 ff
	ff		 je	 $L58091

; 1239 : 			up = (cell *)main_task;	
; 1240 : 			while (!V_TASK_ACTIVE) {

  048ca	a1 60 00 00 00	 mov	 eax, DWORD PTR _main_task+96
  048cf	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_main_task
  048d4	85 c0		 test	 eax, eax
  048d6	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  048da	75 0e		 jne	 SHORT $L58964
$L58963:

; 1241 : 				up = (cell *) V_LINK;

  048dc	8b 7f 5c	 mov	 edi, DWORD PTR [edi+92]
  048df	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  048e2	85 c0		 test	 eax, eax
  048e4	74 f6		 je	 SHORT $L58963
  048e6	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
$L58964:

; 1242 : 			}
; 1243 : 			RESTORE_TASKCONTEXT

  048ea	8b b7 94 00 00
	00		 mov	 esi, DWORD PTR [edi+148]
  048f0	8b 97 a8 00 00
	00		 mov	 edx, DWORD PTR [edi+168]
  048f6	8b 5f 6c	 mov	 ebx, DWORD PTR [edi+108]
  048f9	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  048fd	8b 06		 mov	 eax, DWORD PTR [esi]
  048ff	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  04902	8b 13		 mov	 edx, DWORD PTR [ebx]
  04904	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  04908	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  0490b	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  0490f	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  04912	83 c6 08	 add	 esi, 8
  04915	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04919	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  0491d	83 c3 04	 add	 ebx, 4
  04920	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  04924	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx

; 1244 : 		} next;

  04927	e9 3a b7 ff ff	 jmp	 $L58091
$L58971:

; 1245 :     case MAINTASK:
; 1246 : 		push(main_task);

  0492c	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04930	83 eb 04	 sub	 ebx, 4
  04933	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], OFFSET FLAT:_main_task
  0493b	89 13		 mov	 DWORD PTR [ebx], edx

; 1247 : 		next;

  0493d	e9 24 b7 ff ff	 jmp	 $L58091
$L58973:

; 1248 :     case NFRAMES:
; 1249 : 		push(&NumberFrames);

  04942	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04946	83 eb 04	 sub	 ebx, 4
  04949	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], OFFSET FLAT:_NumberFrames
  04951	89 03		 mov	 DWORD PTR [ebx], eax

; 1250 : 		next;

  04953	e9 0e b7 ff ff	 jmp	 $L58091
$L58975:

; 1251 :     case MAXCODEFIELD:
; 1252 : 		push(MAXCF - 1);

  04958	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0495c	83 eb 04	 sub	 ebx, 4
  0495f	c7 44 24 0c 97
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 407 ; 00000197H
  04967	89 0b		 mov	 DWORD PTR [ebx], ecx

; 1253 : 		next;

  04969	e9 f8 b6 ff ff	 jmp	 $L58091
$L58977:

; 1254 :     case DEBUGGERDATA:
; 1255 : 		push(&DebuggerData);

  0496e	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04972	83 eb 04	 sub	 ebx, 4
  04975	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], OFFSET FLAT:_DebuggerData
  0497d	89 13		 mov	 DWORD PTR [ebx], edx

; 1256 : 		next;

  0497f	e9 e2 b6 ff ff	 jmp	 $L58091
$L58979:

; 1257 :     case IFPAREN_LIT: {
; 1258 : 		cell exponent, mantissa;
; 1259 : 		*(ip-1) = (token_t)FPAREN_LIT;

  04984	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]

; 1260 : 		exponent = *(cell *)ip;
; 1261 : 		mantissa = *((cell *)ip + 1);
; 1262 : 		*--fsp = ftos;

  04987	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  0498b	83 ee 08	 sub	 esi, 8
  0498e	8b 08		 mov	 ecx, DWORD PTR [eax]
  04990	c7 40 fc e8 00
	00 00		 mov	 DWORD PTR [eax-4], 232	; 000000e8H
  04997	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0499a	89 16		 mov	 DWORD PTR [esi], edx
  0499c	89 44 24 40	 mov	 DWORD PTR _mantissa$58981[esp+304], eax
  049a0	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  049a4	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1263 : 		IFloat2Float(exponent, mantissa, &ftemp);

  049a7	8b 44 24 40	 mov	 eax, DWORD PTR _mantissa$58981[esp+304]
  049ab	8d 54 24 60	 lea	 edx, DWORD PTR _ftemp$[esp+304]
  049af	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  049b3	52		 push	 edx
  049b4	50		 push	 eax
  049b5	51		 push	 ecx
  049b6	e8 00 00 00 00	 call	 _IFloat2Float

; 1264 : 		*(double *)ip = ftos = ftemp;

  049bb	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  049be	8b 4c 24 6c	 mov	 ecx, DWORD PTR _ftemp$[esp+316]
  049c2	8b 54 24 70	 mov	 edx, DWORD PTR _ftemp$[esp+320]
  049c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  049c9	89 08		 mov	 DWORD PTR [eax], ecx
  049cb	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1265 : 		ip += 2;

  049ce	83 c0 08	 add	 eax, 8
  049d1	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  049d5	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  049d9	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 1266 : 	} next;

  049dc	e9 85 b6 ff ff	 jmp	 $L58091
$L58986:

; 1267 : 	/* mantissa exponent -- */
; 1268 : 	/* [float] -- f */
; 1269 :     case IF2F:	scr = pop;		/* exponent */

  049e1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  049e3	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1270 : 		IFloat2Float(scr, tos, &ftemp);

  049e7	8d 54 24 60	 lea	 edx, DWORD PTR _ftemp$[esp+304]
  049eb	83 c3 04	 add	 ebx, 4
  049ee	52		 push	 edx
  049ef	51		 push	 ecx
  049f0	50		 push	 eax
  049f1	e8 00 00 00 00	 call	 _IFloat2Float

; 1271 : 		flpush(ftemp); tos = *sp++;

  049f6	8b 44 24 1c	 mov	 eax, DWORD PTR _ftos$[esp+316]
  049fa	8b 4c 24 20	 mov	 ecx, DWORD PTR _ftos$[esp+320]
  049fe	83 ee 08	 sub	 esi, 8
  04a01	83 c4 0c	 add	 esp, 12			; 0000000cH
  04a04	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2486 : 					RESTORE_XCONTEXT

  04a08	83 c3 04	 add	 ebx, 4
  04a0b	89 06		 mov	 DWORD PTR [esi], eax
  04a0d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  04a10	8b 54 24 60	 mov	 edx, DWORD PTR _ftemp$[esp+304]
  04a14	8b 44 24 64	 mov	 eax, DWORD PTR _ftemp$[esp+308]
  04a18	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  04a1b	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  04a1f	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  04a23	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2487 : 					next;

  04a27	e9 3a b6 ff ff	 jmp	 $L58091
$L58987:

; 1272 : 		next;
; 1273 : 	/* -- mantissa exponent */
; 1274 : 	/* [float] f -- */
; 1275 :     case F2IF:	ftemp = flpop;

  04a2c	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  04a30	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  04a34	89 44 24 64	 mov	 DWORD PTR _ftemp$[esp+308], eax

; 1276 : 		*--sp = tos; --sp;

  04a38	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04a3c	83 eb 04	 sub	 ebx, 4
  04a3f	89 54 24 60	 mov	 DWORD PTR _ftemp$[esp+304], edx
  04a43	8b 0e		 mov	 ecx, DWORD PTR [esi]
  04a45	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  04a48	89 03		 mov	 DWORD PTR [ebx], eax

; 1277 : 		Float2IFloat(ftemp, &scr2, sp);

  04a4a	8b 44 24 60	 mov	 eax, DWORD PTR _ftemp$[esp+304]
  04a4e	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  04a52	83 eb 04	 sub	 ebx, 4
  04a55	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  04a59	8b 54 24 64	 mov	 edx, DWORD PTR _ftemp$[esp+308]
  04a5d	8d 4c 24 6c	 lea	 ecx, DWORD PTR _scr2$[esp+304]
  04a61	53		 push	 ebx
  04a62	51		 push	 ecx
  04a63	83 c6 08	 add	 esi, 8
  04a66	52		 push	 edx
  04a67	50		 push	 eax
  04a68	89 74 24 34	 mov	 DWORD PTR _fsp$[esp+320], esi
  04a6c	e8 00 00 00 00	 call	 _Float2IFloat

; 1278 : 		tos = scr2;

  04a71	8b 4c 24 7c	 mov	 ecx, DWORD PTR _scr2$[esp+320]
  04a75	83 c4 10	 add	 esp, 16			; 00000010H
  04a78	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 1279 : 		next;

  04a7c	e9 e5 b5 ff ff	 jmp	 $L58091
$L58988:

; 1280 :     case SETRELOCBIT:
; 1281 : 		SAVE_XCONTEXT

  04a81	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04a85	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  04a89	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  04a8d	83 eb 04	 sub	 ebx, 4
  04a90	83 ee 08	 sub	 esi, 8
  04a93	89 13		 mov	 DWORD PTR [ebx], edx
  04a95	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  04a99	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  04a9f	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  04aa4	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  04aa8	89 0e		 mov	 DWORD PTR [esi], ecx
  04aaa	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1282 : 		set_relocation_bit((cell *)*xsp);

  04aad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xsp
  04ab3	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  04ab9	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  04abf	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  04ac4	8b 01		 mov	 eax, DWORD PTR [ecx]
  04ac6	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  04acc	85 c9		 test	 ecx, ecx
  04ace	74 16		 je	 SHORT $L61682
  04ad0	8b 7f 1c	 mov	 edi, DWORD PTR [edi+28]
  04ad3	2b c7		 sub	 eax, edi
  04ad5	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  04ad8	03 cf		 add	 ecx, edi
  04ada	c1 f8 02	 sar	 eax, 2
  04add	c6 04 08 03	 mov	 BYTE PTR [eax+ecx], 3
  04ae1	e9 8e 25 00 00	 jmp	 $L61693
$L61682:
  04ae6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _origin
  04aec	8b c8		 mov	 ecx, eax
  04aee	2b ce		 sub	 ecx, esi
  04af0	c1 f9 02	 sar	 ecx, 2
  04af3	78 28		 js	 SHORT $L61692
  04af5	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR _main_task+112
  04afb	77 20		 ja	 SHORT $L61692
  04afd	a1 00 00 00 00	 mov	 eax, DWORD PTR _relmap
  04b02	8b d1		 mov	 edx, ecx
  04b04	c1 fa 03	 sar	 edx, 3
  04b07	03 c2		 add	 eax, edx
  04b09	83 e1 07	 and	 ecx, 7
  04b0c	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _bit[ecx]
  04b12	8a 10		 mov	 dl, BYTE PTR [eax]
  04b14	0a d1		 or	 dl, cl
  04b16	88 10		 mov	 BYTE PTR [eax], dl
  04b18	e9 57 25 00 00	 jmp	 $L61693
$L61692:
  04b1d	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:_main_task
  04b22	c1 f8 02	 sar	 eax, 2
  04b25	0f 88 49 25 00
	00		 js	 $L61693
  04b2b	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  04b30	0f 83 3e 25 00
	00		 jae	 $L61693
  04b36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _urelmap
  04b3c	8b d0		 mov	 edx, eax
  04b3e	c1 fa 03	 sar	 edx, 3
  04b41	83 e0 07	 and	 eax, 7
  04b44	03 ca		 add	 ecx, edx
  04b46	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _bit[eax]
  04b4c	8a 01		 mov	 al, BYTE PTR [ecx]
  04b4e	0a c2		 or	 al, dl
  04b50	88 01		 mov	 BYTE PTR [ecx], al

; 1283 : 		RESTORE_XCONTEXT
; 1284 : 		next;

  04b52	e9 1d 25 00 00	 jmp	 $L61693
$L58990:

; 1285 : 		
; 1286 : 	case OBJECT:		scr = pop; push((cell)&Objects[scr]);	next;

  04b57	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04b5b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04b5d	89 0b		 mov	 DWORD PTR [ebx], ecx
  04b5f	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  04b66	2b d0		 sub	 edx, eax
  04b68	c1 e2 04	 shl	 edx, 4
  04b6b	81 c2 00 00 00
	00		 add	 edx, OFFSET FLAT:_Objects
  04b71	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  04b75	e9 ec b4 ff ff	 jmp	 $L58091
$L58993:

; 1287 : 	case RENDER:		Render(); 				next;

  04b7a	e8 00 00 00 00	 call	 _Render
  04b7f	e9 e2 b4 ff ff	 jmp	 $L58091
$L58994:

; 1288 : 	case NUMOBJECTS:	push( NumberObjects() );		next;

  04b84	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04b88	83 eb 04	 sub	 ebx, 4
  04b8b	89 03		 mov	 DWORD PTR [ebx], eax
  04b8d	e8 00 00 00 00	 call	 _NumberObjects

; 2298 : 				push(scr);

  04b92	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04b96	e9 cb b4 ff ff	 jmp	 $L58091
$L58996:

; 1289 : 	/* ( parent linktype x y width height -- objaddr ) */
; 1290 : 	case NEWCAMERA: { 
; 1291 : 		Object *obj, *parent;
; 1292 : 		cell linktype, subtype, height, width, x, y; 
; 1293 : 		height = pop; width = pop; y = pop; x = pop;

  04b9b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04b9d	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  04ba0	83 c3 04	 add	 ebx, 4
  04ba3	89 54 24 40	 mov	 DWORD PTR _y$59004[esp+304], edx
  04ba7	83 c3 04	 add	 ebx, 4
  04baa	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1294 : 		subtype = pop; linktype = pop; parent = (Object *)pop;
; 1295 : 		obj = NewCameraObject(parent, linktype, subtype, x, y, width, height);

  04bae	50		 push	 eax
  04baf	8b 44 24 44	 mov	 eax, DWORD PTR _y$59004[esp+308]
  04bb3	8b 13		 mov	 edx, DWORD PTR [ebx]
  04bb5	83 c3 04	 add	 ebx, 4
  04bb8	89 54 24 54	 mov	 DWORD PTR _x$59003[esp+308], edx
  04bbc	51		 push	 ecx
  04bbd	8b 13		 mov	 edx, DWORD PTR [ebx]
  04bbf	83 c3 04	 add	 ebx, 4
  04bc2	89 54 24 78	 mov	 DWORD PTR _subtype$59000[esp+312], edx
  04bc6	8b 4c 24 58	 mov	 ecx, DWORD PTR _x$59003[esp+312]
  04bca	8b 13		 mov	 edx, DWORD PTR [ebx]
  04bcc	83 c3 04	 add	 ebx, 4
  04bcf	89 54 24 40	 mov	 DWORD PTR _linktype$58999[esp+312], edx
  04bd3	50		 push	 eax
  04bd4	8b 13		 mov	 edx, DWORD PTR [ebx]
  04bd6	8b 44 24 44	 mov	 eax, DWORD PTR _linktype$58999[esp+316]
  04bda	83 c3 04	 add	 ebx, 4
  04bdd	89 54 24 68	 mov	 DWORD PTR _parent$58998[esp+316], edx
  04be1	51		 push	 ecx
  04be2	8b 4c 24 6c	 mov	 ecx, DWORD PTR _parent$58998[esp+320]
  04be6	8b 13		 mov	 edx, DWORD PTR [ebx]
  04be8	89 54 24 1c	 mov	 DWORD PTR _tos$[esp+320], edx
  04bec	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR _subtype$59000[esp+320]
  04bf3	52		 push	 edx
  04bf4	50		 push	 eax
  04bf5	51		 push	 ecx
  04bf6	e8 00 00 00 00	 call	 _NewCameraObject

; 1296 : 		push( (cell) obj); next;

  04bfb	8b 54 24 28	 mov	 edx, DWORD PTR _tos$[esp+332]
  04bff	83 c4 1c	 add	 esp, 28			; 0000001cH
  04c02	89 13		 mov	 DWORD PTR [ebx], edx

; 2298 : 				push(scr);

  04c04	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04c08	e9 59 b4 ff ff	 jmp	 $L58091
$L59008:

; 1297 : 	}
; 1298 : 
; 1299 : 	/* ( parent linktype subtype -- objaddr ) */
; 1300 : 	case NEWLIGHT: {
; 1301 : 		Object *parent, *obj;
; 1302 : 		cell linktype, subtype;
; 1303 : 		subtype = pop; linktype = pop; parent = (Object *)pop;

  04c0d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04c0f	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  04c12	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04c16	83 c3 04	 add	 ebx, 4
  04c19	83 c3 04	 add	 ebx, 4
  04c1c	89 54 24 40	 mov	 DWORD PTR _parent$59009[esp+304], edx

; 1304 : 		obj = NewLightObject(parent, linktype, subtype);

  04c20	50		 push	 eax
  04c21	8b 44 24 44	 mov	 eax, DWORD PTR _parent$59009[esp+308]
  04c25	8b 13		 mov	 edx, DWORD PTR [ebx]
  04c27	51		 push	 ecx
  04c28	50		 push	 eax
  04c29	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  04c2d	e8 00 00 00 00	 call	 _NewLightObject

; 1305 : 		push(obj); next;

  04c32	8b 4c 24 18	 mov	 ecx, DWORD PTR _tos$[esp+316]
  04c36	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2298 : 				push(scr);

  04c39	89 0b		 mov	 DWORD PTR [ebx], ecx
  04c3b	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04c3f	e9 22 b4 ff ff	 jmp	 $L58091
$L59015:

; 1306 : 	}
; 1307 : 
; 1308 : 	/* ( parent linktype subtype filenameaddr -- objaddr ) */
; 1309 : 	case NEWVISIBLE: {
; 1310 : 		Object *obj, *parent;
; 1311 : 		char *filename;
; 1312 : 		cell linktype, subtype;
; 1313 : 		RFRequest *rq;
; 1314 : 
; 1315 : 		filename = (char *)pop;

  04c44	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04c48	8b 03		 mov	 eax, DWORD PTR [ebx]
  04c4a	83 c3 04	 add	 ebx, 4
  04c4d	89 4c 24 30	 mov	 DWORD PTR _filename$59018[esp+304], ecx

; 1316 : 
; 1317 : 		/* If filename is null, make an object with no geometry */
; 1318 : 		if (filename == NULL) {

  04c51	85 c9		 test	 ecx, ecx
  04c53	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  04c57	75 35		 jne	 SHORT $L59024

; 1319 : 			subtype = pop;

  04c59	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1320 : 			linktype = pop;

  04c5b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  04c5e	83 c3 04	 add	 ebx, 4

; 1321 : 			parent = (Object *)apop;

  04c61	89 54 24 30	 mov	 DWORD PTR _parent$59017[esp+304], edx
  04c65	83 c3 04	 add	 ebx, 4

; 1322 : 			obj = NewVisibleObject(parent, linktype, subtype, 0);

  04c68	6a 00		 push	 0
  04c6a	50		 push	 eax
  04c6b	8b 44 24 38	 mov	 eax, DWORD PTR _parent$59017[esp+312]
  04c6f	8b 13		 mov	 edx, DWORD PTR [ebx]
  04c71	51		 push	 ecx
  04c72	50		 push	 eax
  04c73	89 54 24 1c	 mov	 DWORD PTR _tos$[esp+320], edx
  04c77	e8 00 00 00 00	 call	 _NewVisibleObject

; 1323 : 			push(obj);

  04c7c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _tos$[esp+320]
  04c80	83 c4 10	 add	 esp, 16			; 00000010H

; 2298 : 				push(scr);

  04c83	89 0b		 mov	 DWORD PTR [ebx], ecx
  04c85	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04c89	e9 d8 b3 ff ff	 jmp	 $L58091
$L59024:

; 1324 : 			next;
; 1325 : 		}
; 1326 : 		if (filename != (char *)-1) {	/* First time, try to open URL */

  04c8e	83 f9 ff	 cmp	 ecx, -1
  04c91	74 37		 je	 SHORT $L59029

; 1327 : 			rq = malloc(sizeof(RFRequest));

  04c93	68 10 01 00 00	 push	 272			; 00000110H
  04c98	e8 00 00 00 00	 call	 _malloc
  04c9d	83 c4 04	 add	 esp, 4
  04ca0	89 44 24 2c	 mov	 DWORD PTR _rq$59021[esp+304], eax

; 1328 : 			if (!rq) {

  04ca4	85 c0		 test	 eax, eax
  04ca6	75 0c		 jne	 SHORT $L59031

; 1329 : 				sp += 3; tos = 0;

  04ca8	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  04cab	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2022 : 				next;

  04caf	e9 b2 b3 ff ff	 jmp	 $L58091
$L59031:

; 1330 : 				next;
; 1331 : 			}
; 1332 : 			OpenURL(filename, rq, rfrqFILE);

  04cb4	8b 54 24 2c	 mov	 edx, DWORD PTR _rq$59021[esp+304]
  04cb8	8b 44 24 30	 mov	 eax, DWORD PTR _filename$59018[esp+304]
  04cbc	6a 00		 push	 0
  04cbe	52		 push	 edx
  04cbf	50		 push	 eax
  04cc0	e8 00 00 00 00	 call	 _OpenURL
  04cc5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1333 : 		} else {						/* Not first time, we're idling */

  04cc8	eb 16		 jmp	 SHORT $L59032
$L59029:

; 1334 : 			rq = (RFRequest *)pop;

  04cca	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1335 : 			WaitURL(rq);

  04ccc	50		 push	 eax
  04ccd	89 44 24 30	 mov	 DWORD PTR _rq$59021[esp+308], eax
  04cd1	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  04cd5	83 c3 04	 add	 ebx, 4
  04cd8	e8 00 00 00 00	 call	 _WaitURL
  04cdd	83 c4 04	 add	 esp, 4
$L59032:

; 1336 : 		}
; 1337 : 		if (rq->status == 0) {		/* File opened */

  04ce0	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59021[esp+304]
  04ce4	8b 01		 mov	 eax, DWORD PTR [ecx]
  04ce6	85 c0		 test	 eax, eax
  04ce8	0f 85 c0 00 00
	00		 jne	 $L59034

; 1338 : 			filename = rq->tmpname;

  04cee	8b d1		 mov	 edx, ecx

; 1339 : 			subtype = pop;

  04cf0	83 c3 04	 add	 ebx, 4
  04cf3	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 1340 : 			linktype = pop;

  04cf7	83 c3 04	 add	 ebx, 4
  04cfa	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  04cfd	8b 53 f8	 mov	 edx, DWORD PTR [ebx-8]
  04d00	89 54 24 40	 mov	 DWORD PTR _linktype$59019[esp+304], edx
  04d04	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]

; 1341 : 			parent = (Object *)pop;

  04d07	89 54 24 30	 mov	 DWORD PTR _parent$59017[esp+304], edx
  04d0b	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1342 : 			SAVE_XCONTEXT

  04d0d	89 13		 mov	 DWORD PTR [ebx], edx
  04d0f	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  04d13	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  04d19	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  04d1d	83 ee 08	 sub	 esi, 8

; 1343 : 			obj = NewVisibleObject(parent, linktype, subtype, filename);

  04d20	50		 push	 eax
  04d21	8b 44 24 44	 mov	 eax, DWORD PTR _linktype$59019[esp+308]
  04d25	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  04d2b	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  04d2f	51		 push	 ecx
  04d30	8b 4c 24 38	 mov	 ecx, DWORD PTR _parent$59017[esp+312]
  04d34	89 16		 mov	 DWORD PTR [esi], edx
  04d36	8b 54 24 28	 mov	 edx, DWORD PTR _frp$[esp+312]
  04d3a	50		 push	 eax
  04d3b	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  04d3e	51		 push	 ecx
  04d3f	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  04d45	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  04d4b	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  04d51	e8 00 00 00 00	 call	 _NewVisibleObject

; 1344 : #ifdef REMOVE
; 1345 : 			/* Don't remove temporary files anymore, because of caching */
; 1346 : 			ascr = strrchr(filename, '.');
; 1347 : 			if (ascr && !strcmp(ascr, ".tmp")) unlink(filename);
; 1348 : #endif
; 1349 : 			RESTORE_XCONTEXT

  04d56	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  04d5c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  04d62	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  04d68	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  04d6e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  04d70	89 54 24 30	 mov	 DWORD PTR _frp$[esp+320], edx
  04d74	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  04d77	89 4c 24 20	 mov	 DWORD PTR _ftos$[esp+320], ecx
  04d7b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  04d81	89 54 24 24	 mov	 DWORD PTR _ftos$[esp+324], edx

; 1350 : 			push(obj);
; 1351 : 			free(rq);

  04d85	8b 54 24 3c	 mov	 edx, DWORD PTR _rq$59021[esp+320]
  04d89	89 4c 24 2c	 mov	 DWORD PTR _rp$[esp+320], ecx
  04d8d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04d8f	83 c6 08	 add	 esi, 8
  04d92	52		 push	 edx
  04d93	89 7c 24 3c	 mov	 DWORD PTR _up$[esp+324], edi
  04d97	89 74 24 38	 mov	 DWORD PTR _fsp$[esp+324], esi
  04d9b	89 0b		 mov	 DWORD PTR [ebx], ecx
  04d9d	89 44 24 20	 mov	 DWORD PTR _tos$[esp+324], eax
  04da1	e8 00 00 00 00	 call	 _free
  04da6	83 c4 14	 add	 esp, 20			; 00000014H

; 1352 : 			next;

  04da9	e9 b8 b2 ff ff	 jmp	 $L58091
$L59034:

; 1353 : 		}
; 1354 : 		if (rq->status == 1) {		/* Request failed */

  04dae	83 f8 01	 cmp	 eax, 1
  04db1	0f 85 be 00 00
	00		 jne	 $L59037

; 1355 : 			strcpy(errMsg, "Couldn't read URL ");

  04db7	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG59038
  04dbc	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG59038+4
  04dc2	a3 00 00 00 00	 mov	 DWORD PTR _errMsg, eax
  04dc7	a1 08 00 00 00	 mov	 eax, DWORD PTR $SG59038+8
  04dcc	a3 08 00 00 00	 mov	 DWORD PTR _errMsg+8, eax
  04dd1	66 a1 10 00 00
	00		 mov	 ax, WORD PTR $SG59038+16
  04dd7	89 15 04 00 00
	00		 mov	 DWORD PTR _errMsg+4, edx
  04ddd	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR $SG59038+12
  04de3	66 a3 10 00 00
	00		 mov	 WORD PTR _errMsg+16, ax

; 1356 : 			if (filename == (char *)-1) {

  04de9	8b 44 24 30	 mov	 eax, DWORD PTR _filename$59018[esp+304]
  04ded	89 15 0c 00 00
	00		 mov	 DWORD PTR _errMsg+12, edx
  04df3	8a 15 12 00 00
	00		 mov	 dl, BYTE PTR $SG59038+18
  04df9	83 f8 ff	 cmp	 eax, -1
  04dfc	88 15 12 00 00
	00		 mov	 BYTE PTR _errMsg+18, dl
  04e02	75 0a		 jne	 SHORT $L59040

; 1357 : 				filename = rq->urlname;

  04e04	81 c1 90 00 00
	00		 add	 ecx, 144		; 00000090H
  04e0a	89 4c 24 30	 mov	 DWORD PTR _filename$59018[esp+304], ecx
$L59040:

; 1358 : 			}
; 1359 : 			strcat(errMsg, filename);

  04e0e	8b 7c 24 30	 mov	 edi, DWORD PTR _filename$59018[esp+304]
  04e12	83 c9 ff	 or	 ecx, -1
  04e15	33 c0		 xor	 eax, eax

; 1360 : 			strcat(errMsg, "\n");
; 1361 : 			error(errMsg);

  04e17	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  04e1c	f2 ae		 repne scasb
  04e1e	f7 d1		 not	 ecx
  04e20	2b f9		 sub	 edi, ecx
  04e22	8b f7		 mov	 esi, edi
  04e24	8b d1		 mov	 edx, ecx
  04e26	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  04e2b	83 c9 ff	 or	 ecx, -1
  04e2e	f2 ae		 repne scasb
  04e30	8b ca		 mov	 ecx, edx
  04e32	4f		 dec	 edi
  04e33	c1 e9 02	 shr	 ecx, 2
  04e36	f3 a5		 rep movsd
  04e38	8b ca		 mov	 ecx, edx
  04e3a	83 e1 03	 and	 ecx, 3
  04e3d	f3 a4		 rep movsb
  04e3f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  04e44	83 c9 ff	 or	 ecx, -1
  04e47	f2 ae		 repne scasb
  04e49	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG59041
  04e4f	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  04e53	e8 00 00 00 00	 call	 _error

; 1362 : 			sp += 2; tos = 0;
; 1363 : 			free(rq);

  04e58	8b 4c 24 30	 mov	 ecx, DWORD PTR _rq$59021[esp+308]
  04e5c	83 c3 08	 add	 ebx, 8
  04e5f	51		 push	 ecx
  04e60	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+312], 0
  04e68	e8 00 00 00 00	 call	 _free
  04e6d	83 c4 08	 add	 esp, 8

; 1364 : 			next;

  04e70	e9 e9 b1 ff ff	 jmp	 $L61881
$L59037:

; 1365 : 		}
; 1366 : 		if (rq->status == -1) {		/* Request pending */

  04e75	83 f8 ff	 cmp	 eax, -1
  04e78	75 3a		 jne	 SHORT $L59042

; 1367 : 			push(rq);

  04e7a	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04e7e	83 eb 04	 sub	 ebx, 4

; 1368 : 			push((cell)-1);

  04e81	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 1369 : 			--ip;

  04e85	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  04e88	89 13		 mov	 DWORD PTR [ebx], edx
  04e8a	83 eb 04	 sub	 ebx, 4
  04e8d	83 e8 04	 sub	 eax, 4
  04e90	89 0b		 mov	 DWORD PTR [ebx], ecx
  04e92	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 1370 : 			if (*ip == EXECUTE) {

  04e95	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  04e98	0f 85 95 23 00
	00		 jne	 $pause$58247

; 1371 : 				push(NEWVISIBLE);

  04e9e	83 eb 04	 sub	 ebx, 4
  04ea1	c7 44 24 0c 0c
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 268 ; 0000010cH
  04ea9	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 1372 : 			}
; 1373 : 			goto pause;

  04eaf	e9 7f 23 00 00	 jmp	 $pause$58247
$L59042:

; 1374 : 		}
; 1375 : 	}
; 1376 : 	case NEWAUDIBLE:
; 1377 : 		error("NewAudible: Unimplemented Meme operation\n"); next;

  04eb4	68 00 00 00 00	 push	 OFFSET FLAT:$SG59049
  04eb9	e8 00 00 00 00	 call	 _error
  04ebe	83 c4 04	 add	 esp, 4
  04ec1	e9 a0 b1 ff ff	 jmp	 $L58091
$L59050:

; 1378 : 	/* ( parent linktype -- objaddr ) */
; 1379 : 	case NEWIMAGINARY: {
; 1380 : 		Object *obj, *parent;
; 1381 : 		cell linktype;
; 1382 : 		linktype = pop; parent = (Object *)pop;

  04ec6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04ec8	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04ecc	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  04ecf	83 c3 04	 add	 ebx, 4

; 1383 : 		obj = NewImaginaryObject(parent, linktype);

  04ed2	50		 push	 eax
  04ed3	51		 push	 ecx
  04ed4	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  04ed8	e8 00 00 00 00	 call	 _NewImaginaryObject

; 1384 : 		push(obj); next;

  04edd	8b 4c 24 14	 mov	 ecx, DWORD PTR _tos$[esp+312]
  04ee1	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  04ee4	89 0b		 mov	 DWORD PTR [ebx], ecx
  04ee6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04eea	e9 77 b1 ff ff	 jmp	 $L58091
$L59056:

; 1385 : 	}
; 1386 : 	case CURRCAMERA:
; 1387 : 		ascr = apop;

  04eef	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04ef3	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1388 : 		MemeCurrentCamera((Object *)ascr);

  04ef5	50		 push	 eax
  04ef6	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  04efa	83 c3 04	 add	 ebx, 4
  04efd	e8 00 00 00 00	 call	 _MemeCurrentCamera
  04f02	83 c4 04	 add	 esp, 4

; 1389 : 		next;

  04f05	e9 5c b1 ff ff	 jmp	 $L58091
$L59059:

; 1390 : 	case MOUSEX: push(MemeMouseX()); next;

  04f0a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04f0e	83 eb 04	 sub	 ebx, 4
  04f11	89 03		 mov	 DWORD PTR [ebx], eax
  04f13	e8 00 00 00 00	 call	 _MemeMouseX

; 2298 : 				push(scr);

  04f18	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04f1c	e9 45 b1 ff ff	 jmp	 $L58091
$L59061:

; 1391 : 	case MOUSEY: push(MemeMouseY()); next;

  04f21	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  04f25	83 eb 04	 sub	 ebx, 4
  04f28	89 0b		 mov	 DWORD PTR [ebx], ecx
  04f2a	e8 00 00 00 00	 call	 _MemeMouseY

; 2298 : 				push(scr);

  04f2f	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04f33	e9 2e b1 ff ff	 jmp	 $L58091
$L59063:

; 1392 : 	case MOUSEB: push(MemeMouseB()); next;

  04f38	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  04f3c	83 eb 04	 sub	 ebx, 4
  04f3f	89 13		 mov	 DWORD PTR [ebx], edx
  04f41	e8 00 00 00 00	 call	 _MemeMouseB

; 2298 : 				push(scr);

  04f46	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  04f4a	e9 17 b1 ff ff	 jmp	 $L58091
$L59065:

; 1393 : 			/* objaddr destnodeaddr resultaddr -- err */
; 1394 : 			case TRANSFORM: {
; 1395 : 				Object *objp;
; 1396 : 				objp = (Object *)apop;

  04f4f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  04f51	83 c3 04	 add	 ebx, 4

; 1397 : 				ascr1 = apop;

  04f54	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx
  04f58	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04f5c	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1398 : 				ascr = apop;

  04f5e	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  04f61	83 c3 04	 add	 ebx, 4

; 1399 : 				SAVE_XCONTEXT;

  04f64	83 ee 08	 sub	 esi, 8

; 1400 : 				scr = Transform((Object *)ascr, (Object *)ascr1, objp);

  04f67	50		 push	 eax
  04f68	89 13		 mov	 DWORD PTR [ebx], edx
  04f6a	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  04f6e	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  04f74	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  04f78	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  04f7e	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  04f82	89 16		 mov	 DWORD PTR [esi], edx
  04f84	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  04f88	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  04f8b	8b 44 24 40	 mov	 eax, DWORD PTR _ascr1$[esp+308]
  04f8f	50		 push	 eax
  04f90	51		 push	 ecx
  04f91	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  04f97	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  04f9d	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  04fa3	e8 00 00 00 00	 call	 _Transform

; 1401 : 				RESTORE_XCONTEXT;
; 1402 : 				push(scr);
; 1403 : 			} next;

  04fa8	e9 6a 1b 00 00	 jmp	 $L61963
$L59074:

; 1404 : 			/* [float] -- 0.0 */
; 1405 : 			case FZERO:
; 1406 : 				flpush(0.0); next;

  04fad	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  04fb1	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  04fb5	83 ee 08	 sub	 esi, 8
  04fb8	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _ftos$[esp+304], 0
  04fc0	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  04fc4	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _ftos$[esp+308], 0
  04fcc	89 06		 mov	 DWORD PTR [esi], eax
  04fce	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  04fd1	e9 90 b0 ff ff	 jmp	 $L58091
$L59075:

; 1407 : 	case SETCAMERABACKCOLOR: {
; 1408 : 		Object	*obj;
; 1409 : 		double r, g, b;
; 1410 : 		b = flpop; g = flpop; r = flpop;

  04fd6	dd 06		 fld	 QWORD PTR [esi]
  04fd8	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  04fdc	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  04fe0	dd 5c 24 40	 fstp	 QWORD PTR _g$59078[esp+304]
  04fe4	dd 46 08	 fld	 QWORD PTR [esi+8]
  04fe7	83 c6 08	 add	 esi, 8
  04fea	89 94 24 98 00
	00 00		 mov	 DWORD PTR _b$59079[esp+304], edx
  04ff1	83 c6 08	 add	 esi, 8
  04ff4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _b$59079[esp+308], eax

; 1411 : 		obj = (Object *)pop;

  04ffb	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  04fff	83 c3 04	 add	 ebx, 4
  05002	8b 0e		 mov	 ecx, DWORD PTR [esi]
  05004	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  05007	dd 5c 24 50	 fstp	 QWORD PTR _r$59077[esp+304]
  0500b	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  0500f	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  05012	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 1412 : 		MemeSetCameraBackColor(obj, r, g, b);

  05016	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR _b$59079[esp+308]
  0501d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05021	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR _b$59079[esp+304]
  05028	52		 push	 edx
  05029	8b 54 24 48	 mov	 edx, DWORD PTR _g$59078[esp+312]
  0502d	51		 push	 ecx
  0502e	8b 4c 24 48	 mov	 ecx, DWORD PTR _g$59078[esp+312]
  05032	52		 push	 edx
  05033	8b 54 24 60	 mov	 edx, DWORD PTR _r$59077[esp+320]
  05037	51		 push	 ecx
  05038	8b 4c 24 60	 mov	 ecx, DWORD PTR _r$59077[esp+320]
  0503c	52		 push	 edx
  0503d	83 c6 08	 add	 esi, 8
  05040	51		 push	 ecx
  05041	50		 push	 eax
  05042	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  05046	e8 00 00 00 00	 call	 _MemeSetCameraBackColor
  0504b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1413 : 	} next;

  0504e	e9 13 b0 ff ff	 jmp	 $L58091
$L59081:

; 1414 : 	case SETCAMERAVIEWWINDOW: {
; 1415 : 		Object *obj;
; 1416 : 		double w, h;
; 1417 : 		h = flpop; w = flpop; obj = (Object *)pop;

  05053	dd 06		 fld	 QWORD PTR [esi]
  05055	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  05059	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0505c	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  05060	83 c6 08	 add	 esi, 8
  05063	dd 5c 24 40	 fstp	 QWORD PTR _w$59083[esp+304]
  05067	89 94 24 c8 00
	00 00		 mov	 DWORD PTR _h$59084[esp+304], edx
  0506e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  05071	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  05075	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05077	89 84 24 cc 00
	00 00		 mov	 DWORD PTR _h$59084[esp+308], eax
  0507e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05082	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 1418 : 		MemeSetCameraViewWindow(obj, w, h);

  05086	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR _h$59084[esp+308]
  0508d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05091	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR _h$59084[esp+304]
  05098	52		 push	 edx
  05099	8b 54 24 48	 mov	 edx, DWORD PTR _w$59083[esp+312]
  0509d	51		 push	 ecx
  0509e	8b 4c 24 48	 mov	 ecx, DWORD PTR _w$59083[esp+312]
  050a2	52		 push	 edx
  050a3	83 c6 08	 add	 esi, 8
  050a6	51		 push	 ecx
  050a7	50		 push	 eax
  050a8	89 74 24 38	 mov	 DWORD PTR _fsp$[esp+324], esi
  050ac	83 c3 04	 add	 ebx, 4
  050af	e8 00 00 00 00	 call	 _MemeSetCameraViewWindow
  050b4	83 c4 14	 add	 esp, 20			; 00000014H

; 1419 : 	} next;

  050b7	e9 aa af ff ff	 jmp	 $L58091
$L59086:

; 1420 : 	case GETTIME: {
; 1421 : 		struct timeb t;
; 1422 : 		ftime(&t);

  050bc	8d 94 24 24 01
	00 00		 lea	 edx, DWORD PTR _t$59087[esp+304]
  050c3	52		 push	 edx
  050c4	e8 00 00 00 00	 call	 _ftime

; 1423 : 		push((cell) t.time);

  050c9	8b 44 24 10	 mov	 eax, DWORD PTR _tos$[esp+308]
  050cd	83 eb 04	 sub	 ebx, 4
  050d0	83 c4 04	 add	 esp, 4
  050d3	89 03		 mov	 DWORD PTR [ebx], eax

; 1424 : 		push((cell) t.millitm);

  050d5	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR _t$59087[esp+304]
  050dc	83 eb 04	 sub	 ebx, 4
  050df	89 0b		 mov	 DWORD PTR [ebx], ecx
  050e1	8b 94 24 28 01
	00 00		 mov	 edx, DWORD PTR _t$59087[esp+308]
  050e8	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  050ee	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 1425 : 	} next;

  050f2	e9 6f af ff ff	 jmp	 $L58091
$L59092:

; 1426 : 
; 1427 : 	case ORPHAN:
; 1428 : 		ascr =  apop;

  050f7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  050fb	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1429 : 		scr = Orphan((Object *)ascr);

  050fd	50		 push	 eax
  050fe	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  05102	83 c3 04	 add	 ebx, 4
  05105	e8 00 00 00 00	 call	 _Orphan
  0510a	83 c4 04	 add	 esp, 4

; 1430 : 		if (scr) {	V_ERRNO = scr;	push(-1);	next;	} else {	push(0);	next;	}

  0510d	85 c0		 test	 eax, eax
  0510f	0f 84 ef 16 00
	00		 je	 $L59095
  05115	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  05119	83 eb 04	 sub	 ebx, 4
  0511c	89 47 4c	 mov	 DWORD PTR [edi+76], eax
  0511f	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  05127	89 13		 mov	 DWORD PTR [ebx], edx
  05129	e9 38 af ff ff	 jmp	 $L58091
$L59099:

; 1431 : 		next;
; 1432 : 
; 1433 : 	case ADOPTS:
; 1434 : 		ascr = apop; /* child */ ascr1 = apop; /* parent */

  0512e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05130	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05134	83 c3 04	 add	 ebx, 4
  05137	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx

; 1435 : 		scr = Adopts((Object *)ascr1, (Object *)ascr);

  0513b	50		 push	 eax
  0513c	51		 push	 ecx
  0513d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0513f	83 c3 04	 add	 ebx, 4
  05142	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05146	e8 00 00 00 00	 call	 _Adopts
  0514b	83 c4 08	 add	 esp, 8

; 1436 : 		if (scr) { V_ERRNO = scr;	push(-1);	next;	} else {	push(0); 	next;	}  

  0514e	85 c0		 test	 eax, eax
  05150	0f 84 9a 1d 00
	00		 je	 $L59104
  05156	89 47 4c	 mov	 DWORD PTR [edi+76], eax
$L59131:
  05159	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0515d	83 eb 04	 sub	 ebx, 4
  05160	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  05168	89 03		 mov	 DWORD PTR [ebx], eax
  0516a	e9 f7 ae ff ff	 jmp	 $L58091
$L59106:

; 1437 : 
; 1438 : 	case SCRHEIGHT: push(MemeScreenHeight()); next;

  0516f	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  05173	83 eb 04	 sub	 ebx, 4
  05176	89 13		 mov	 DWORD PTR [ebx], edx
  05178	e8 00 00 00 00	 call	 _MemeScreenHeight

; 2298 : 				push(scr);

  0517d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05181	e9 e0 ae ff ff	 jmp	 $L58091
$L59110:

; 1439 : 	case SCRWIDTH: push(MemeScreenWidth()); next;

  05186	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0518a	83 eb 04	 sub	 ebx, 4
  0518d	89 03		 mov	 DWORD PTR [ebx], eax
  0518f	e8 00 00 00 00	 call	 _MemeScreenWidth

; 2298 : 				push(scr);

  05194	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05198	e9 c9 ae ff ff	 jmp	 $L58091
$L59112:

; 1440 : 	case MATERIALOPACITY: {
; 1441 : 		double opacity;
; 1442 : 		ascr = apop;

  0519d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0519f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1443 : 		opacity = flpop;

  051a3	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  051a7	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  051ab	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  051af	89 94 24 a8 00
	00 00		 mov	 DWORD PTR _opacity$59113[esp+304], edx
  051b6	8b 16		 mov	 edx, DWORD PTR [esi]
  051b8	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR _opacity$59113[esp+308], ecx
  051bf	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  051c2	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx

; 1444 : 		MatOpacity(ascr, opacity);

  051c6	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR _opacity$59113[esp+308]
  051cd	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  051d1	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _opacity$59113[esp+304]
  051d8	52		 push	 edx
  051d9	83 c6 08	 add	 esi, 8
  051dc	51		 push	 ecx
  051dd	50		 push	 eax
  051de	83 c3 04	 add	 ebx, 4
  051e1	89 74 24 30	 mov	 DWORD PTR _fsp$[esp+316], esi
  051e5	e8 00 00 00 00	 call	 _MatOpacity
  051ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1445 : 	} next;

  051ed	e9 74 ae ff ff	 jmp	 $L58091
$L59115:

; 1446 : 	case JOYSTICKX: push(MemeJoystickX()); next;

  051f2	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  051f6	83 eb 04	 sub	 ebx, 4
  051f9	89 13		 mov	 DWORD PTR [ebx], edx
  051fb	e8 00 00 00 00	 call	 _MemeJoystickX

; 2298 : 				push(scr);

  05200	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05204	e9 5d ae ff ff	 jmp	 $L58091
$L59117:

; 1447 : 	case JOYSTICKY: push(MemeJoystickY()); next;

  05209	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0520d	83 eb 04	 sub	 ebx, 4
  05210	89 03		 mov	 DWORD PTR [ebx], eax
  05212	e8 00 00 00 00	 call	 _MemeJoystickY

; 2298 : 				push(scr);

  05217	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0521b	e9 46 ae ff ff	 jmp	 $L58091
$L59119:

; 1448 : 	case JOYSTICKB: push(MemeJoystickB()); next;

  05220	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  05224	83 eb 04	 sub	 ebx, 4
  05227	89 0b		 mov	 DWORD PTR [ebx], ecx
  05229	e8 00 00 00 00	 call	 _MemeJoystickB

; 2298 : 				push(scr);

  0522e	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05232	e9 2f ae ff ff	 jmp	 $L58091
$L59121:

; 1449 : 	case DESTROYOBJECT: ascr = apop; DestroyObject((Object *)ascr); next;

  05237	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0523b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0523d	50		 push	 eax
  0523e	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  05242	83 c3 04	 add	 ebx, 4
  05245	e8 00 00 00 00	 call	 _DestroyObject
  0524a	83 c4 04	 add	 esp, 4
  0524d	e9 14 ae ff ff	 jmp	 $L58091
$L59124:

; 1450 : 
; 1451 : 	    /* Return the vertex, polygon, and clump that are pointed
; 1452 : 	     * to by screenx and screeny.  If clump = 0
; 1453 : 	     * then nothing was found.
; 1454 : 	     * If nothing found:
; 1455 : 	     * ( screenx screeny pickrecordptr -- 0 )
; 1456 : 	     * If a vertex was found:
; 1457 : 	     * ( screenx screeny pickrecordptr -- -1 )
; 1458 : 	     */
; 1459 : 	case PICKOBJECT: {
; 1460 : 		cell x, y;
; 1461 : 		MemePickRecord *mrecp = (MemePickRecord *)apop;

  05252	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1462 : 		y = pop;

  05256	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  05259	89 44 24 38	 mov	 DWORD PTR _mrecp$59127[esp+304], eax
  0525d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0525f	83 c3 04	 add	 ebx, 4

; 1463 : 		x = pop;
; 1464 : 		MemePickObject(mrecp, x, y);

  05262	50		 push	 eax
  05263	8b 44 24 3c	 mov	 eax, DWORD PTR _mrecp$59127[esp+308]
  05267	83 c3 04	 add	 ebx, 4
  0526a	51		 push	 ecx
  0526b	50		 push	 eax
  0526c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0526e	83 c3 04	 add	 ebx, 4
  05271	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  05275	e8 00 00 00 00	 call	 _MemePickObject

; 1465 : 		if (mrecp->clump == (void *)0) {

  0527a	8b 4c 24 44	 mov	 ecx, DWORD PTR _mrecp$59127[esp+316]
  0527e	83 c4 0c	 add	 esp, 12			; 0000000cH
  05281	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  05284	85 c0		 test	 eax, eax
  05286	0f 85 cd fe ff
	ff		 jne	 $L59131

; 1466 : 			push(0);

  0528c	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  05290	83 eb 04	 sub	 ebx, 4
  05293	89 13		 mov	 DWORD PTR [ebx], edx
$L58621:
  05295	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0

; 1467 : 		} else {

  0529d	e9 c4 ad ff ff	 jmp	 $L58091
$L59135:

; 1468 : 			push(-1);
; 1469 : 		}
; 1470 : 	} next;
; 1471 : 
; 1472 : 	/* Set the vertex whose object address and vertex index
; 1473 : 	 * are given, to the xyz triplet on the float stack.
; 1474 : 	 * ( vindex objaddr -- )
; 1475 : 	 * ( [float] x y z -- )
; 1476 : 	 */
; 1477 : 	case SETVERTEX: {
; 1478 : 	    Object *obj;
; 1479 : 	    cell vindex;
; 1480 : 		double x, y, z;
; 1481 : 	    obj = (Object *) apop; vindex = pop;
; 1482 : 	    z = flpop; y = flpop; x = flpop;

  052a2	dd 06		 fld	 QWORD PTR [esi]
  052a4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  052a6	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  052aa	dd 5c 24 50	 fstp	 QWORD PTR _y$59139[esp+304]
  052ae	dd 46 08	 fld	 QWORD PTR [esi+8]
  052b1	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  052b5	83 c3 04	 add	 ebx, 4
  052b8	83 c6 08	 add	 esi, 8
  052bb	89 4c 24 40	 mov	 DWORD PTR _vindex$59137[esp+304], ecx
  052bf	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  052c1	83 c6 08	 add	 esi, 8
  052c4	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  052c8	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  052cc	89 94 24 d8 00
	00 00		 mov	 DWORD PTR _z$59140[esp+304], edx
  052d3	8b 16		 mov	 edx, DWORD PTR [esi]
  052d5	dd 5c 24 70	 fstp	 QWORD PTR _x$59138[esp+304]
  052d9	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR _z$59140[esp+308], ecx
  052e0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  052e3	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx

; 1483 : 	    MemeSetVertex(obj, vindex, x, y, z);

  052e7	8b 94 24 dc 00
	00 00		 mov	 edx, DWORD PTR _z$59140[esp+308]
  052ee	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  052f2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR _z$59140[esp+304]
  052f9	52		 push	 edx
  052fa	8b 54 24 58	 mov	 edx, DWORD PTR _y$59139[esp+312]
  052fe	51		 push	 ecx
  052ff	8b 4c 24 58	 mov	 ecx, DWORD PTR _y$59139[esp+312]
  05303	52		 push	 edx
  05304	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR _x$59138[esp+320]
  0530b	51		 push	 ecx
  0530c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR _x$59138[esp+320]
  05313	52		 push	 edx
  05314	8b 54 24 54	 mov	 edx, DWORD PTR _vindex$59137[esp+324]
  05318	51		 push	 ecx
  05319	83 c6 08	 add	 esi, 8
  0531c	52		 push	 edx
  0531d	50		 push	 eax
  0531e	83 c3 04	 add	 ebx, 4
  05321	89 74 24 44	 mov	 DWORD PTR _fsp$[esp+336], esi
  05325	e8 00 00 00 00	 call	 _MemeSetVertex
  0532a	83 c4 20	 add	 esp, 32			; 00000020H

; 1484 : 	} next ;

  0532d	e9 34 ad ff ff	 jmp	 $L58091
$L59143:

; 1485 : 	/* Get the number of polygons in the visible object.
; 1486 : 	 * ( objaddr -- #polys )
; 1487 : 	 */
; 1488 : 	 case POLYGONCOUNT:
; 1489 : 		ascr = apop; push( MemePolygonCount((Object *)ascr) ); next; 

  05332	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05336	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05338	50		 push	 eax
  05339	89 0b		 mov	 DWORD PTR [ebx], ecx
  0533b	e8 00 00 00 00	 call	 _MemePolygonCount
  05340	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  05343	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05347	e9 1a ad ff ff	 jmp	 $L58091
$L59147:

; 1490 : 	
; 1491 : 	 /* Create a texture for mapping onto a polygon or clump
; 1492 : 	  * ( filenameaddr -- textureptr )
; 1493 : 	  */
; 1494 : 		case NEWTEXTURE: {
; 1495 : 			cell tp;
; 1496 : 			char *filename;
; 1497 : 			RFRequest *rq;
; 1498 : 
; 1499 : 			filename = (char *)apop;

  0534c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  05350	8b 03		 mov	 eax, DWORD PTR [ebx]
  05352	83 c3 04	 add	 ebx, 4

; 1500 : 			if (filename != (char *)-1) {	/* First time, try to open URL */

  05355	83 f9 ff	 cmp	 ecx, -1
  05358	89 4c 24 30	 mov	 DWORD PTR _filename$59149[esp+304], ecx
  0535c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  05360	74 41		 je	 SHORT $L59154

; 1501 : 				rq = malloc(sizeof(RFRequest));

  05362	68 10 01 00 00	 push	 272			; 00000110H
  05367	e8 00 00 00 00	 call	 _malloc
  0536c	83 c4 04	 add	 esp, 4
  0536f	89 44 24 2c	 mov	 DWORD PTR _rq$59150[esp+304], eax

; 1502 : 				if (!rq) {

  05373	85 c0		 test	 eax, eax
  05375	75 16		 jne	 SHORT $L59156

; 1503 : 					push(0);

  05377	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0537b	83 eb 04	 sub	 ebx, 4

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  0537e	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  05386	89 03		 mov	 DWORD PTR [ebx], eax

; 2022 : 				next;

  05388	e9 d9 ac ff ff	 jmp	 $L58091
$L59156:

; 1504 : 					next;
; 1505 : 				}
; 1506 : 				OpenURL(filename, rq, rfrqFILE);

  0538d	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59150[esp+304]
  05391	8b 54 24 30	 mov	 edx, DWORD PTR _filename$59149[esp+304]
  05395	6a 00		 push	 0
  05397	51		 push	 ecx
  05398	52		 push	 edx
  05399	e8 00 00 00 00	 call	 _OpenURL
  0539e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1507 : 			} else {						/* We're idling */

  053a1	eb 16		 jmp	 SHORT $L59158
$L59154:

; 1508 : 				rq = (RFRequest *)pop;

  053a3	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1509 : 				WaitURL(rq);

  053a5	50		 push	 eax
  053a6	89 44 24 30	 mov	 DWORD PTR _rq$59150[esp+308], eax
  053aa	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  053ae	83 c3 04	 add	 ebx, 4
  053b1	e8 00 00 00 00	 call	 _WaitURL
  053b6	83 c4 04	 add	 esp, 4
$L59158:

; 1510 : 			}
; 1511 : 			if (rq->status == 0) {		/* File opened */

  053b9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59150[esp+304]
  053bd	8b 01		 mov	 eax, DWORD PTR [ecx]
  053bf	85 c0		 test	 eax, eax
  053c1	0f 85 a2 00 00
	00		 jne	 $L59160

; 1512 : 				filename = rq->tmpname;

  053c7	8b d1		 mov	 edx, ecx

; 1513 : 				SAVE_XCONTEXT

  053c9	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  053cd	83 eb 04	 sub	 ebx, 4
  053d0	83 ee 08	 sub	 esi, 8
  053d3	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  053d6	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  053da	89 0b		 mov	 DWORD PTR [ebx], ecx
  053dc	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  053e0	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  053e6	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  053ec	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  053f0	89 0e		 mov	 DWORD PTR [esi], ecx
  053f2	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  053f6	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1514 : 				tp = MemeNewTexture(filename);

  053f9	50		 push	 eax
  053fa	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05400	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05406	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  0540c	e8 00 00 00 00	 call	 _MemeNewTexture

; 1515 : #ifdef REMOVE
; 1516 : 				/* Don't remove temporary files anymore, because of caching */
; 1517 : 				ascr = strrchr(filename, '.');
; 1518 : 				if (ascr && !strcmp(ascr, ".tmp")) unlink(filename);
; 1519 : #endif
; 1520 : 				RESTORE_XCONTEXT

  05411	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  05417	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  0541d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  05423	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  05429	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0542b	89 54 24 24	 mov	 DWORD PTR _frp$[esp+308], edx
  0542f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  05432	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  05436	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  0543c	89 54 24 18	 mov	 DWORD PTR _ftos$[esp+312], edx

; 1521 : 				push(tp);
; 1522 : 				free(rq);

  05440	8b 54 24 30	 mov	 edx, DWORD PTR _rq$59150[esp+308]
  05444	89 4c 24 20	 mov	 DWORD PTR _rp$[esp+308], ecx
  05448	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0544a	83 c6 08	 add	 esi, 8
  0544d	52		 push	 edx
  0544e	89 7c 24 30	 mov	 DWORD PTR _up$[esp+312], edi
  05452	89 74 24 2c	 mov	 DWORD PTR _fsp$[esp+312], esi
  05456	89 0b		 mov	 DWORD PTR [ebx], ecx
  05458	89 44 24 14	 mov	 DWORD PTR _tos$[esp+312], eax

; 2416 : 							free(rq);

  0545c	e8 00 00 00 00	 call	 _free
  05461	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  05464	e9 fd ab ff ff	 jmp	 $L58091
$L59160:

; 1523 : 				next;
; 1524 : 			}
; 1525 : 			if (rq->status == 1) {		/* Request failed */

  05469	83 f8 01	 cmp	 eax, 1
  0546c	0f 85 94 00 00
	00		 jne	 $L59162

; 1526 : 				strcpy(errMsg, "Couldn't read texture file ");
; 1527 : 				if (filename == (char *)-1) {

  05472	8b 44 24 30	 mov	 eax, DWORD PTR _filename$59149[esp+304]
  05476	b9 07 00 00 00	 mov	 ecx, 7
  0547b	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG59163
  05480	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  05485	83 f8 ff	 cmp	 eax, -1
  05488	f3 a5		 rep movsd
  0548a	75 0d		 jne	 SHORT $L59165

; 1528 : 					filename = rq->urlname;

  0548c	8b 44 24 2c	 mov	 eax, DWORD PTR _rq$59150[esp+304]
  05490	05 90 00 00 00	 add	 eax, 144		; 00000090H
  05495	89 44 24 30	 mov	 DWORD PTR _filename$59149[esp+304], eax
$L59165:

; 1529 : 				}
; 1530 : 				strcat(errMsg, filename);

  05499	8b 7c 24 30	 mov	 edi, DWORD PTR _filename$59149[esp+304]
  0549d	83 c9 ff	 or	 ecx, -1
  054a0	33 c0		 xor	 eax, eax

; 1531 : 				strcat(errMsg, "\n");
; 1532 : 				error(errMsg);

  054a2	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  054a7	f2 ae		 repne scasb
  054a9	f7 d1		 not	 ecx
  054ab	2b f9		 sub	 edi, ecx
  054ad	8b f7		 mov	 esi, edi
  054af	8b d1		 mov	 edx, ecx
  054b1	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  054b6	83 c9 ff	 or	 ecx, -1
  054b9	f2 ae		 repne scasb
  054bb	8b ca		 mov	 ecx, edx
  054bd	4f		 dec	 edi
  054be	c1 e9 02	 shr	 ecx, 2
  054c1	f3 a5		 rep movsd
  054c3	8b ca		 mov	 ecx, edx
  054c5	83 e1 03	 and	 ecx, 3
  054c8	f3 a4		 rep movsb
  054ca	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  054cf	83 c9 ff	 or	 ecx, -1
  054d2	f2 ae		 repne scasb
  054d4	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG59166
  054da	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  054de	e8 00 00 00 00	 call	 _error

; 1533 : 				push(0);
; 1534 : 				free(rq);

  054e3	8b 54 24 30	 mov	 edx, DWORD PTR _rq$59150[esp+308]
  054e7	8b 4c 24 10	 mov	 ecx, DWORD PTR _tos$[esp+308]
  054eb	83 eb 04	 sub	 ebx, 4
  054ee	52		 push	 edx
  054ef	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+312], 0
  054f7	89 0b		 mov	 DWORD PTR [ebx], ecx
  054f9	e8 00 00 00 00	 call	 _free
  054fe	83 c4 08	 add	 esp, 8

; 1535 : 				next;

  05501	e9 58 ab ff ff	 jmp	 $L61881
$L59162:

; 1536 : 			}
; 1537 : 			if (rq->status == -1) {		/* Request pending */

  05506	83 f8 ff	 cmp	 eax, -1
  05509	0f 85 e1 19 00
	00		 jne	 $L59104

; 1538 : 				push(rq);

  0550f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05513	83 eb 04	 sub	 ebx, 4

; 1539 : 				push((cell)-1);

  05516	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  0551e	89 03		 mov	 DWORD PTR [ebx], eax

; 1540 : 				--ip;

  05520	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  05523	83 eb 04	 sub	 ebx, 4
  05526	83 e8 04	 sub	 eax, 4
  05529	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  0552c	89 0b		 mov	 DWORD PTR [ebx], ecx

; 1541 : 				if (*ip == EXECUTE) {

  0552e	8b 08		 mov	 ecx, DWORD PTR [eax]
  05530	83 f9 34	 cmp	 ecx, 52			; 00000034H
  05533	0f 85 fa 1c 00
	00		 jne	 $pause$58247

; 1542 : 					push(NEWTEXTURE);
; 1543 : 				}
; 1544 : 				goto pause;

  05539	e9 e4 1c 00 00	 jmp	 $L61974
$L59176:

; 1545 : 			}
; 1546 : 		}
; 1547 : 
; 1548 : 		/* -- 0 */
; 1549 : 		case PUSH_FALSE:	push(0); next;
; 1550 : 
; 1551 : 	    /* Set the frame step for the texture frames
; 1552 : 	     * ( step textureptr -- )
; 1553 : 	     */
; 1554 : 	    case TEXTUREFRAMESTEP:
; 1555 : 		ascr = apop;

  0553e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05540	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1556 : 		scr = pop;

  05544	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05547	83 c3 04	 add	 ebx, 4

; 1557 : 		MemeTextureFrameStep(ascr, scr);

  0554a	51		 push	 ecx
  0554b	50		 push	 eax
  0554c	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05550	83 c3 04	 add	 ebx, 4
  05553	e8 00 00 00 00	 call	 _MemeTextureFrameStep

; 2416 : 							free(rq);

  05558	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  0555b	e9 06 ab ff ff	 jmp	 $L58091
$L59178:

; 1558 : 		next;
; 1559 : 
; 1560 : 	    /* Move to the next frame in the texture
; 1561 : 	     * ( textureptr -- )
; 1562 : 	     */
; 1563 : 	    case TEXTURENEXTFRAME:
; 1564 : 		ascr = apop;

  05560	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05564	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1565 : 		MemeTextureNextFrame(ascr);

  05566	50		 push	 eax
  05567	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  0556b	83 c3 04	 add	 ebx, 4
  0556e	e8 00 00 00 00	 call	 _MemeTextureNextFrame
  05573	83 c4 04	 add	 esp, 4

; 1566 : 		next;

  05576	e9 eb aa ff ff	 jmp	 $L58091
$L59180:

; 1567 : 
; 1568 : 	    /* Set the texture frame #
; 1569 : 	     * ( frame# textureptr -- )
; 1570 : 	     */
; 1571 : 	    case SETTEXTUREFRAME:
; 1572 : 		ascr = apop;

  0557b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0557d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1573 : 		scr = pop;

  05581	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05584	83 c3 04	 add	 ebx, 4

; 1574 : 		MemeSetTextureFrame(ascr, scr);

  05587	51		 push	 ecx
  05588	50		 push	 eax
  05589	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  0558d	83 c3 04	 add	 ebx, 4
  05590	e8 00 00 00 00	 call	 _MemeSetTextureFrame

; 2416 : 							free(rq);

  05595	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  05598	e9 c9 aa ff ff	 jmp	 $L58091
$L59182:

; 1575 : 		next;
; 1576 : 
; 1577 : 	    /* Create a new material.
; 1578 : 	     * ( -- materialptr )
; 1579 : 	     */
; 1580 : 	    case NEWMATERIAL: push(NewMat()); next;

  0559d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  055a1	83 eb 04	 sub	 ebx, 4
  055a4	89 03		 mov	 DWORD PTR [ebx], eax
  055a6	e8 00 00 00 00	 call	 _NewMat

; 2298 : 				push(scr);

  055ab	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  055af	e9 b2 aa ff ff	 jmp	 $L58091
$L59184:

; 1581 : 
; 1582 : 	    /* Destroy a material.
; 1583 : 	     * ( materialptr -- )
; 1584 : 	     */
; 1585 : 	    case DESTROYMATERIAL:
; 1586 : 		ascr = apop;

  055b4	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  055b8	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1587 : 		DestroyMat(ascr);

  055ba	50		 push	 eax
  055bb	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  055bf	83 c3 04	 add	 ebx, 4
  055c2	e8 00 00 00 00	 call	 _DestroyMat
  055c7	83 c4 04	 add	 esp, 4

; 1588 : 		next;

  055ca	e9 97 aa ff ff	 jmp	 $L58091
$L59186:

; 1589 : 
; 1590 : 	    /* Set the material's color.
; 1591 : 	     * ( materialptr -- )
; 1592 : 	     * ( [float] Kr Kg Kb -- )
; 1593 : 	     */
; 1594 : 	    case MATERIALCOLOR: {
; 1595 : 		double r, g, b;
; 1596 : 		b = flpop;

  055cf	dd 06		 fld	 QWORD PTR [esi]
  055d1	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  055d5	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]

; 1597 : 		g = flpop;

  055d9	dd 5c 24 40	 fstp	 QWORD PTR _g$59188[esp+304]
  055dd	dd 46 08	 fld	 QWORD PTR [esi+8]
  055e0	83 c6 08	 add	 esi, 8
  055e3	89 94 24 b8 00
	00 00		 mov	 DWORD PTR _b$59189[esp+304], edx
  055ea	83 c6 08	 add	 esi, 8
  055ed	89 84 24 bc 00
	00 00		 mov	 DWORD PTR _b$59189[esp+308], eax

; 1598 : 		r = flpop;
; 1599 : 		ascr = apop;

  055f4	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  055f8	83 c3 04	 add	 ebx, 4
  055fb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  055fd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  05600	dd 5c 24 50	 fstp	 QWORD PTR _r$59187[esp+304]
  05604	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  05608	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  0560b	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 1600 : 		MatColor(ascr, r, g, b);

  0560f	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR _b$59189[esp+308]
  05616	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0561a	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR _b$59189[esp+304]
  05621	52		 push	 edx
  05622	8b 54 24 48	 mov	 edx, DWORD PTR _g$59188[esp+312]
  05626	51		 push	 ecx
  05627	8b 4c 24 48	 mov	 ecx, DWORD PTR _g$59188[esp+312]
  0562b	52		 push	 edx
  0562c	8b 54 24 60	 mov	 edx, DWORD PTR _r$59187[esp+320]
  05630	51		 push	 ecx
  05631	8b 4c 24 60	 mov	 ecx, DWORD PTR _r$59187[esp+320]
  05635	52		 push	 edx
  05636	83 c6 08	 add	 esi, 8
  05639	51		 push	 ecx
  0563a	50		 push	 eax
  0563b	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  0563f	e8 00 00 00 00	 call	 _MatColor
  05644	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1601 : 	    } next;

  05647	e9 1a aa ff ff	 jmp	 $L58091
$L59191:

; 1602 : 
; 1603 : 	    /* Set the material's surface
; 1604 : 	     * ( materialptr -- )
; 1605 : 	     * ( [float] Ka Kd Ks power -- )
; 1606 : 	     */
; 1607 : 	    case MATERIALSURFACE: {
; 1608 : 		double a, d, s, power;
; 1609 : 		power = flpop; s = flpop; d = flpop; a = flpop;

  0564c	dd 06		 fld	 QWORD PTR [esi]
  0564e	83 c6 08	 add	 esi, 8
  05651	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  05655	dd 5c 24 40	 fstp	 QWORD PTR _s$59194[esp+304]
  05659	dd 06		 fld	 QWORD PTR [esi]
  0565b	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  0565f	83 c6 08	 add	 esi, 8
  05662	dd 5c 24 50	 fstp	 QWORD PTR _d$59193[esp+304]
  05666	dd 06		 fld	 QWORD PTR [esi]
  05668	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0566b	83 c6 08	 add	 esi, 8
  0566e	89 94 24 e8 00
	00 00		 mov	 DWORD PTR _power$59195[esp+304], edx
  05675	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  05679	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 1610 : 		ascr = apop;

  0567c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0567e	89 84 24 ec 00
	00 00		 mov	 DWORD PTR _power$59195[esp+308], eax
  05685	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05689	dd 5c 24 70	 fstp	 QWORD PTR _a$59192[esp+304]
  0568d	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 1611 : 		MatSurface(ascr, a, d, s, power);

  05691	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR _power$59195[esp+308]
  05698	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0569c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR _power$59195[esp+304]
  056a3	52		 push	 edx
  056a4	8b 54 24 48	 mov	 edx, DWORD PTR _s$59194[esp+312]
  056a8	51		 push	 ecx
  056a9	8b 4c 24 48	 mov	 ecx, DWORD PTR _s$59194[esp+312]
  056ad	52		 push	 edx
  056ae	8b 54 24 60	 mov	 edx, DWORD PTR _d$59193[esp+320]
  056b2	51		 push	 ecx
  056b3	8b 4c 24 60	 mov	 ecx, DWORD PTR _d$59193[esp+320]
  056b7	52		 push	 edx
  056b8	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _a$59192[esp+328]
  056bf	51		 push	 ecx
  056c0	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR _a$59192[esp+328]
  056c7	52		 push	 edx
  056c8	83 c6 08	 add	 esi, 8
  056cb	51		 push	 ecx
  056cc	50		 push	 eax
  056cd	89 74 24 48	 mov	 DWORD PTR _fsp$[esp+340], esi
  056d1	83 c3 04	 add	 ebx, 4
  056d4	e8 00 00 00 00	 call	 _MatSurface
  056d9	83 c4 24	 add	 esp, 36			; 00000024H

; 1612 : 	    } next;

  056dc	e9 85 a9 ff ff	 jmp	 $L58091
$L59197:

; 1613 : 
; 1614 : 	    /* Set the material's shading.
; 1615 : 	     * ( shadingtype materialptr -- )
; 1616 : 	     */
; 1617 : 	    case MATERIALSHADING:
; 1618 : 		ascr = apop; scr = pop;

  056e1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  056e3	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  056e7	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  056ea	83 c3 04	 add	 ebx, 4

; 1619 : 		MatShading(ascr, scr);

  056ed	51		 push	 ecx
  056ee	50		 push	 eax
  056ef	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  056f3	83 c3 04	 add	 ebx, 4
  056f6	e8 00 00 00 00	 call	 _MatShading

; 2416 : 							free(rq);

  056fb	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  056fe	e9 63 a9 ff ff	 jmp	 $L58091
$L59199:

; 1620 : 		next;
; 1621 : 
; 1622 : 	    /* Set the material's geometry type.
; 1623 : 	     * ( geometrytype materialptr -- )
; 1624 : 	     */
; 1625 : 	    case MATERIALGEOMETRY:
; 1626 : 		ascr = apop; scr = pop;

  05703	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05705	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05709	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0570c	83 c3 04	 add	 ebx, 4

; 1627 : 		MatGeometry(ascr, scr);

  0570f	51		 push	 ecx
  05710	50		 push	 eax
  05711	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05715	83 c3 04	 add	 ebx, 4
  05718	e8 00 00 00 00	 call	 _MatGeometry

; 2416 : 							free(rq);

  0571d	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  05720	e9 41 a9 ff ff	 jmp	 $L58091
$L59201:

; 1628 : 		next;
; 1629 : 
; 1630 : 	    /* Set the material's texture.
; 1631 : 	     * ( textureptr materialptr -- )
; 1632 : 	     */
; 1633 : 	    case MATERIALTEXTURE:
; 1634 : 		ascr = apop; ascr1 = apop;

  05725	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05727	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0572b	83 c3 04	 add	 ebx, 4
  0572e	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx

; 1635 : 		MatTexture(ascr, ascr1);

  05732	51		 push	 ecx
  05733	50		 push	 eax
  05734	8b 13		 mov	 edx, DWORD PTR [ebx]
  05736	83 c3 04	 add	 ebx, 4
  05739	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  0573d	e8 00 00 00 00	 call	 _MatTexture

; 2416 : 							free(rq);

  05742	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  05745	e9 1c a9 ff ff	 jmp	 $L58091
$L59204:

; 1636 : 		next;
; 1637 : 
; 1638 : 	    /* Set a polygon's material.
; 1639 : 	     * ( materialptr polygonptr -- )
; 1640 : 	     */
; 1641 : 	    case POLYGONMATERIAL:
; 1642 : 		ascr = apop; ascr1 = apop;

  0574a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0574c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05750	83 c3 04	 add	 ebx, 4
  05753	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx

; 1643 : 		MemePolygonMaterial(ascr, (mMat *)ascr1);

  05757	51		 push	 ecx
  05758	50		 push	 eax
  05759	8b 13		 mov	 edx, DWORD PTR [ebx]
  0575b	83 c3 04	 add	 ebx, 4
  0575e	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05762	e8 00 00 00 00	 call	 _MemePolygonMaterial

; 2416 : 							free(rq);

  05767	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  0576a	e9 f7 a8 ff ff	 jmp	 $L58091
$L59208:

; 1644 : 		next;
; 1645 : 
; 1646 : 	    /* Set the shape's material.
; 1647 : 	     * ( materialptr objaddr -- )
; 1648 : 	     */
; 1649 : 	    case SHAPEMATERIAL:
; 1650 : 		ascr = apop; ascr1 = apop;

  0576f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05771	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05775	83 c3 04	 add	 ebx, 4
  05778	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx

; 1651 : 		MemeShapeMaterial(ascr, ascr1);

  0577c	51		 push	 ecx
  0577d	50		 push	 eax
  0577e	8b 13		 mov	 edx, DWORD PTR [ebx]
  05780	83 c3 04	 add	 ebx, 4
  05783	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05787	e8 00 00 00 00	 call	 _MemeShapeMaterial

; 2416 : 							free(rq);

  0578c	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  0578f	e9 d2 a8 ff ff	 jmp	 $L58091
$L59211:

; 1652 : 		next;
; 1653 : 
; 1654 : 	    /* Write the shape to a file.
; 1655 : 	     * ( objaddr filenameaddr filenamelen -- )
; 1656 : 	     */
; 1657 : 	    case WRITESHAPE:
; 1658 : 		scr = pop;	/* Discard the filenamelen */

  05794	8b 03		 mov	 eax, DWORD PTR [ebx]
  05796	83 c3 04	 add	 ebx, 4

; 1659 : 		ascr1 = apop;

  05799	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax

; 1660 : 		ascr = apop;
; 1661 : 		MemeWriteShape(ascr, ascr1);

  0579d	50		 push	 eax
  0579e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  057a0	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  057a3	83 c3 04	 add	 ebx, 4
  057a6	51		 push	 ecx
  057a7	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  057ab	83 c3 04	 add	 ebx, 4
  057ae	e8 00 00 00 00	 call	 _MemeWriteShape

; 2416 : 							free(rq);

  057b3	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  057b6	e9 ab a8 ff ff	 jmp	 $L58091
$L59214:

; 1662 : 		next;
; 1663 : 		/* hostid -- bool */
; 1664 : 		case ISMYHOSTID: scr = pop; SAVE_XCONTEXT

  057bb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  057bd	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  057c1	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  057c5	89 0b		 mov	 DWORD PTR [ebx], ecx
  057c7	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  057cb	83 ee 08	 sub	 esi, 8
  057ce	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  057d4	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  057da	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  057de	89 16		 mov	 DWORD PTR [esi], edx
  057e0	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  057e4	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1665 : 							scr = IsMyHostID(scr);

  057e7	50		 push	 eax
  057e8	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  057ee	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  057f4	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  057fa	e8 00 00 00 00	 call	 _IsMyHostID
  057ff	83 c4 04	 add	 esp, 4

; 1666 : 						RESTORE_XCONTEXT push(scr); next;

  05802	e9 13 13 00 00	 jmp	 $L61959
$L59216:

; 1667 : 		/* GETTIMEOFDAY accepts a pointer to storage, in
; 1668 : 		 * which it puts the time of day structure.
; 1669 : 		 */
; 1670 : 		/* addr -- */
; 1671 : 	    case GETTIMEOFDAY: {
; 1672 : 			time_t theTime;
; 1673 : 			ascr = apop;

  05807	8b 03		 mov	 eax, DWORD PTR [ebx]
  05809	8b 7c 24 0c	 mov	 edi, DWORD PTR _tos$[esp+304]

; 1674 : 			theTime = time(NULL);

  0580d	6a 00		 push	 0
  0580f	89 44 24 10	 mov	 DWORD PTR _tos$[esp+308], eax
  05813	83 c3 04	 add	 ebx, 4
  05816	e8 00 00 00 00	 call	 _time

; 1675 : 			memcpy(ascr, localtime(&theTime), sizeof(struct tm));

  0581b	8d 8c 24 c8 00
	00 00		 lea	 ecx, DWORD PTR _theTime$59217[esp+308]
  05822	89 84 24 c8 00
	00 00		 mov	 DWORD PTR _theTime$59217[esp+308], eax
  05829	51		 push	 ecx
  0582a	e8 00 00 00 00	 call	 _localtime
  0582f	b9 09 00 00 00	 mov	 ecx, 9
  05834	8b f0		 mov	 esi, eax
  05836	83 c4 08	 add	 esp, 8
  05839	f3 a5		 rep movsd

; 1676 : 		} next;

  0583b	e9 1e a8 ff ff	 jmp	 $L61881
$L59221:

; 1677 : 	    case DESTROYTEXTURE:
; 1678 : 			ascr = apop;

  05840	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05844	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1679 : 			MemeDestroyTexture(ascr);

  05846	50		 push	 eax
  05847	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  0584b	83 c3 04	 add	 ebx, 4
  0584e	e8 00 00 00 00	 call	 _MemeDestroyTexture
  05853	83 c4 04	 add	 esp, 4

; 1680 : 			next; 

  05856	e9 0b a8 ff ff	 jmp	 $L58091
$L59223:

; 1681 : 	    /* Get the number of vertices in a clump
; 1682 : 	     * ( objaddr -- num )
; 1683 : 	     */
; 1684 : 	    case GETVERTEXCOUNT:
; 1685 : 		ascr = apop;

  0585b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0585f	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1686 : 		push(MemeGetVertexCount((Object *)ascr));

  05861	50		 push	 eax
  05862	89 0b		 mov	 DWORD PTR [ebx], ecx
  05864	e8 00 00 00 00	 call	 _MemeGetVertexCount
  05869	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  0586c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05870	e9 f1 a7 ff ff	 jmp	 $L58091
$L59227:

; 1687 : 		next;
; 1688 : 
; 1689 : 	    /* Get a clump's vertex
; 1690 : 	     * ( index objaddr -- )
; 1691 : 	     * ( [float] -- x y z )
; 1692 : 	     */
; 1693 : 	    case GETVERTEX: {
; 1694 : 		double x, y, z;
; 1695 : 		ascr = apop;

  05875	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1696 : 		scr = pop;

  05877	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0587a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0587e	83 c3 04	 add	 ebx, 4
  05881	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 1697 : 		MemeGetVertex((Object *)ascr, scr, &x, &y, &z);

  05885	8d 94 24 f8 00
	00 00		 lea	 edx, DWORD PTR _z$59230[esp+304]
  0588c	52		 push	 edx
  0588d	8d 94 24 1c 01
	00 00		 lea	 edx, DWORD PTR _y$59229[esp+308]
  05894	52		 push	 edx
  05895	8d 94 24 18 01
	00 00		 lea	 edx, DWORD PTR _x$59228[esp+312]
  0589c	52		 push	 edx
  0589d	51		 push	 ecx
  0589e	50		 push	 eax
  0589f	83 c3 04	 add	 ebx, 4
  058a2	e8 00 00 00 00	 call	 _MemeGetVertex

; 1698 : 		flpush(x);

  058a7	8b 44 24 24	 mov	 eax, DWORD PTR _ftos$[esp+324]
  058ab	8b 4c 24 28	 mov	 ecx, DWORD PTR _ftos$[esp+328]
  058af	83 ee 08	 sub	 esi, 8
  058b2	83 c4 14	 add	 esp, 20			; 00000014H
  058b5	89 06		 mov	 DWORD PTR [esi], eax
  058b7	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1699 : 		flpush(y);

  058ba	dd 84 24 10 01
	00 00		 fld	 QWORD PTR _x$59228[esp+304]
  058c1	83 ee 08	 sub	 esi, 8
  058c4	dd 1e		 fstp	 QWORD PTR [esi]

; 1700 : 		flpush(z);

  058c6	dd 84 24 18 01
	00 00		 fld	 QWORD PTR _y$59229[esp+304]
  058cd	83 ee 08	 sub	 esi, 8
  058d0	dd 1e		 fstp	 QWORD PTR [esi]
  058d2	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR _z$59230[esp+304]
  058d9	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR _z$59230[esp+308]
  058e0	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  058e4	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  058e8	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax

; 1701 : 	    } next;

  058ec	e9 75 a7 ff ff	 jmp	 $L58091
$L59233:

; 1702 : 	    /* Create a new module object
; 1703 : 	     * Filename is a dummy.  NewCompound is
; 1704 : 	     * redefined in module.m.
; 1705 : 	     * ( parent linktype filename -- objaddr )
; 1706 : 	     */
; 1707 : 	    case NEWCOMPOUND: {
; 1708 : 		Object *obj, *parent;
; 1709 : 		cell linktype;
; 1710 : 		char *filename;
; 1711 : 		filename = apop;

  058f1	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1712 : 		linktype = pop; parent = (Object *) apop;

  058f3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  058f6	83 c3 04	 add	 ebx, 4

; 1713 : 		obj = NewCompoundObject(parent, linktype);

  058f9	50		 push	 eax
  058fa	83 c3 04	 add	 ebx, 4
  058fd	51		 push	 ecx
  058fe	8b 13		 mov	 edx, DWORD PTR [ebx]
  05900	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  05904	e8 00 00 00 00	 call	 _NewCompoundObject

; 1714 : 		push(obj); next;

  05909	8b 4c 24 14	 mov	 ecx, DWORD PTR _tos$[esp+312]
  0590d	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  05910	89 0b		 mov	 DWORD PTR [ebx], ecx
  05912	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05916	e9 4b a7 ff ff	 jmp	 $L58091
$L59242:

; 1715 : 	    } next;
; 1716 : 	    /* Find the Meme object that has the input argument
; 1717 : 	     * in its ptr field.  Used for finding the object addr
; 1718 : 	     * of a compound object, given its module addr.  Also used
; 1719 : 		 * for finding the object given a clump pointer.
; 1720 : 	     */
; 1721 : 	    case WHICHOBJECT: tos = (cell)MemeWhichObject((void *)tos); next;

  0591b	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0591f	52		 push	 edx
  05920	e8 00 00 00 00	 call	 _MemeWhichObject
  05925	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  05928	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0592c	e9 35 a7 ff ff	 jmp	 $L58091
$L59247:

; 1722 : 		/* -- -1 */
; 1723 : 		case PUSH_TRUE:	push(-1); next;
; 1724 : 	    /* size -- addr */
; 1725 : 	    case NEWMODULE:
; 1726 : 			tos = (cell)NewModule(tos); next;

  05931	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  05935	51		 push	 ecx
  05936	e8 00 00 00 00	 call	 _NewModule
  0593b	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  0593e	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05942	e9 1f a7 ff ff	 jmp	 $L58091
$L59249:

; 1727 : 	    /* addr -- */
; 1728 : 	    case DESTROYMODULE:
; 1729 : 			ascr = apop; DestroyModule((void *)ascr); next;

  05947	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0594b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0594d	50		 push	 eax
  0594e	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  05952	83 c3 04	 add	 ebx, 4
  05955	e8 00 00 00 00	 call	 _DestroyModule
  0595a	83 c4 04	 add	 esp, 4
  0595d	e9 04 a7 ff ff	 jmp	 $L58091
$L59252:

; 1730 : 		/* msgptr -- result */
; 1731 : 		/* result is 0 if no error, 1 if error */
; 1732 : 	    case SENDMESSAGE: {
; 1733 : 				time_t timeout;
; 1734 : 				ascr = apop;

  05962	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05966	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05968	83 c3 04	 add	 ebx, 4

; 1735 : 				if (ascr != (void *)(0xffffffff)) {	/* If 1st time */

  0596b	83 f8 ff	 cmp	 eax, -1
  0596e	89 44 24 34	 mov	 DWORD PTR _ascr$[esp+304], eax
  05972	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05976	74 13		 je	 SHORT $L59256

; 1736 : 					timeout = time((time_t)0) + SENDMESSAGETIMEOUT;

  05978	6a 00		 push	 0
  0597a	e8 00 00 00 00	 call	 _time
  0597f	83 c4 04	 add	 esp, 4
  05982	83 c0 14	 add	 eax, 20			; 00000014H
  05985	89 44 24 2c	 mov	 DWORD PTR _timeout$59253[esp+304], eax

; 1737 : 				} else {

  05989	eb 16		 jmp	 SHORT $L59258
$L59256:

; 1738 : 					ascr = apop;

  0598b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0598d	83 c3 04	 add	 ebx, 4

; 1739 : 					timeout = pop;

  05990	89 44 24 2c	 mov	 DWORD PTR _timeout$59253[esp+304], eax
  05994	89 4c 24 34	 mov	 DWORD PTR _ascr$[esp+304], ecx
  05998	8b 03		 mov	 eax, DWORD PTR [ebx]
  0599a	83 c3 04	 add	 ebx, 4
  0599d	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
$L59258:

; 1740 : 				}
; 1741 : 				SAVE_XCONTEXT

  059a1	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  059a5	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  059a9	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  059ad	83 eb 04	 sub	 ebx, 4
  059b0	83 ee 08	 sub	 esi, 8

; 1742 : 				scr = SendMemeMessage((void *)ascr, (cell)0);

  059b3	6a 00		 push	 0
  059b5	89 0b		 mov	 DWORD PTR [ebx], ecx
  059b7	8b 4c 24 18	 mov	 ecx, DWORD PTR _ftos$[esp+312]
  059bb	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  059c1	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  059c7	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  059cb	89 06		 mov	 DWORD PTR [esi], eax
  059cd	8b 44 24 38	 mov	 eax, DWORD PTR _ascr$[esp+308]
  059d1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  059d4	50		 push	 eax
  059d5	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  059db	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  059e1	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  059e7	e8 00 00 00 00	 call	 _SendMemeMessage

; 1743 : 				RESTORE_XCONTEXT

  059ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  059f2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  059f8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  059fe	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  05a04	8b 16		 mov	 edx, DWORD PTR [esi]
  05a06	89 4c 24 28	 mov	 DWORD PTR _frp$[esp+312], ecx
  05a0a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  05a0d	89 54 24 18	 mov	 DWORD PTR _ftos$[esp+312], edx
  05a11	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  05a17	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  05a1b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05a1d	83 c4 08	 add	 esp, 8
  05a20	83 c6 08	 add	 esi, 8
  05a23	83 c3 04	 add	 ebx, 4

; 1744 : 				/* If the connection is pending, "idle" this task by
; 1745 : 				 * decrementing IP to point at the token for SENDMESSAGE,
; 1746 : 				 * and pushing the message address back on the int stack.
; 1747 : 				 * If SENDMESSAGE was called by EXECUTE, push the token
; 1748 : 				 * for SENDMESSAGE on the int stack as well.
; 1749 : 				 */
; 1750 : 				if (scr == -1) {

  05a26	83 f8 ff	 cmp	 eax, -1
  05a29	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  05a2d	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  05a31	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  05a35	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05a39	75 6b		 jne	 SHORT $L59270

; 1751 : 					if (timeout > time((time_t)0)) {	/* Not timed out yet */

  05a3b	6a 00		 push	 0
  05a3d	e8 00 00 00 00	 call	 _time
  05a42	8b 4c 24 30	 mov	 ecx, DWORD PTR _timeout$59253[esp+308]
  05a46	83 c4 04	 add	 esp, 4
  05a49	3b c8		 cmp	 ecx, eax
  05a4b	7e 4d		 jle	 SHORT $L59264

; 1752 : 						push(timeout);

  05a4d	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]

; 1753 : 						push(ascr);

  05a51	8b 44 24 2c	 mov	 eax, DWORD PTR _timeout$59253[esp+304]
  05a55	83 eb 04	 sub	 ebx, 4

; 1754 : 						push(-1);

  05a58	8b 4c 24 34	 mov	 ecx, DWORD PTR _ascr$[esp+304]
  05a5c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  05a64	89 13		 mov	 DWORD PTR [ebx], edx
  05a66	83 eb 04	 sub	 ebx, 4
  05a69	89 03		 mov	 DWORD PTR [ebx], eax

; 1755 : 						--ip;

  05a6b	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  05a6e	83 eb 04	 sub	 ebx, 4
  05a71	83 e8 04	 sub	 eax, 4
  05a74	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  05a77	89 0b		 mov	 DWORD PTR [ebx], ecx

; 1756 : 						if (*ip == EXECUTE) {

  05a79	8b 08		 mov	 ecx, DWORD PTR [eax]
  05a7b	83 f9 34	 cmp	 ecx, 52			; 00000034H
  05a7e	0f 85 af 17 00
	00		 jne	 $pause$58247

; 1757 : 							push(SENDMESSAGE); /* Keep braces; push is macro */

  05a84	83 eb 04	 sub	 ebx, 4
  05a87	c7 44 24 0c 3d
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 317 ; 0000013dH
  05a8f	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 1758 : 						}
; 1759 : 						goto pause;

  05a95	e9 99 17 00 00	 jmp	 $pause$58247
$L59264:

; 1760 : 					} else {				/* Timed out */
; 1761 : 						scr = 1;			/* Indicate failure */

  05a9a	b8 01 00 00 00	 mov	 eax, 1

; 1762 : 						V_ERRNO = ESENDMSGTIMEDOUT;

  05a9f	c7 47 4c a8 fd
	ff ff		 mov	 DWORD PTR [edi+76], -600 ; fffffda8H
$L59270:

; 1763 : 					}
; 1764 : 				}
; 1765 : 				push(scr);

  05aa6	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  05aaa	83 eb 04	 sub	 ebx, 4

; 2298 : 				push(scr);

  05aad	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  05ab1	89 13		 mov	 DWORD PTR [ebx], edx

; 2299 : 				next;

  05ab3	e9 ae a5 ff ff	 jmp	 $L58091
$L59272:

; 1766 : 			} next;
; 1767 : 		/* msgptr -- */
; 1768 : 		/* Never returns */
; 1769 : 	    case SENDFINALMESSAGE: {
; 1770 : 				time_t timeout;
; 1771 : 				ascr = apop;

  05ab8	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05abc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05abe	83 c3 04	 add	 ebx, 4

; 1772 : 				if (ascr != (void *)(0xffffffff)) {	/* If 1st time */

  05ac1	83 f8 ff	 cmp	 eax, -1
  05ac4	89 44 24 34	 mov	 DWORD PTR _ascr$[esp+304], eax
  05ac8	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05acc	74 13		 je	 SHORT $L59276

; 1773 : 					timeout = time((time_t)0) + SENDMESSAGETIMEOUT;

  05ace	6a 00		 push	 0
  05ad0	e8 00 00 00 00	 call	 _time
  05ad5	83 c4 04	 add	 esp, 4
  05ad8	83 c0 14	 add	 eax, 20			; 00000014H
  05adb	89 44 24 2c	 mov	 DWORD PTR _timeout$59273[esp+304], eax

; 1774 : 				} else {

  05adf	eb 16		 jmp	 SHORT $L59278
$L59276:

; 1775 : 					ascr = apop;

  05ae1	8b 03		 mov	 eax, DWORD PTR [ebx]
  05ae3	83 c3 04	 add	 ebx, 4

; 1776 : 					timeout = pop;

  05ae6	89 44 24 2c	 mov	 DWORD PTR _timeout$59273[esp+304], eax
  05aea	89 4c 24 34	 mov	 DWORD PTR _ascr$[esp+304], ecx
  05aee	8b 03		 mov	 eax, DWORD PTR [ebx]
  05af0	83 c3 04	 add	 ebx, 4
  05af3	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
$L59278:

; 1777 : 				}
; 1778 : 				V_TASK_ACTIVE = 0;
; 1779 : 				SAVE_XCONTEXT

  05af7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  05afb	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  05aff	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  05b03	83 eb 04	 sub	 ebx, 4
  05b06	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0
  05b0d	83 ee 08	 sub	 esi, 8
  05b10	89 0b		 mov	 DWORD PTR [ebx], ecx
  05b12	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  05b16	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05b1c	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05b22	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  05b26	89 06		 mov	 DWORD PTR [esi], eax

; 1780 : 				scr = SendMemeMessage((void *)ascr, (cell)0);

  05b28	8b 44 24 34	 mov	 eax, DWORD PTR _ascr$[esp+304]
  05b2c	6a 00		 push	 0
  05b2e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  05b31	50		 push	 eax
  05b32	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05b38	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05b3e	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05b44	e8 00 00 00 00	 call	 _SendMemeMessage

; 1781 : 				RESTORE_XCONTEXT

  05b49	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  05b4f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  05b55	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  05b5b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  05b61	8b 16		 mov	 edx, DWORD PTR [esi]
  05b63	89 4c 24 28	 mov	 DWORD PTR _frp$[esp+312], ecx
  05b67	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  05b6a	89 54 24 18	 mov	 DWORD PTR _ftos$[esp+312], edx
  05b6e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  05b74	89 4c 24 1c	 mov	 DWORD PTR _ftos$[esp+316], ecx
  05b78	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05b7a	83 c4 08	 add	 esp, 8
  05b7d	83 c6 08	 add	 esi, 8
  05b80	83 c3 04	 add	 ebx, 4

; 1782 : 				/* If the connection is pending, "idle" this task by
; 1783 : 				 * decrementing IP to point at the token for SENDMESSAGE,
; 1784 : 				 * and pushing the message address back on the int stack.
; 1785 : 				 * If SENDMESSAGE was called by EXECUTE, push the token
; 1786 : 				 * for SENDMESSAGE on the int stack as well.
; 1787 : 				 */
; 1788 : 				if (scr == -1) {

  05b83	83 f8 ff	 cmp	 eax, -1
  05b86	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  05b8a	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  05b8e	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  05b92	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  05b96	75 61		 jne	 SHORT $L59284

; 1789 : 					if (timeout > time((time_t)0)) {	/* Not timed out yet */

  05b98	6a 00		 push	 0
  05b9a	e8 00 00 00 00	 call	 _time
  05b9f	8b 4c 24 30	 mov	 ecx, DWORD PTR _timeout$59273[esp+308]
  05ba3	83 c4 04	 add	 esp, 4
  05ba6	3b c8		 cmp	 ecx, eax
  05ba8	7e 4f		 jle	 SHORT $L59284

; 1790 : 						V_TASK_ACTIVE = -1;
; 1791 : 						push(timeout);

  05baa	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]

; 1792 : 						push(ascr);

  05bae	8b 4c 24 2c	 mov	 ecx, DWORD PTR _timeout$59273[esp+304]
  05bb2	83 c8 ff	 or	 eax, -1
  05bb5	83 eb 04	 sub	 ebx, 4
  05bb8	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 1793 : 						push(-1);

  05bbb	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 1794 : 						--ip;

  05bbf	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  05bc2	89 13		 mov	 DWORD PTR [ebx], edx
  05bc4	8b 54 24 34	 mov	 edx, DWORD PTR _ascr$[esp+304]
  05bc8	83 eb 04	 sub	 ebx, 4
  05bcb	83 e8 04	 sub	 eax, 4
  05bce	89 0b		 mov	 DWORD PTR [ebx], ecx
  05bd0	83 eb 04	 sub	 ebx, 4
  05bd3	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  05bd6	89 13		 mov	 DWORD PTR [ebx], edx

; 1795 : 						if (*ip == EXECUTE) {

  05bd8	8b 08		 mov	 ecx, DWORD PTR [eax]
  05bda	83 f9 34	 cmp	 ecx, 52			; 00000034H
  05bdd	0f 85 50 16 00
	00		 jne	 $pause$58247

; 1796 : 							push(SENDFINALMESSAGE); /* Braces for push macro */

  05be3	83 eb 04	 sub	 ebx, 4
  05be6	c7 44 24 0c 3e
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 318 ; 0000013eH
  05bee	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 1797 : 						}
; 1798 : 						goto pause;

  05bf4	e9 3a 16 00 00	 jmp	 $pause$58247
$L59284:

; 1799 : 					}
; 1800 : 				}
; 1801 : 			} 
; 1802 : 			/* Switch context directly to the main task */
; 1803 : 			if (up != (cell *)main_task) {

  05bf9	81 ff 00 00 00
	00		 cmp	 edi, OFFSET FLAT:_main_task
  05bff	0f 84 59 a4 ff
	ff		 je	 $L61881

; 1804 : 				up = (cell *)main_task;

  05c05	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_main_task
  05c0a	89 44 24 28	 mov	 DWORD PTR _up$[esp+304], eax

; 1805 : 				goto task_dispatcher;

  05c0e	e9 e5 16 00 00	 jmp	 $task_dispatcher$58939
$L59293:

; 1806 : 			}
; 1807 : 			next;
; 1808 : 		case REGISTERDECKMODULE:
; 1809 : 			ascr = apop;

  05c13	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1810 : 			SAVE_XCONTEXT

  05c15	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  05c19	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05c1d	89 0b		 mov	 DWORD PTR [ebx], ecx
  05c1f	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  05c23	83 ee 08	 sub	 esi, 8
  05c26	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05c2c	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  05c32	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  05c36	89 16		 mov	 DWORD PTR [esi], edx
  05c38	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  05c3c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1811 : 			scr = RegisterDeckModule( (module *)ascr );

  05c3f	50		 push	 eax
  05c40	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05c46	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05c4c	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05c52	e8 00 00 00 00	 call	 _RegisterDeckModule
  05c57	83 c4 04	 add	 esp, 4

; 1812 : 			RESTORE_XCONTEXT
; 1813 : 			push(scr);
; 1814 : 			next;

  05c5a	e9 bb 0e 00 00	 jmp	 $L61959
$L59297:

; 1815 : #ifdef	CMAN
; 1816 : 			case CYBERMAN: *--sp = tos; tos = (cell)CyberMan(); next;
; 1817 : #else /* CMAN */
; 1818 : 			case CYBERMAN:
; 1819 : 				error("CyberMan support is unimplemented in this version.\n");

  05c5f	68 00 00 00 00	 push	 OFFSET FLAT:$SG59298
  05c64	e8 00 00 00 00	 call	 _error
  05c69	83 c4 04	 add	 esp, 4

; 1820 : 				next;

  05c6c	e9 f5 a3 ff ff	 jmp	 $L58091
$L59301:

; 1821 : #endif /* CMAN */
; 1822 : 			/* -- extended-err-code */
; 1823 : 			case GETLASTERROR:	push(V_ERRNO);	next;
; 1824 : 			/* comport baudrate parity databits stopbits -- portdesc */
; 1825 : 			case SER_OPEN: {
; 1826 : 				cell	comport;		/* 0 = COM1, 1 = COM2, etc.	*/
; 1827 : 				cell	baudrate;		/* 9600 = 9600 baud, etc.	*/
; 1828 : 				cell	parity;			/* 'N', 'E', or 'O'			*/
; 1829 : 				cell	word_length;	/* 7 or 8					*/
; 1830 : 				cell	stop_bits;		/* 1 or 2					*/
; 1831 : 				stop_bits = pop;

  05c71	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1832 : 				word_length = pop;

  05c73	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05c76	83 c3 04	 add	 ebx, 4

; 1833 : 				parity = pop;

  05c79	89 54 24 40	 mov	 DWORD PTR _parity$59304[esp+304], edx
  05c7d	83 c3 04	 add	 ebx, 4
  05c80	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1834 : 				baudrate = pop;
; 1835 : 				comport = pop;
; 1836 : 				push(SerialOpen(comport, baudrate, parity,
; 1837 : 											word_length, stop_bits));

  05c84	50		 push	 eax
  05c85	51		 push	 ecx
  05c86	8b 13		 mov	 edx, DWORD PTR [ebx]
  05c88	83 c3 04	 add	 ebx, 4
  05c8b	89 54 24 58	 mov	 DWORD PTR _baudrate$59303[esp+312], edx
  05c8f	8b 13		 mov	 edx, DWORD PTR [ebx]
  05c91	8b 44 24 58	 mov	 eax, DWORD PTR _baudrate$59303[esp+312]
  05c95	83 c3 04	 add	 ebx, 4
  05c98	89 54 24 78	 mov	 DWORD PTR _comport$59302[esp+312], edx
  05c9c	8b 4c 24 78	 mov	 ecx, DWORD PTR _comport$59302[esp+312]
  05ca0	8b 13		 mov	 edx, DWORD PTR [ebx]
  05ca2	89 13		 mov	 DWORD PTR [ebx], edx
  05ca4	8b 54 24 48	 mov	 edx, DWORD PTR _parity$59304[esp+312]
  05ca8	52		 push	 edx
  05ca9	50		 push	 eax
  05caa	51		 push	 ecx
  05cab	e8 00 00 00 00	 call	 _SerialOpen
  05cb0	83 c4 14	 add	 esp, 20			; 00000014H

; 2298 : 				push(scr);

  05cb3	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05cb7	e9 aa a3 ff ff	 jmp	 $L58091
$L59308:

; 1838 : 			} next;
; 1839 : 			/* portdesc -- errflag */
; 1840 : 			case SER_CLOSE: {
; 1841 : 				cell portdesc;
; 1842 : 				portdesc = pop;

  05cbc	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05cc0	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1843 : 				push(SerialClose(portdesc));

  05cc2	50		 push	 eax
  05cc3	89 0b		 mov	 DWORD PTR [ebx], ecx
  05cc5	e8 00 00 00 00	 call	 _SerialClose
  05cca	83 c4 04	 add	 esp, 4

; 2298 : 				push(scr);

  05ccd	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05cd1	e9 90 a3 ff ff	 jmp	 $L58091
$L59311:

; 1844 : 			} next;
; 1845 : 			/* portdesc buffer length -- actual */
; 1846 : 			case SER_READ: {
; 1847 : 				cell portdesc;
; 1848 : 				cell buff;
; 1849 : 				cell len;
; 1850 : 				len = pop;  buff = pop; portdesc = pop;

  05cd6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05cd8	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05cdb	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05cdf	83 c3 04	 add	 ebx, 4
  05ce2	83 c3 04	 add	 ebx, 4
  05ce5	89 54 24 40	 mov	 DWORD PTR _portdesc$59312[esp+304], edx

; 1851 : 				push(SerialRead(portdesc, buff, len));

  05ce9	50		 push	 eax
  05cea	51		 push	 ecx
  05ceb	8b 13		 mov	 edx, DWORD PTR [ebx]
  05ced	89 13		 mov	 DWORD PTR [ebx], edx
  05cef	8b 54 24 48	 mov	 edx, DWORD PTR _portdesc$59312[esp+312]
  05cf3	52		 push	 edx
  05cf4	e8 00 00 00 00	 call	 _SerialRead
  05cf9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2298 : 				push(scr);

  05cfc	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05d00	e9 61 a3 ff ff	 jmp	 $L58091
$L59316:

; 1852 : 			} next;
; 1853 : 			/* portdesc buffer length -- actual */
; 1854 : 			case SER_WRITE: {
; 1855 : 				cell portdesc;
; 1856 : 				cell buff;
; 1857 : 				cell len;
; 1858 : 				len = pop; buff = pop; portdesc = pop;

  05d05	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05d07	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05d0a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05d0e	83 c3 04	 add	 ebx, 4
  05d11	83 c3 04	 add	 ebx, 4
  05d14	89 54 24 40	 mov	 DWORD PTR _portdesc$59317[esp+304], edx

; 1859 : 				push(SerialWrite(portdesc, buff, len));

  05d18	50		 push	 eax
  05d19	8b 44 24 44	 mov	 eax, DWORD PTR _portdesc$59317[esp+308]
  05d1d	8b 13		 mov	 edx, DWORD PTR [ebx]
  05d1f	51		 push	 ecx
  05d20	50		 push	 eax
  05d21	89 13		 mov	 DWORD PTR [ebx], edx
  05d23	e8 00 00 00 00	 call	 _SerialWrite
  05d28	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2298 : 				push(scr);

  05d2b	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  05d2f	e9 32 a3 ff ff	 jmp	 $L58091
$L59321:

; 1860 : 			} next;
; 1861 : 	    	/* Open an active connection to the network. sockdesc
; 1862 : 			 * = -1 if failure.
; 1863 : 	    	 * ( ipnumber port timeout -- sockdesc )
; 1864 : 	    	 */
; 1865 : 	    	case NET_CONNECT: {
; 1866 : 				unsigned long ipnumber;
; 1867 : 				cell port;
; 1868 : 				cell timeout;
; 1869 : 				timeout = pop;

  05d34	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1870 : 				port = pop;

  05d36	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05d39	83 c3 04	 add	 ebx, 4
  05d3c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05d40	83 c3 04	 add	 ebx, 4

; 1871 : 				ipnumber = (unsigned long)pop;

  05d43	89 54 24 40	 mov	 DWORD PTR _ipnumber$59322[esp+304], edx

; 1872 : 				SAVE_XCONTEXT

  05d47	83 ee 08	 sub	 esi, 8

; 1873 : 				scr = NetConnect(ipnumber, port, timeout);

  05d4a	50		 push	 eax
  05d4b	8b 13		 mov	 edx, DWORD PTR [ebx]
  05d4d	8b 44 24 44	 mov	 eax, DWORD PTR _ipnumber$59322[esp+308]
  05d51	89 13		 mov	 DWORD PTR [ebx], edx
  05d53	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  05d57	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05d5d	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  05d61	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05d67	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  05d6b	89 16		 mov	 DWORD PTR [esi], edx
  05d6d	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  05d71	51		 push	 ecx
  05d72	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  05d75	50		 push	 eax
  05d76	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05d7c	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05d82	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05d88	e8 00 00 00 00	 call	 _NetConnect

; 1874 : 				RESTORE_XCONTEXT
; 1875 : 				push(scr);
; 1876 : 	    	} next;

  05d8d	e9 85 0d 00 00	 jmp	 $L61963
$L59327:

; 1877 : 		
; 1878 : 	   		/* Open a passive connection to the network.  sockdesc
; 1879 : 			 * = -1 if failure.
; 1880 : 	    	 * ( port timeout -- sockdesc )
; 1881 : 	    	 */
; 1882 : 	    	case NET_LISTEN: {
; 1883 : 				cell port, timeout;
; 1884 : 				timeout = pop; port = pop; 

  05d92	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05d94	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05d97	83 c3 04	 add	 ebx, 4
  05d9a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1885 : 				SAVE_XCONTEXT

  05d9e	83 ee 08	 sub	 esi, 8

; 1886 : 				scr = NetListen(port, timeout);

  05da1	50		 push	 eax
  05da2	89 13		 mov	 DWORD PTR [ebx], edx
  05da4	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  05da8	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05dae	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  05db2	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05db8	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  05dbc	89 16		 mov	 DWORD PTR [esi], edx
  05dbe	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  05dc2	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  05dc5	51		 push	 ecx
  05dc6	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05dcc	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05dd2	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05dd8	e8 00 00 00 00	 call	 _NetListen
  05ddd	83 c4 08	 add	 esp, 8

; 1887 : 				RESTORE_XCONTEXT
; 1888 : 				push(scr);
; 1889 : 	    	} next;

  05de0	e9 35 0d 00 00	 jmp	 $L61959
$L59331:

; 1890 : 
; 1891 : 	    	/* Read data from the network
; 1892 : 	    	 * ( sockdesc buffer len -- actual )
; 1893 : 	    	 */
; 1894 : 	    	case NET_READ:
; 1895 : 				scr = pop; ascr = apop; ascr1 = apop;

  05de5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05de7	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05dea	83 c3 04	 add	 ebx, 4
  05ded	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05df1	83 c3 04	 add	 ebx, 4
  05df4	89 54 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], edx

; 1896 : 				SAVE_XCONTEXT

  05df8	83 ee 08	 sub	 esi, 8

; 1897 : 				scr = NetRead(ascr1, ascr, scr);

  05dfb	50		 push	 eax
  05dfc	8b 13		 mov	 edx, DWORD PTR [ebx]
  05dfe	51		 push	 ecx
  05dff	89 13		 mov	 DWORD PTR [ebx], edx
  05e01	8b 54 24 24	 mov	 edx, DWORD PTR _rp$[esp+312]
  05e05	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05e0b	8b 54 24 18	 mov	 edx, DWORD PTR _ftos$[esp+312]
  05e0f	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05e15	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ftos$[esp+316]
  05e19	89 16		 mov	 DWORD PTR [esi], edx
  05e1b	8b 54 24 28	 mov	 edx, DWORD PTR _frp$[esp+312]
  05e1f	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  05e22	8b 44 24 44	 mov	 eax, DWORD PTR _ascr1$[esp+312]
  05e26	50		 push	 eax
  05e27	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05e2d	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05e33	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05e39	e8 00 00 00 00	 call	 _NetRead

; 1898 : 				RESTORE_XCONTEXT
; 1899 : 				push(scr);
; 1900 : 				next;

  05e3e	e9 d4 0c 00 00	 jmp	 $L61963
$L59335:

; 1901 : 	    	/* Write data to the network
; 1902 : 	    	 * ( sockdesc buffer len -- actual )
; 1903 : 	    	 */
; 1904 : 	    	case NET_WRITE:
; 1905 : 				scr = pop; ascr = apop; ascr1 = apop;

  05e43	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  05e45	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05e48	83 c3 04	 add	 ebx, 4
  05e4b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05e4f	83 c3 04	 add	 ebx, 4
  05e52	89 54 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], edx

; 1906 : 				SAVE_XCONTEXT

  05e56	83 ee 08	 sub	 esi, 8

; 1907 : 				scr = NetWrite(ascr1, ascr, scr);

  05e59	50		 push	 eax
  05e5a	8b 13		 mov	 edx, DWORD PTR [ebx]
  05e5c	51		 push	 ecx
  05e5d	89 13		 mov	 DWORD PTR [ebx], edx
  05e5f	8b 54 24 24	 mov	 edx, DWORD PTR _rp$[esp+312]
  05e63	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05e69	8b 54 24 18	 mov	 edx, DWORD PTR _ftos$[esp+312]
  05e6d	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05e73	8b 5c 24 1c	 mov	 ebx, DWORD PTR _ftos$[esp+316]
  05e77	89 16		 mov	 DWORD PTR [esi], edx
  05e79	8b 54 24 28	 mov	 edx, DWORD PTR _frp$[esp+312]
  05e7d	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  05e80	8b 44 24 44	 mov	 eax, DWORD PTR _ascr1$[esp+312]
  05e84	50		 push	 eax
  05e85	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05e8b	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05e91	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05e97	e8 00 00 00 00	 call	 _NetWrite

; 1908 : 				RESTORE_XCONTEXT
; 1909 : 				push(scr);
; 1910 : 				next;

  05e9c	e9 76 0c 00 00	 jmp	 $L61963
$L59339:

; 1911 : 	    	/* Close the network connection
; 1912 : 	    	 * ( sockdesc timeout -- code )
; 1913 : 			 */
; 1914 : 	    	case NET_DISCONNECT:
; 1915 : 				scr = pop;

  05ea1	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1916 : 				ascr = apop;

  05ea3	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  05ea6	83 c3 04	 add	 ebx, 4
  05ea9	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 1917 : 				SAVE_XCONTEXT

  05ead	83 ee 08	 sub	 esi, 8

; 1918 : 				scr = NetDisconnect(ascr, scr);

  05eb0	50		 push	 eax
  05eb1	89 13		 mov	 DWORD PTR [ebx], edx
  05eb3	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  05eb7	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05ebd	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  05ec1	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05ec7	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  05ecb	89 16		 mov	 DWORD PTR [esi], edx
  05ecd	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  05ed1	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  05ed4	51		 push	 ecx
  05ed5	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05edb	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05ee1	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05ee7	e8 00 00 00 00	 call	 _NetDisconnect
  05eec	83 c4 08	 add	 esp, 8

; 1919 : 				RESTORE_XCONTEXT
; 1920 : 				push(scr);
; 1921 : 				next;

  05eef	e9 26 0c 00 00	 jmp	 $L61959
$L59342:

; 1922 : 			/* Wait for the network connection to be established
; 1923 : 			 * ( sockdesc -- code )
; 1924 : 			 */
; 1925 : 			case NET_CONNECTED:
; 1926 : 				ascr = apop;

  05ef4	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1927 : 				SAVE_XCONTEXT

  05ef6	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  05efa	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05efe	89 0b		 mov	 DWORD PTR [ebx], ecx
  05f00	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  05f04	83 ee 08	 sub	 esi, 8
  05f07	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05f0d	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  05f13	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  05f17	89 16		 mov	 DWORD PTR [esi], edx
  05f19	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  05f1d	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1928 : 				scr = NetConnected(ascr);

  05f20	50		 push	 eax
  05f21	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05f27	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05f2d	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05f33	e8 00 00 00 00	 call	 _NetConnected
  05f38	83 c4 04	 add	 esp, 4

; 1929 : 				RESTORE_XCONTEXT
; 1930 : 				push(scr);
; 1931 : 				next;

  05f3b	e9 da 0b 00 00	 jmp	 $L61959
$L59345:

; 1932 : 			/* Wait for the network connection to close
; 1933 : 			 * ( sockdesc -- code )
; 1934 : 			 */
; 1935 : 			case NET_DISCONNECTED:
; 1936 : 				ascr = apop;

  05f40	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1937 : 				SAVE_XCONTEXT

  05f42	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  05f46	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05f4a	89 0b		 mov	 DWORD PTR [ebx], ecx
  05f4c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  05f50	83 ee 08	 sub	 esi, 8
  05f53	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05f59	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  05f5f	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  05f63	89 16		 mov	 DWORD PTR [esi], edx
  05f65	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  05f69	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1938 : 				scr = NetDisconnected(ascr);

  05f6c	50		 push	 eax
  05f6d	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05f73	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05f79	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  05f7f	e8 00 00 00 00	 call	 _NetDisconnected
  05f84	83 c4 04	 add	 esp, 4

; 1939 : 				RESTORE_XCONTEXT
; 1940 : 				push(scr);
; 1941 : 				next;

  05f87	e9 8e 0b 00 00	 jmp	 $L61959
$L59299:

; 1942 : 			/* Return the network error code
; 1943 : 			 * ( -- n )
; 1944 : 			 */
; 1945 : 			case NET_ERROR:
; 1946 : 				push(V_ERRNO);

  05f8c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05f90	83 eb 04	 sub	 ebx, 4
  05f93	89 03		 mov	 DWORD PTR [ebx], eax
  05f95	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  05f98	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 1947 : 				next;

  05f9c	e9 c5 a0 ff ff	 jmp	 $L58091
$L59350:

; 1948 : 			/* Return the number of bytes waiting on a socket.
; 1949 : 			 * ( sockdesc -- #bytes )
; 1950 : 			 */
; 1951 : 			case NET_STATUS:
; 1952 : 				ascr = apop;

  05fa1	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1953 : 				SAVE_XCONTEXT

  05fa3	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  05fa7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  05fab	89 0b		 mov	 DWORD PTR [ebx], ecx
  05fad	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  05fb1	83 ee 08	 sub	 esi, 8
  05fb4	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  05fba	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  05fc0	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  05fc4	89 0e		 mov	 DWORD PTR [esi], ecx
  05fc6	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  05fca	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1954 : 				scr = NetStatus(ascr);

  05fcd	50		 push	 eax
  05fce	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  05fd4	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  05fda	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  05fe0	e8 00 00 00 00	 call	 _NetStatus

; 1955 : 				RESTORE_XCONTEXT

  05fe5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  05feb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp

; 2297 : 				RESTORE_XCONTEXT

  05ff1	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  05ff7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  05ffd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  05fff	89 54 24 24	 mov	 DWORD PTR _frp$[esp+308], edx
  06003	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  06006	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  0600a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  06010	83 c4 04	 add	 esp, 4
  06013	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  06017	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06019	83 c6 08	 add	 esi, 8
  0601c	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  06020	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  06024	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2298 : 				push(scr);

  06028	89 0b		 mov	 DWORD PTR [ebx], ecx
  0602a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0602e	e9 33 a0 ff ff	 jmp	 $L58091
$L59353:

; 1956 : 				push(scr);
; 1957 : 				next;
; 1958 : 			/* Return a random 32-bit value */
; 1959 : 			case RAND: push((cell)myrand()); next;

  06033	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  06037	83 eb 04	 sub	 ebx, 4
  0603a	89 13		 mov	 DWORD PTR [ebx], edx
  0603c	e8 00 00 00 00	 call	 _myrand

; 2298 : 				push(scr);

  06041	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  06045	e9 1c a0 ff ff	 jmp	 $L58091
$L59356:

; 1960 : 			case RANDOMIZE: myrandomize(); next;

  0604a	e8 00 00 00 00	 call	 _myrandomize
  0604f	e9 12 a0 ff ff	 jmp	 $L58091
$L59357:

; 1961 : 			case WINDOWHEIGHT:
; 1962 : 				push( MemeWindowHeight() );

  06054	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06058	83 eb 04	 sub	 ebx, 4
  0605b	89 03		 mov	 DWORD PTR [ebx], eax
  0605d	e8 00 00 00 00	 call	 _MemeWindowHeight

; 2298 : 				push(scr);

  06062	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  06066	e9 fb 9f ff ff	 jmp	 $L58091
$L59359:

; 1963 : 				next;
; 1964 : 			case WINDOWWIDTH:
; 1965 : 				push( MemeWindowWidth() );

  0606b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0606f	83 eb 04	 sub	 ebx, 4
  06072	89 0b		 mov	 DWORD PTR [ebx], ecx
  06074	e8 00 00 00 00	 call	 _MemeWindowWidth

; 2298 : 				push(scr);

  06079	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0607d	e9 e4 9f ff ff	 jmp	 $L58091
$L59361:

; 1966 : 				next;
; 1967 : 			/* ( regionptr prismptr -- regionptr ) */
; 1968 : 			case ADDTOREGION:
; 1969 : 				ascr1 = apop;

  06082	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06086	83 c3 04	 add	 ebx, 4
  06089	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  0608d	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 1970 : 				ascr = apop;

  06090	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1971 : 				ascr = (u_char *)AddToRegion((Region *)ascr, (RPrism *)ascr1);

  06092	50		 push	 eax
  06093	51		 push	 ecx
  06094	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  06098	e8 00 00 00 00	 call	 _AddToRegion

; 1972 : 				push(ascr);

  0609d	8b 4c 24 14	 mov	 ecx, DWORD PTR _tos$[esp+312]
  060a1	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  060a4	89 0b		 mov	 DWORD PTR [ebx], ecx
  060a6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  060aa	e9 b7 9f ff ff	 jmp	 $L58091
$L59368:

; 1973 : 				next;
; 1974 : 			/* ( regionptr -- ) */
; 1975 : 			case DESTROYREGION:
; 1976 : 				ascr = apop;

  060af	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  060b3	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1977 : 				DestroyRegion((Region *)ascr);

  060b5	50		 push	 eax
  060b6	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  060ba	83 c3 04	 add	 ebx, 4
  060bd	e8 00 00 00 00	 call	 _DestroyRegion
  060c2	83 c4 04	 add	 esp, 4

; 1978 : 				next;

  060c5	e9 9c 9f ff ff	 jmp	 $L58091
$L59371:

; 1979 : 			/* ( [float] x y z -- ) ( regionptr -- boolean ) */
; 1980 : 			case POINTINREGION: {
; 1981 : 				double x, y, z;
; 1982 : 				z = flpop; y = flpop; x = flpop;

  060ca	dd 06		 fld	 QWORD PTR [esi]
  060cc	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  060d0	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  060d4	dd 5c 24 40	 fstp	 QWORD PTR _y$59373[esp+304]
  060d8	dd 46 08	 fld	 QWORD PTR [esi+8]
  060db	83 c6 08	 add	 esi, 8
  060de	89 8c 24 84 00
	00 00		 mov	 DWORD PTR _z$59374[esp+308], ecx

; 1983 : 				ascr = apop;

  060e5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  060e7	83 c6 08	 add	 esi, 8
  060ea	dd 5c 24 50	 fstp	 QWORD PTR _x$59372[esp+304]
  060ee	8b 16		 mov	 edx, DWORD PTR [esi]
  060f0	89 84 24 80 00
	00 00		 mov	 DWORD PTR _z$59374[esp+304], eax
  060f7	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1984 : 				push((cell)PointInRegion((Region *)ascr, x, y, z));

  060fa	89 0b		 mov	 DWORD PTR [ebx], ecx
  060fc	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR _z$59374[esp+308]
  06103	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  06107	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR _z$59374[esp+304]
  0610e	51		 push	 ecx
  0610f	8b 4c 24 48	 mov	 ecx, DWORD PTR _y$59373[esp+312]
  06113	52		 push	 edx
  06114	8b 54 24 48	 mov	 edx, DWORD PTR _y$59373[esp+312]
  06118	51		 push	 ecx
  06119	8b 4c 24 60	 mov	 ecx, DWORD PTR _x$59372[esp+320]
  0611d	52		 push	 edx
  0611e	8b 54 24 60	 mov	 edx, DWORD PTR _x$59372[esp+320]
  06122	89 44 24 24	 mov	 DWORD PTR _ftos$[esp+324], eax
  06126	8b 44 24 1c	 mov	 eax, DWORD PTR _tos$[esp+320]
  0612a	51		 push	 ecx
  0612b	83 c6 08	 add	 esi, 8
  0612e	52		 push	 edx
  0612f	50		 push	 eax
  06130	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  06134	e8 00 00 00 00	 call	 _PointInRegion
  06139	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2298 : 				push(scr);

  0613c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  06140	e9 21 9f ff ff	 jmp	 $L58091
$L59379:

; 1985 : 				next;
; 1986 : 			}
; 1987 : 			/* ( [float] x y z -- ) ( prismptr -- boolean ) */
; 1988 : 			case POINTINPRISM: {
; 1989 : 				double x, y, z;
; 1990 : 				z = flpop; y = flpop; x = flpop;

  06145	dd 06		 fld	 QWORD PTR [esi]
  06147	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0614b	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0614f	dd 5c 24 40	 fstp	 QWORD PTR _y$59381[esp+304]
  06153	dd 46 08	 fld	 QWORD PTR [esi+8]
  06156	83 c6 08	 add	 esi, 8
  06159	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR _z$59382[esp+308], ecx

; 1991 : 				ascr = apop;

  06160	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06162	83 c6 08	 add	 esi, 8
  06165	dd 5c 24 50	 fstp	 QWORD PTR _x$59380[esp+304]
  06169	8b 16		 mov	 edx, DWORD PTR [esi]
  0616b	89 84 24 d0 00
	00 00		 mov	 DWORD PTR _z$59382[esp+304], eax
  06172	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1992 : 				push((cell)PointInPrism((RPrism *)ascr, x, y, z));

  06175	89 0b		 mov	 DWORD PTR [ebx], ecx
  06177	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR _z$59382[esp+308]
  0617e	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  06182	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR _z$59382[esp+304]
  06189	51		 push	 ecx
  0618a	8b 4c 24 48	 mov	 ecx, DWORD PTR _y$59381[esp+312]
  0618e	52		 push	 edx
  0618f	8b 54 24 48	 mov	 edx, DWORD PTR _y$59381[esp+312]
  06193	51		 push	 ecx
  06194	8b 4c 24 60	 mov	 ecx, DWORD PTR _x$59380[esp+320]
  06198	52		 push	 edx
  06199	8b 54 24 60	 mov	 edx, DWORD PTR _x$59380[esp+320]
  0619d	89 44 24 24	 mov	 DWORD PTR _ftos$[esp+324], eax
  061a1	8b 44 24 1c	 mov	 eax, DWORD PTR _tos$[esp+320]
  061a5	51		 push	 ecx
  061a6	83 c6 08	 add	 esi, 8
  061a9	52		 push	 edx
  061aa	50		 push	 eax
  061ab	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  061af	e8 00 00 00 00	 call	 _PointInPrism
  061b4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2298 : 				push(scr);

  061b7	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  061bb	e9 a6 9e ff ff	 jmp	 $L58091
$L59387:

; 1993 : 				next;
; 1994 : 			}
; 1995 : 			/* ( prismptr1 prismptr2 -- boolean ) */
; 1996 : 			case OVERLAPPINGPRISMS:
; 1997 : 				ascr1 = apop;

  061c0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  061c4	83 c3 04	 add	 ebx, 4
  061c7	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  061cb	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 1998 : 				ascr = apop;

  061ce	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1999 : 				push(OverlappingPrisms((RPrism *)ascr, (RPrism *)ascr1));

  061d0	89 0b		 mov	 DWORD PTR [ebx], ecx
  061d2	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ascr1$[esp+304]
  061d6	51		 push	 ecx
  061d7	50		 push	 eax
  061d8	e8 00 00 00 00	 call	 _OverlappingPrisms
  061dd	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  061e0	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  061e4	e9 7d 9e ff ff	 jmp	 $L58091
$L59393:

; 2000 : 				next;
; 2001 : 			/* ( regionptr1 regionptr2 -- boolean ) */
; 2002 : 			case OVERLAPPINGREGIONS:
; 2003 : 				ascr1 = apop;

  061e9	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  061ed	83 c3 04	 add	 ebx, 4
  061f0	89 54 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], edx
  061f4	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 2004 : 				ascr = apop;

  061f7	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2005 : 				push(OverlappingRegions((Region *)ascr, (Region *)ascr1));

  061f9	89 0b		 mov	 DWORD PTR [ebx], ecx
  061fb	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ascr1$[esp+304]
  061ff	51		 push	 ecx
  06200	50		 push	 eax
  06201	e8 00 00 00 00	 call	 _OverlappingRegions
  06206	83 c4 08	 add	 esp, 8

; 2298 : 				push(scr);

  06209	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  0620d	e9 54 9e ff ff	 jmp	 $L58091
$L59399:

; 2006 : 				next;
; 2007 : 			/* ( regionptr -- boolean ) */
; 2008 : 			case REGISTERREGION:
; 2009 : 				ascr = apop;

  06212	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2010 : 				SAVE_XCONTEXT

  06214	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  06218	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0621c	89 0b		 mov	 DWORD PTR [ebx], ecx
  0621e	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  06222	83 ee 08	 sub	 esi, 8
  06225	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0622b	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  06231	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  06235	89 0e		 mov	 DWORD PTR [esi], ecx
  06237	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  0623b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 2011 : 				ascr = (u_char *)RegisterDBRegion((Region *)ascr);

  0623e	50		 push	 eax
  0623f	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  06245	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0624b	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  06251	e8 00 00 00 00	 call	 _RegisterDBRegion

; 2012 : 				RESTORE_XCONTEXT
; 2013 : 				if (ascr) { push(-1); } else { push(0); }
; 2014 : 				next;

  06256	eb 44		 jmp	 SHORT $L61965
$L59407:

; 2015 : 			/* ( regionptr -- boolean ) */
; 2016 : 			case UNREGISTERREGION:
; 2017 : 				ascr = apop;

  06258	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2018 : 				SAVE_XCONTEXT

  0625a	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0625e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06262	89 0b		 mov	 DWORD PTR [ebx], ecx
  06264	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  06268	83 ee 08	 sub	 esi, 8
  0626b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  06271	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  06277	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0627b	89 0e		 mov	 DWORD PTR [esi], ecx
  0627d	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  06281	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 2019 : 				ascr = (u_char *)UnregisterDBRegion((Region *)ascr);

  06284	50		 push	 eax
  06285	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0628b	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  06291	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  06297	e8 00 00 00 00	 call	 _UnregisterDBRegion
$L61965:

; 2020 : 				RESTORE_XCONTEXT

  0629c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  062a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  062a8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  062ae	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  062b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  062b6	89 54 24 24	 mov	 DWORD PTR _frp$[esp+308], edx
  062ba	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  062bd	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  062c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  062c7	83 c4 04	 add	 esp, 4
  062ca	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  062ce	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  062d0	83 c6 08	 add	 esi, 8
  062d3	83 c3 04	 add	 ebx, 4

; 2021 : 				if (ascr) { push(-1); } else { push(0); }

  062d6	85 c0		 test	 eax, eax
  062d8	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  062dc	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  062e0	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  062e4	74 12		 je	 SHORT $L59403
  062e6	83 eb 04	 sub	 ebx, 4
  062e9	89 0b		 mov	 DWORD PTR [ebx], ecx
$L61622:
  062eb	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  062f3	e9 6e 9d ff ff	 jmp	 $L58091
$L59403:
  062f8	83 eb 04	 sub	 ebx, 4
  062fb	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  06303	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2022 : 				next;

  06305	e9 5c 9d ff ff	 jmp	 $L58091
$L59415:

; 2023 : 			/* ( -- ptr ) ( [float] x y z -- ) */
; 2024 : 			case ENCLOSINGREGION: {
; 2025 : 				double x, y, z;
; 2026 : 				z = flpop; y = flpop; x = flpop;

  0630a	dd 06		 fld	 QWORD PTR [esi]
  0630c	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  06310	83 c6 08	 add	 esi, 8
  06313	dd 5c 24 40	 fstp	 QWORD PTR _y$59417[esp+304]
  06317	dd 06		 fld	 QWORD PTR [esi]
  06319	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]

; 2027 : 				SAVE_XCONTEXT

  0631d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  06321	dd 5c 24 50	 fstp	 QWORD PTR _x$59416[esp+304]
  06325	dd 46 08	 fld	 QWORD PTR [esi+8]
  06328	83 c6 08	 add	 esi, 8
  0632b	83 eb 04	 sub	 ebx, 4
  0632e	83 c6 08	 add	 esi, 8
  06331	89 94 24 88 00
	00 00		 mov	 DWORD PTR _z$59418[esp+304], edx
  06338	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0633c	83 ee 08	 sub	 esi, 8
  0633f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _z$59418[esp+308], eax
  06346	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  0634a	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2028 : 				ascr = (u_char *)EnclosingDBRegion(x, y, z);

  0634c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR _z$59418[esp+308]
  06353	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  06359	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  0635f	dd 1e		 fstp	 QWORD PTR [esi]
  06361	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR _z$59418[esp+304]
  06368	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  0636d	8b 44 24 44	 mov	 eax, DWORD PTR _y$59417[esp+308]
  06371	51		 push	 ecx
  06372	8b 4c 24 44	 mov	 ecx, DWORD PTR _y$59417[esp+308]
  06376	52		 push	 edx
  06377	8b 54 24 5c	 mov	 edx, DWORD PTR _x$59416[esp+316]
  0637b	50		 push	 eax
  0637c	8b 44 24 5c	 mov	 eax, DWORD PTR _x$59416[esp+316]
  06380	51		 push	 ecx
  06381	52		 push	 edx
  06382	50		 push	 eax
  06383	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  06389	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0638f	e8 00 00 00 00	 call	 _EnclosingDBRegion
  06394	83 c4 18	 add	 esp, 24			; 00000018H

; 2029 : 				RESTORE_XCONTEXT
; 2030 : 				push(ascr);
; 2031 : 				next;

  06397	e9 7e 07 00 00	 jmp	 $L61959
$L59421:

; 2032 : 			}
; 2033 : 			/* ( regionptr -- firstregionptr ) */
; 2034 : 			case FIRSTOVERLAPPINGREGION:
; 2035 : 				ascr = apop;

  0639c	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2036 : 				SAVE_XCONTEXT

  0639e	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  063a2	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  063a6	89 0b		 mov	 DWORD PTR [ebx], ecx
  063a8	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  063ac	83 ee 08	 sub	 esi, 8
  063af	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  063b5	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  063bb	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  063bf	89 16		 mov	 DWORD PTR [esi], edx
  063c1	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  063c5	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2037 : 				ascr = (u_char *)FirstOverlappingDBRegion((Region *)ascr);

  063c8	50		 push	 eax
  063c9	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  063cf	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  063d5	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  063db	e8 00 00 00 00	 call	 _FirstOverlappingDBRegion
  063e0	83 c4 04	 add	 esp, 4

; 2038 : 				RESTORE_XCONTEXT
; 2039 : 				push(ascr);
; 2040 : 				next;

  063e3	e9 32 07 00 00	 jmp	 $L61959
$L59426:

; 2041 : 			/* ( regionptr -- nextregionptr ) */
; 2042 : 			case NEXTOVERLAPPINGREGION:
; 2043 : 				ascr = apop;

  063e8	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2044 : 				SAVE_XCONTEXT

  063ea	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  063ee	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  063f2	89 0b		 mov	 DWORD PTR [ebx], ecx
  063f4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  063f8	83 ee 08	 sub	 esi, 8
  063fb	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  06401	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  06407	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0640b	89 16		 mov	 DWORD PTR [esi], edx
  0640d	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  06411	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2045 : 				ascr = (u_char *)NextOverlappingDBRegion((Region *)ascr);

  06414	50		 push	 eax
  06415	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0641b	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  06421	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  06427	e8 00 00 00 00	 call	 _NextOverlappingDBRegion
  0642c	83 c4 04	 add	 esp, 4

; 2046 : 				RESTORE_XCONTEXT
; 2047 : 				push(ascr);
; 2048 : 				next;

  0642f	e9 e6 06 00 00	 jmp	 $L61959
$L59431:

; 2049 : 			/* ( cstr -- len ) */
; 2050 : 			case STRLEN:
; 2051 : 				tos = strlen((char *)tos);

  06434	8b 7c 24 0c	 mov	 edi, DWORD PTR _tos$[esp+304]
  06438	83 c9 ff	 or	 ecx, -1
  0643b	33 c0		 xor	 eax, eax
  0643d	f2 ae		 repne scasb
  0643f	f7 d1		 not	 ecx
  06441	49		 dec	 ecx
  06442	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2052 : 				next;

  06446	e9 17 9c ff ff	 jmp	 $L61884
$L59433:

; 2053 : 			/* ( src dest -- ) */
; 2054 : 			case STRCPY:
; 2055 : 				ascr1 = apop;	/* dest */

  0644b	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0644f	83 c3 04	 add	 ebx, 4
  06452	89 54 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], edx
  06456	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 2056 : 				ascr = apop;	/* src */

  06459	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2057 : 				strcpy(ascr1, ascr);

  0645b	8b f8		 mov	 edi, eax
  0645d	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  06461	83 c9 ff	 or	 ecx, -1
  06464	33 c0		 xor	 eax, eax
  06466	83 c3 04	 add	 ebx, 4
  06469	f2 ae		 repne scasb
  0646b	f7 d1		 not	 ecx
  0646d	2b f9		 sub	 edi, ecx
  0646f	8b c1		 mov	 eax, ecx
  06471	8b f7		 mov	 esi, edi
  06473	8b fa		 mov	 edi, edx
  06475	c1 e9 02	 shr	 ecx, 2
  06478	f3 a5		 rep movsd
  0647a	8b c8		 mov	 ecx, eax
  0647c	83 e1 03	 and	 ecx, 3
  0647f	f3 a4		 rep movsb

; 2058 : 				next;

  06481	e9 d8 9b ff ff	 jmp	 $L61881
$L59436:

; 2059 : 			/* ( cstr1 cstr2 -- diff ) */
; 2060 : 			case STRCMP:
; 2061 : 				ascr = apop;

  06486	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06488	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0648c	83 c3 04	 add	 ebx, 4

; 2062 : 				ascr1 = apop;

  0648f	89 4c 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], ecx
  06493	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2063 : 				push(strcmp(ascr, ascr1));

  06495	89 0b		 mov	 DWORD PTR [ebx], ecx
  06497	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ascr1$[esp+304]
  0649b	89 4c 24 2c	 mov	 DWORD PTR -260+[esp+304], ecx
$L61867:
  0649f	8a 10		 mov	 dl, BYTE PTR [eax]
  064a1	8b 4c 24 2c	 mov	 ecx, DWORD PTR -260+[esp+304]
  064a5	88 54 24 4f	 mov	 BYTE PTR -225+[esp+304], dl
  064a9	3a 11		 cmp	 dl, BYTE PTR [ecx]
  064ab	75 35		 jne	 SHORT $L61868
  064ad	8a ca		 mov	 cl, dl
  064af	84 c9		 test	 cl, cl
  064b1	74 24		 je	 SHORT $L61869
  064b3	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  064b6	8b 4c 24 2c	 mov	 ecx, DWORD PTR -260+[esp+304]
  064ba	88 54 24 4f	 mov	 BYTE PTR -225+[esp+304], dl
  064be	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  064c1	75 1f		 jne	 SHORT $L61868
  064c3	8b d1		 mov	 edx, ecx
  064c5	8a 4c 24 4f	 mov	 cl, BYTE PTR -225+[esp+304]
  064c9	83 c0 02	 add	 eax, 2
  064cc	83 c2 02	 add	 edx, 2
  064cf	84 c9		 test	 cl, cl
  064d1	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  064d5	75 c8		 jne	 SHORT $L61867
$L61869:
  064d7	33 c0		 xor	 eax, eax
  064d9	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2064 : 				next;

  064dd	e9 84 9b ff ff	 jmp	 $L58091
$L61868:

; 2063 : 				push(strcmp(ascr, ascr1));

  064e2	1b c0		 sbb	 eax, eax
  064e4	83 d8 ff	 sbb	 eax, -1
  064e7	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2064 : 				next;

  064eb	e9 76 9b ff ff	 jmp	 $L58091
$L59440:

; 2065 : 			/* ( cstr -- n ) */
; 2066 : 			case ATOI:
; 2067 : 				ascr = apop;

  064f0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  064f4	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2068 : 				push(atoi(ascr));

  064f6	50		 push	 eax
  064f7	89 0b		 mov	 DWORD PTR [ebx], ecx
  064f9	e8 00 00 00 00	 call	 _atoi
  064fe	83 c4 04	 add	 esp, 4
  06501	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2069 : 				next;

  06505	e9 5c 9b ff ff	 jmp	 $L58091
$L59443:

; 2070 : 			/* ( n cstr radix -- ) */
; 2071 : 			case ITOA: {
; 2072 : 				cell radix;
; 2073 : 				char *cstr;
; 2074 : 				radix = pop;

  0650a	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2075 : 				cstr = apop;

  0650c	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0650f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06513	83 c3 04	 add	 ebx, 4
  06516	83 c3 04	 add	 ebx, 4

; 2076 : 				scr = pop;

  06519	89 54 24 30	 mov	 DWORD PTR _scr$[esp+304], edx

; 2077 : 				(void)itoa((int)scr, cstr, (int)radix);

  0651d	50		 push	 eax
  0651e	8b 44 24 34	 mov	 eax, DWORD PTR _scr$[esp+308]
  06522	8b 13		 mov	 edx, DWORD PTR [ebx]
  06524	51		 push	 ecx
  06525	50		 push	 eax
  06526	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  0652a	83 c3 04	 add	 ebx, 4
  0652d	e8 00 00 00 00	 call	 _itoa
  06532	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2078 : 			} next;

  06535	e9 2c 9b ff ff	 jmp	 $L58091
$L59450:

; 2079 : 			/* ( cstr -- ) ( [float] -- n ) */
; 2080 : 			case ATOF:
; 2081 : 				ascr = apop;

  0653a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0653c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2082 : 				flpush(atof(ascr));

  06540	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  06544	83 ee 08	 sub	 esi, 8
  06547	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  0654b	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  0654f	89 16		 mov	 DWORD PTR [esi], edx
  06551	50		 push	 eax
  06552	83 c3 04	 add	 ebx, 4
  06555	89 74 24 28	 mov	 DWORD PTR _fsp$[esp+308], esi
  06559	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0655c	e8 00 00 00 00	 call	 _atof
  06561	dd 5c 24 14	 fstp	 QWORD PTR _ftos$[esp+308]
  06565	83 c4 04	 add	 esp, 4

; 2083 : 				next;

  06568	e9 f9 9a ff ff	 jmp	 $L58091
$L59452:

; 2084 : 			/* ( cstr -- ) ( [float] n -- ) */
; 2085 : 			case FTOA:
; 2086 : 				ascr = apop;

  0656d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0656f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2087 : 				ftemp = flpop;

  06573	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  06577	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  0657b	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0657f	89 4c 24 60	 mov	 DWORD PTR _ftemp$[esp+304], ecx
  06583	89 54 24 64	 mov	 DWORD PTR _ftemp$[esp+308], edx
  06587	8b 0e		 mov	 ecx, DWORD PTR [esi]
  06589	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0658c	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx

; 2088 : 				sprintf(ascr, "%f", ftemp);

  06590	8b 4c 24 64	 mov	 ecx, DWORD PTR _ftemp$[esp+308]
  06594	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  06598	8b 54 24 60	 mov	 edx, DWORD PTR _ftemp$[esp+304]
  0659c	51		 push	 ecx
  0659d	52		 push	 edx
  0659e	83 c6 08	 add	 esi, 8
  065a1	68 00 00 00 00	 push	 OFFSET FLAT:$SG59454
  065a6	50		 push	 eax
  065a7	83 c3 04	 add	 ebx, 4
  065aa	89 74 24 34	 mov	 DWORD PTR _fsp$[esp+320], esi
  065ae	e8 00 00 00 00	 call	 _sprintf

; 2409 : 							free(rq);

  065b3	83 c4 10	 add	 esp, 16			; 00000010H

; 2410 : 							next;

  065b6	e9 ab 9a ff ff	 jmp	 $L58091
$L59455:

; 2089 : 				next;
; 2090 : 			/* ( n1 n2 --- n1 ) If n1 <> n2 */
; 2091 : 			/* ( n1 n2 -- ) If n1 = n2 */
; 2092 : 			case POF:
; 2093 : 				scr = pop;

  065bb	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  065bf	8b 03		 mov	 eax, DWORD PTR [ebx]
  065c1	83 c3 04	 add	 ebx, 4

; 2094 : 				if (tos == scr) {

  065c4	3b c1		 cmp	 eax, ecx
  065c6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  065ca	0f 85 d0 c7 ff
	ff		 jne	 $L59456

; 2095 : 					tos = *sp++;

  065d0	8b 03		 mov	 eax, DWORD PTR [ebx]
  065d2	83 c3 04	 add	 ebx, 4
  065d5	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2096 : 					/* Pointer alignment */
; 2097 : 					ip = (token_t *)(((char *)ip) + sizeof(cell));

  065d9	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  065dc	83 c0 04	 add	 eax, 4
  065df	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2098 : 					next;

  065e2	e9 7f 9a ff ff	 jmp	 $L58091
$L59461:

; 2099 : 				}
; 2100 : 				branch;
; 2101 : 				next;
; 2102 : 			/* ( addr1 addr2 -- addr1 ) If string1 <> string2 */
; 2103 : 			/* ( addr1 addr2 -- ) If string1 = string2 */
; 2104 : 			case PSOF:
; 2105 : 				scr = pop;

  065e7	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  065eb	8b 03		 mov	 eax, DWORD PTR [ebx]
  065ed	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  065f1	83 c3 04	 add	 ebx, 4

; 2106 : 				if (!strcmp((char *)tos, (char *)scr)) {

  065f4	89 4c 24 2c	 mov	 DWORD PTR -260+[esp+304], ecx
$L61871:
  065f8	8a 08		 mov	 cl, BYTE PTR [eax]
  065fa	8b 54 24 2c	 mov	 edx, DWORD PTR -260+[esp+304]
  065fe	88 4c 24 4f	 mov	 BYTE PTR -225+[esp+304], cl
  06602	3a 0a		 cmp	 cl, BYTE PTR [edx]
  06604	75 22		 jne	 SHORT $L61872
  06606	84 c9		 test	 cl, cl
  06608	74 1a		 je	 SHORT $L61873
  0660a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0660d	88 4c 24 4f	 mov	 BYTE PTR -225+[esp+304], cl
  06611	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  06614	75 12		 jne	 SHORT $L61872
  06616	83 c0 02	 add	 eax, 2
  06619	83 c2 02	 add	 edx, 2
  0661c	84 c9		 test	 cl, cl
  0661e	89 54 24 2c	 mov	 DWORD PTR -260+[esp+304], edx
  06622	75 d4		 jne	 SHORT $L61871
$L61873:
  06624	33 c0		 xor	 eax, eax
  06626	eb 05		 jmp	 SHORT $L61874
$L61872:
  06628	1b c0		 sbb	 eax, eax
  0662a	83 d8 ff	 sbb	 eax, -1
$L61874:
  0662d	85 c0		 test	 eax, eax
  0662f	0f 85 6b c7 ff
	ff		 jne	 $L59456

; 2107 : 					tos = *sp++;

  06635	8b 03		 mov	 eax, DWORD PTR [ebx]
  06637	83 c3 04	 add	 ebx, 4
  0663a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2108 : 					/* Pointer alignment */
; 2109 : 					ip = (token_t *)(((char *)ip) + sizeof(cell));

  0663e	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  06641	83 c0 04	 add	 eax, 4
  06644	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2110 : 					next;

  06647	e9 1a 9a ff ff	 jmp	 $L58091
$L59469:

; 2111 : 				}
; 2112 : 				branch;
; 2113 : 				next;
; 2114 : 			/* ("s) -- leave pascal-string addr */
; 2115 : 			case PQUOTES:
; 2116 : 				push(ip);		/* Push address */

  0664c	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06650	83 eb 04	 sub	 ebx, 4

; 2117 : 				ip =	aligned((u_char *)ip + *(u_char *)ip + 2);

  06653	33 c9		 xor	 ecx, ecx
  06655	89 03		 mov	 DWORD PTR [ebx], eax
  06657	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  0665a	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  0665e	8a 08		 mov	 cl, BYTE PTR [eax]
  06660	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  06664	83 e2 fc	 and	 edx, -4			; fffffffcH
  06667	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx

; 2118 : 				next;

  0666a	e9 f7 99 ff ff	 jmp	 $L58091
$L59473:

; 2119 : 			/* (") -- leave pascal-string addr+1 and length */
; 2120 : 			case PQUOTE:
; 2121 : 				push((cell)ip + 1);		/* Push address */

  0666f	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06673	8b 4d 08	 mov	 ecx, DWORD PTR _ip$[ebp]
  06676	83 eb 04	 sub	 ebx, 4
  06679	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0667c	89 03		 mov	 DWORD PTR [ebx], eax

; 2122 : 				push(*(unsigned char *)ip);

  0667e	83 eb 04	 sub	 ebx, 4
  06681	33 c0		 xor	 eax, eax
  06683	89 13		 mov	 DWORD PTR [ebx], edx
  06685	8a 01		 mov	 al, BYTE PTR [ecx]
  06687	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2123 : #ifdef REMOVE
; 2124 : 				ip =	(token_t *)(
; 2125 : 						(char *)ip + 			/* Current address */
; 2126 : 						( *(unsigned char *)ip + /* Plus length of string */
; 2127 : 						+ 2						/* One len byte and one null */
; 2128 : 						+ sizeof(cell) & ~(sizeof(cell) - 1) ) );/* align */
; 2129 : #else
; 2130 : 				ip =	aligned((u_char *)ip + *(u_char *)ip + 2);

  0668b	8d 44 08 05	 lea	 eax, DWORD PTR [eax+ecx+5]
  0668f	24 fc		 and	 al, -4			; fffffffcH
  06691	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2131 : #endif
; 2132 : 				next;

  06694	e9 cd 99 ff ff	 jmp	 $L58091
$L59480:

; 2133 : 			/* (c") -- leave C-string addr */
; 2134 : 			case PCQUOTE:
; 2135 : 				push((cell)ip + 1);				/* Push address */

  06699	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0669d	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  066a0	83 eb 04	 sub	 ebx, 4
  066a3	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  066a6	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2136 : #ifdef REMOVE
; 2137 : 				ip =	(token_t *)(
; 2138 : 						(char *)ip + 			/* Current address */
; 2139 : 						( *(unsigned char *)ip + /* Plus length of string */
; 2140 : 						+ 2						/* One len byte and one null */
; 2141 : 						+ sizeof(cell) & ~(sizeof(cell) - 1) ) );/* align */
; 2142 : #else
; 2143 : 				ip =	aligned((u_char *)ip + *(u_char *)ip + 2);

  066a8	33 c9		 xor	 ecx, ecx
  066aa	8a 08		 mov	 cl, BYTE PTR [eax]
  066ac	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  066b0	8d 54 01 05	 lea	 edx, DWORD PTR [ecx+eax+5]
  066b4	83 e2 fc	 and	 edx, -4			; fffffffcH
  066b7	89 55 08	 mov	 DWORD PTR _ip$[ebp], edx

; 2144 : #endif
; 2145 : 				next;

  066ba	e9 a7 99 ff ff	 jmp	 $L58091
$L59485:

; 2146 : 
; 2147 : 			/* OPENURLASFILE opens a file whose location is described by the URL
; 2148 : 			 * that cstrURL points to.  cstrURL is a pointer to a cstring containing
; 2149 : 			 * the URL.  fnamestrbuffptr is a pointer to an array that can hold the
; 2150 : 			 * cstring pathname of the local copy of the file, which is created in
; 2151 : 			 * MEMETMP directory.  If the file can't be opened, fnamestrbuff contains
; 2152 : 			 * a null string.
; 2153 : 			 * If the URL specifies a remote host and the network interface is disabled,
; 2154 : 			 * the call always fails.
; 2155 : 			 */
; 2156 : 			/* cstrURL fnamestrbuffptr -- */
; 2157 : 			case OPENURLASFILE: {
; 2158 : 				char *filename;
; 2159 : 				char *destname;
; 2160 : 				RFRequest *rq;
; 2161 : 				destname = (char *)pop;

  066bf	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  066c3	8b 03		 mov	 eax, DWORD PTR [ebx]
  066c5	83 c3 04	 add	 ebx, 4

; 2162 : 				
; 2163 : 				if (destname != (char *)-1) { /* First time, try to open URL */

  066c8	83 f9 ff	 cmp	 ecx, -1
  066cb	89 4c 24 30	 mov	 DWORD PTR _destname$59487[esp+304], ecx
  066cf	74 43		 je	 SHORT $L59491

; 2164 : 					filename = (char *)pop;

  066d1	89 44 24 40	 mov	 DWORD PTR _filename$59486[esp+304], eax
  066d5	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2165 : 					rq = malloc(sizeof(RFRequest));

  066d7	68 10 01 00 00	 push	 272			; 00000110H
  066dc	89 44 24 10	 mov	 DWORD PTR _tos$[esp+308], eax
  066e0	83 c3 04	 add	 ebx, 4
  066e3	e8 00 00 00 00	 call	 _malloc
  066e8	83 c4 04	 add	 esp, 4
  066eb	89 44 24 2c	 mov	 DWORD PTR _rq$59488[esp+304], eax

; 2166 : 					if (!rq) {

  066ef	85 c0		 test	 eax, eax
  066f1	75 0b		 jne	 SHORT $L59494

; 2167 : 						*destname = '\0';

  066f3	8b 4c 24 30	 mov	 ecx, DWORD PTR _destname$59487[esp+304]
  066f7	88 01		 mov	 BYTE PTR [ecx], al

; 2168 : 						next;

  066f9	e9 68 99 ff ff	 jmp	 $L58091
$L59494:

; 2169 : 					}
; 2170 : 					OpenURL(filename, rq, rfrqFILE);

  066fe	8b 54 24 2c	 mov	 edx, DWORD PTR _rq$59488[esp+304]
  06702	8b 44 24 40	 mov	 eax, DWORD PTR _filename$59486[esp+304]
  06706	6a 00		 push	 0
  06708	52		 push	 edx
  06709	50		 push	 eax
  0670a	e8 00 00 00 00	 call	 _OpenURL
  0670f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2171 : 				} else {						/* We're idling */

  06712	eb 1f		 jmp	 SHORT $L59495
$L59491:

; 2172 : 					rq = (RFRequest *)pop;

  06714	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06716	83 c3 04	 add	 ebx, 4

; 2173 : 					destname = (char *)pop;

  06719	89 4c 24 30	 mov	 DWORD PTR _destname$59487[esp+304], ecx

; 2174 : 					WaitURL(rq);

  0671d	50		 push	 eax
  0671e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06720	89 44 24 30	 mov	 DWORD PTR _rq$59488[esp+308], eax
  06724	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  06728	83 c3 04	 add	 ebx, 4
  0672b	e8 00 00 00 00	 call	 _WaitURL
  06730	83 c4 04	 add	 esp, 4
$L59495:

; 2175 : 				}
; 2176 : 				if (rq->status == rfrSUCCESS) {	/* File opened */

  06733	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59488[esp+304]
  06737	8b 01		 mov	 eax, DWORD PTR [ecx]
  06739	85 c0		 test	 eax, eax
  0673b	75 30		 jne	 SHORT $L59498

; 2177 : 					strcpy(destname, rq->tmpname);

  0673d	8b d1		 mov	 edx, ecx
  0673f	83 c9 ff	 or	 ecx, -1

; 2178 : 					free(rq);

  06742	52		 push	 edx
  06743	8d 7a 10	 lea	 edi, DWORD PTR [edx+16]
  06746	f2 ae		 repne scasb
  06748	f7 d1		 not	 ecx
  0674a	2b f9		 sub	 edi, ecx
  0674c	8b c1		 mov	 eax, ecx
  0674e	8b f7		 mov	 esi, edi
  06750	8b 7c 24 34	 mov	 edi, DWORD PTR _destname$59487[esp+308]
  06754	c1 e9 02	 shr	 ecx, 2
  06757	f3 a5		 rep movsd
  06759	8b c8		 mov	 ecx, eax
  0675b	83 e1 03	 and	 ecx, 3
  0675e	f3 a4		 rep movsb
  06760	e8 00 00 00 00	 call	 _free
  06765	83 c4 04	 add	 esp, 4

; 2179 : 					next;

  06768	e9 f1 98 ff ff	 jmp	 $L61881
$L59498:

; 2180 : 				}
; 2181 : 				if (rq->status == rfrFAILURE) {	/* Request failed */

  0676d	83 f8 01	 cmp	 eax, 1
  06770	75 19		 jne	 SHORT $L59499

; 2182 : 					*destname = '\0';

  06772	8b 4c 24 30	 mov	 ecx, DWORD PTR _destname$59487[esp+304]

; 2183 : 					free(rq);

  06776	8b 54 24 2c	 mov	 edx, DWORD PTR _rq$59488[esp+304]
  0677a	52		 push	 edx
  0677b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0677e	e8 00 00 00 00	 call	 _free
  06783	83 c4 04	 add	 esp, 4

; 2184 : 					next;

  06786	e9 db 98 ff ff	 jmp	 $L58091
$L59499:

; 2185 : 				}
; 2186 : 				if (rq->status == rfrPENDING) {	/* Request pending */

  0678b	83 f8 ff	 cmp	 eax, -1
  0678e	75 49		 jne	 SHORT $L59500

; 2187 : 					push(destname);

  06790	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2188 : 					push(rq);

  06794	8b 54 24 30	 mov	 edx, DWORD PTR _destname$59487[esp+304]
  06798	83 eb 04	 sub	 ebx, 4

; 2189 : 					push((cell)-1);

  0679b	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  067a3	89 03		 mov	 DWORD PTR [ebx], eax

; 2190 : 					--ip;

  067a5	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  067a8	83 eb 04	 sub	 ebx, 4
  067ab	83 e8 04	 sub	 eax, 4
  067ae	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  067b1	89 13		 mov	 DWORD PTR [ebx], edx
  067b3	83 eb 04	 sub	 ebx, 4
  067b6	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2191 : 					if (*ip == EXECUTE) {

  067b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  067ba	83 f9 34	 cmp	 ecx, 52			; 00000034H
  067bd	0f 85 70 0a 00
	00		 jne	 $pause$58247

; 2192 : 						push(OPENURLASFILE);

  067c3	83 eb 04	 sub	 ebx, 4
  067c6	c7 44 24 0c 6a
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 362 ; 0000016aH
  067ce	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 2193 : 					}
; 2194 : 					goto pause;

  067d4	e9 5a 0a 00 00	 jmp	 $pause$58247
$L59500:

; 2195 : 				}
; 2196 : 			}
; 2197 : 
; 2198 : 			/* OPENURLASBUFFER opens a file whose location is described by the URL
; 2199 : 			 * that cstrURL points to.  cstrURL is a pointer to a cstring containing
; 2200 : 			 * the URL.  msgptr is a pointer to a malloc'd buffer that contains the file.
; 2201 : 			 * If the open fails then msgptr is NULL.
; 2202 : 			 * If the URL specifies a remote host and the network interface is disabled,
; 2203 : 			 * the call always fails.
; 2204 : 			 */
; 2205 : 			/* cstrURL -- msgptr */
; 2206 : 			case OPENURLASBUFFER: {
; 2207 : 				char *filename;
; 2208 : 				RFRequest *rq;
; 2209 : 				filename = (char *)pop;

  067d9	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  067dd	8b 03		 mov	 eax, DWORD PTR [ebx]
  067df	83 c3 04	 add	 ebx, 4

; 2210 : 				
; 2211 : 				if (filename != (char *)-1) { /* First time, try to open URL */

  067e2	83 f9 ff	 cmp	 ecx, -1
  067e5	89 4c 24 40	 mov	 DWORD PTR _filename$59508[esp+304], ecx
  067e9	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  067ed	74 41		 je	 SHORT $L59512

; 2212 : 					rq = malloc(sizeof(RFRequest));

  067ef	68 10 01 00 00	 push	 272			; 00000110H
  067f4	e8 00 00 00 00	 call	 _malloc
  067f9	83 c4 04	 add	 esp, 4
  067fc	89 44 24 2c	 mov	 DWORD PTR _rq$59509[esp+304], eax

; 2213 : 					if (!rq) {

  06800	85 c0		 test	 eax, eax
  06802	75 16		 jne	 SHORT $L59514
$L59095:

; 2214 : 						push(0);

  06804	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06808	83 eb 04	 sub	 ebx, 4
  0680b	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  06813	89 03		 mov	 DWORD PTR [ebx], eax

; 2215 : 						next;

  06815	e9 4c 98 ff ff	 jmp	 $L58091
$L59514:

; 2216 : 					}
; 2217 : 					OpenURL(filename, rq, rfrqBUFFER);

  0681a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59509[esp+304]
  0681e	8b 54 24 40	 mov	 edx, DWORD PTR _filename$59508[esp+304]
  06822	6a 01		 push	 1
  06824	51		 push	 ecx
  06825	52		 push	 edx
  06826	e8 00 00 00 00	 call	 _OpenURL
  0682b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2218 : 
; 2219 : 				} else {						/* We're idling */

  0682e	eb 16		 jmp	 SHORT $L59516
$L59512:

; 2220 : 					rq = (RFRequest *)pop;

  06830	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2221 : 					WaitURL(rq);

  06832	50		 push	 eax
  06833	89 44 24 30	 mov	 DWORD PTR _rq$59509[esp+308], eax
  06837	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  0683b	83 c3 04	 add	 ebx, 4
  0683e	e8 00 00 00 00	 call	 _WaitURL
  06843	83 c4 04	 add	 esp, 4
$L59516:

; 2222 : 				}
; 2223 : 				if (rq->status == rfrSUCCESS) {	/* File opened */

  06846	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59509[esp+304]
  0684a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0684c	85 c0		 test	 eax, eax
  0684e	75 22		 jne	 SHORT $L59518

; 2224 : 					push(rq->buff);

  06850	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  06854	8b 44 24 2c	 mov	 eax, DWORD PTR _rq$59509[esp+304]
  06858	83 eb 04	 sub	 ebx, 4

; 2225 : 					free(rq);

  0685b	50		 push	 eax
  0685c	89 13		 mov	 DWORD PTR [ebx], edx
  0685e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  06861	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  06865	e8 00 00 00 00	 call	 _free
  0686a	83 c4 04	 add	 esp, 4

; 2226 : 					next;

  0686d	e9 f4 97 ff ff	 jmp	 $L58091
$L59518:

; 2227 : 				}
; 2228 : 				if (rq->status == rfrFAILURE) {	/* Request failed */

  06872	83 f8 01	 cmp	 eax, 1
  06875	75 23		 jne	 SHORT $L59520

; 2229 : 					push(0);
; 2230 : 					free(rq);

  06877	8b 44 24 2c	 mov	 eax, DWORD PTR _rq$59509[esp+304]
  0687b	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  0687f	83 eb 04	 sub	 ebx, 4
  06882	50		 push	 eax
  06883	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+308], 0
  0688b	89 13		 mov	 DWORD PTR [ebx], edx
  0688d	e8 00 00 00 00	 call	 _free
  06892	83 c4 04	 add	 esp, 4

; 2231 : 					next;

  06895	e9 cc 97 ff ff	 jmp	 $L58091
$L59520:

; 2232 : 				}
; 2233 : 				if (rq->status == rfrPENDING) {	/* Request pending */

  0689a	83 f8 ff	 cmp	 eax, -1
  0689d	75 3a		 jne	 SHORT $L59522

; 2234 : 					push(rq);

  0689f	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  068a3	83 eb 04	 sub	 ebx, 4

; 2235 : 					push((cell)-1);

  068a6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2236 : 					--ip;

  068aa	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  068ad	89 13		 mov	 DWORD PTR [ebx], edx
  068af	83 eb 04	 sub	 ebx, 4
  068b2	83 e8 04	 sub	 eax, 4
  068b5	89 0b		 mov	 DWORD PTR [ebx], ecx
  068b7	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2237 : 					if (*ip == EXECUTE) {

  068ba	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  068bd	0f 85 70 09 00
	00		 jne	 $pause$58247

; 2238 : 						push(OPENURLASBUFFER);

  068c3	83 eb 04	 sub	 ebx, 4
  068c6	c7 44 24 0c 6b
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 363 ; 0000016bH
  068ce	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 2239 : 					}
; 2240 : 					goto pause;

  068d4	e9 5a 09 00 00	 jmp	 $pause$58247
$L59522:

; 2241 : 				}
; 2242 : 				/* If we get here we have a bogus value for rq->status */
; 2243 : 				rq = rq; //  A place to breakpoint
; 2244 : 			}
; 2245 : 			/* cstr -- */
; 2246 : 			case CTYPE:
; 2247 : 				ascr = apop; SAVE_XCONTEXT cprint(ascr); RESTORE_XCONTEXT next;

  068d9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  068db	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  068df	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  068e3	89 0b		 mov	 DWORD PTR [ebx], ecx
  068e5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  068e9	83 ee 08	 sub	 esi, 8
  068ec	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  068f2	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  068f8	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  068fc	89 16		 mov	 DWORD PTR [esi], edx
  068fe	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  06902	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  06905	50		 push	 eax
  06906	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0690c	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  06912	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  06918	e8 00 00 00 00	 call	 _cprint
  0691d	83 c4 04	 add	 esp, 4
  06920	e9 4f 07 00 00	 jmp	 $L61693
$L59530:

; 2248 : 			/* offset -- */
; 2249 : 			/* [float] -- value */
; 2250 : 			case GETFLOC:
; 2251 : 				scr = pop;

  06925	8b 13		 mov	 edx, DWORD PTR [ebx]

; 2252 : 				flpush(*(double *)&frp[scr]);

  06927	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  0692b	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0692f	83 c3 04	 add	 ebx, 4
  06932	83 ee 08	 sub	 esi, 8
  06935	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  06939	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0693d	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  06941	89 0e		 mov	 DWORD PTR [esi], ecx
  06943	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  06947	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0694a	dd 04 81	 fld	 QWORD PTR [ecx+eax*4]
  0694d	dd 5c 24 10	 fstp	 QWORD PTR _ftos$[esp+304]

; 2253 : 				next;

  06951	e9 10 97 ff ff	 jmp	 $L58091
$L59532:

; 2254 : 			/* offset -- */
; 2255 : 			/* [float] value -- */
; 2256 : 			case SETFLOC:
; 2257 : 				scr = pop;

  06956	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2258 : 				*(double *)&frp[scr] = flpop;

  0695a	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  0695e	dd 44 24 10	 fld	 QWORD PTR _ftos$[esp+304]
  06962	8b 13		 mov	 edx, DWORD PTR [ebx]
  06964	83 c3 04	 add	 ebx, 4
  06967	dd 1c 81	 fstp	 QWORD PTR [ecx+eax*4]
  0696a	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
$L60690:
  0696e	8b 16		 mov	 edx, DWORD PTR [esi]
  06970	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  06973	83 c6 08	 add	 esi, 8
  06976	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  0697a	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  0697e	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi

; 2259 : 				next;

  06982	e9 df 96 ff ff	 jmp	 $L58091
$L59534:

; 2260 : 			/* wrap materialptr -- */
; 2261 : 			case MATERIALWRAP:
; 2262 : 				ascr = apop;

  06987	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06989	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2263 : 				scr = pop;

  0698d	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  06990	83 c3 04	 add	 ebx, 4

; 2264 : 				MatWrap(ascr, scr);

  06993	51		 push	 ecx
  06994	50		 push	 eax
  06995	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  06999	83 c3 04	 add	 ebx, 4
  0699c	e8 00 00 00 00	 call	 _MatWrap

; 2416 : 							free(rq);

  069a1	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  069a4	e9 bd 96 ff ff	 jmp	 $L58091
$L59536:

; 2265 : 				next;
; 2266 : 			/* objptr -- */
; 2267 : 			/* [float] r g b -- */
; 2268 : 			case LIGHTCOLOR: {
; 2269 : 				double r, g, b;
; 2270 : 				b = flpop; g = flpop; r = flpop;

  069a9	dd 06		 fld	 QWORD PTR [esi]
  069ab	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  069af	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  069b3	dd 5c 24 40	 fstp	 QWORD PTR _g$59538[esp+304]
  069b7	dd 46 08	 fld	 QWORD PTR [esi+8]
  069ba	83 c6 08	 add	 esi, 8
  069bd	89 84 24 90 00
	00 00		 mov	 DWORD PTR _b$59539[esp+304], eax
  069c4	83 c6 08	 add	 esi, 8
  069c7	89 8c 24 94 00
	00 00		 mov	 DWORD PTR _b$59539[esp+308], ecx

; 2271 : 				ascr = apop;

  069ce	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  069d0	83 c3 04	 add	 ebx, 4
  069d3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  069d6	8b 16		 mov	 edx, DWORD PTR [esi]
  069d8	dd 5c 24 50	 fstp	 QWORD PTR _r$59537[esp+304]
  069dc	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  069e0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  069e4	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx

; 2272 : 				MemeLightColor((Object *)ascr, r, g, b);

  069e8	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR _b$59539[esp+308]
  069ef	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  069f3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _b$59539[esp+304]
  069fa	52		 push	 edx
  069fb	8b 54 24 48	 mov	 edx, DWORD PTR _g$59538[esp+312]
  069ff	51		 push	 ecx
  06a00	8b 4c 24 48	 mov	 ecx, DWORD PTR _g$59538[esp+312]
  06a04	52		 push	 edx
  06a05	8b 54 24 60	 mov	 edx, DWORD PTR _r$59537[esp+320]
  06a09	51		 push	 ecx
  06a0a	8b 4c 24 60	 mov	 ecx, DWORD PTR _r$59537[esp+320]
  06a0e	52		 push	 edx
  06a0f	83 c6 08	 add	 esi, 8
  06a12	51		 push	 ecx
  06a13	50		 push	 eax
  06a14	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  06a18	e8 00 00 00 00	 call	 _MemeLightColor
  06a1d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2273 : 			} next;

  06a20	e9 41 96 ff ff	 jmp	 $L58091
$L59542:

; 2274 : 			/* objptr -- */
; 2275 : 			/* [float] umbra penumbra -- */
; 2276 : 			case LIGHTCONEANGLE: {
; 2277 : 				double umbra, penumbra;
; 2278 : 				penumbra = flpop; umbra = flpop; ascr = apop; 

  06a25	dd 06		 fld	 QWORD PTR [esi]
  06a27	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  06a2b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  06a2e	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  06a32	83 c6 08	 add	 esi, 8
  06a35	dd 5c 24 40	 fstp	 QWORD PTR _umbra$59543[esp+304]
  06a39	89 94 24 a0 00
	00 00		 mov	 DWORD PTR _penumbra$59544[esp+304], edx
  06a40	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  06a43	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  06a47	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06a49	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _penumbra$59544[esp+308], eax
  06a50	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06a54	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx

; 2279 : 				MemeLightConeAngle((Object *)ascr, umbra, penumbra);

  06a58	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR _penumbra$59544[esp+308]
  06a5f	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  06a63	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _penumbra$59544[esp+304]
  06a6a	52		 push	 edx
  06a6b	8b 54 24 48	 mov	 edx, DWORD PTR _umbra$59543[esp+312]
  06a6f	51		 push	 ecx
  06a70	8b 4c 24 48	 mov	 ecx, DWORD PTR _umbra$59543[esp+312]
  06a74	52		 push	 edx
  06a75	83 c6 08	 add	 esi, 8
  06a78	51		 push	 ecx
  06a79	50		 push	 eax
  06a7a	89 74 24 38	 mov	 DWORD PTR _fsp$[esp+324], esi
  06a7e	83 c3 04	 add	 ebx, 4
  06a81	e8 00 00 00 00	 call	 _MemeLightConeAngle
  06a86	83 c4 14	 add	 esp, 20			; 00000014H

; 2280 : 			} next;

  06a89	e9 d8 95 ff ff	 jmp	 $L58091
$L59547:

; 2281 : 			/* cstringptr -- ip-in-host-byte-order */
; 2282 : 			case NETGETHOSTBYNAME:
; 2283 : 				ascr = apop;

  06a8e	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06a92	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2284 : 				push(NetName2HostID(ascr));

  06a94	50		 push	 eax
  06a95	89 0b		 mov	 DWORD PTR [ebx], ecx
  06a97	e8 00 00 00 00	 call	 _NetName2HostID
  06a9c	83 c4 04	 add	 esp, 4
  06a9f	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2285 : 				next;

  06aa3	e9 be 95 ff ff	 jmp	 $L58091
$L59550:

; 2286 : 			/* msockptr -- newsockptr<or>statusvalue */
; 2287 : 			case NETACCEPTED:
; 2288 : 				tos = NetAccepted((void *)tos);

  06aa8	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  06aac	52		 push	 edx
  06aad	e8 00 00 00 00	 call	 _NetAccepted
  06ab2	83 c4 04	 add	 esp, 4
  06ab5	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2289 : 				next;

  06ab9	e9 a8 95 ff ff	 jmp	 $L58091
$L59552:

; 2290 : 			/* msockptr flags timeout -- errcode */
; 2291 : 			case NETDISPATCH:
; 2292 : 				scr = pop;

  06abe	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06ac0	83 c3 04	 add	 ebx, 4

; 2293 : 				scr2 = pop;

  06ac3	89 4c 24 6c	 mov	 DWORD PTR _scr2$[esp+304], ecx
  06ac7	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06acb	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2294 : 				ascr = apop;

  06acd	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  06ad0	83 c3 04	 add	 ebx, 4

; 2295 : 				SAVE_XCONTEXT

  06ad3	83 ee 08	 sub	 esi, 8

; 2296 : 				scr = NetDispatch(ascr, scr2, scr);

  06ad6	50		 push	 eax
  06ad7	89 13		 mov	 DWORD PTR [ebx], edx
  06ad9	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  06add	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  06ae3	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  06ae7	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  06aed	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  06af1	89 16		 mov	 DWORD PTR [esi], edx
  06af3	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  06af7	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  06afa	8b 44 24 70	 mov	 eax, DWORD PTR _scr2$[esp+308]
  06afe	50		 push	 eax
  06aff	51		 push	 ecx
  06b00	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  06b06	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  06b0c	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  06b12	e8 00 00 00 00	 call	 _NetDispatch
$L61963:
  06b17	83 c4 0c	 add	 esp, 12			; 0000000cH
$L61959:

; 2297 : 				RESTORE_XCONTEXT

  06b1a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  06b20	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  06b26	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  06b2c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  06b32	8b 16		 mov	 edx, DWORD PTR [esi]
  06b34	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  06b38	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  06b3b	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  06b3f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  06b45	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  06b49	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06b4b	83 c6 08	 add	 esi, 8
  06b4e	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  06b52	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  06b56	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx

; 2298 : 				push(scr);

  06b5a	89 0b		 mov	 DWORD PTR [ebx], ecx
  06b5c	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2299 : 				next;

  06b60	e9 01 95 ff ff	 jmp	 $L58091
$L59555:

; 2300 : 			/* -- floatstkptr */
; 2301 : 			case FPFETCH:
; 2302 : 				push(fsp);

  06b65	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06b69	83 eb 04	 sub	 ebx, 4
  06b6c	89 74 24 0c	 mov	 DWORD PTR _tos$[esp+304], esi
  06b70	89 03		 mov	 DWORD PTR [ebx], eax

; 2303 : 				next;

  06b72	e9 ef 94 ff ff	 jmp	 $L58091
$L59557:

; 2304 : 			/* -- frameptr */
; 2305 : 			case FRPFETCH:
; 2306 : 				push(frp);

  06b77	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  06b7b	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  06b7f	83 eb 04	 sub	 ebx, 4
  06b82	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  06b86	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2307 : 				next;

  06b88	e9 d9 94 ff ff	 jmp	 $L58091
$L59559:

; 2308 : 			/* errnum -- */
; 2309 : 			case SETLASTERROR:
; 2310 : 				V_ERRNO = pop;

  06b8d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06b91	83 c3 04	 add	 ebx, 4
  06b94	89 47 4c	 mov	 DWORD PTR [edi+76], eax
  06b97	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]
  06b9a	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2311 : 				next;

  06b9e	e9 c3 94 ff ff	 jmp	 $L58091
$L59560:

; 2312 : 			/* bufaddr -- */
; 2313 : 			case GETCWD:
; 2314 : 				ascr = apop;

  06ba3	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06ba7	8b 13		 mov	 edx, DWORD PTR [ebx]

; 2315 : 				if (getcwd((char *)ascr, 256) == NULL) *(char *)ascr = '\0';

  06ba9	68 00 01 00 00	 push	 256			; 00000100H
  06bae	50		 push	 eax
  06baf	89 44 24 3c	 mov	 DWORD PTR _ascr$[esp+312], eax
  06bb3	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  06bb7	83 c3 04	 add	 ebx, 4
  06bba	e8 00 00 00 00	 call	 _getcwd
  06bbf	83 c4 08	 add	 esp, 8
  06bc2	85 c0		 test	 eax, eax
  06bc4	0f 85 98 94 ff
	ff		 jne	 $L61884
  06bca	8b 44 24 34	 mov	 eax, DWORD PTR _ascr$[esp+304]
  06bce	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2316 : 				next;

  06bd1	e9 90 94 ff ff	 jmp	 $L58091
$L59566:

; 2317 : 			/* -- addr */
; 2318 : 			case MAINTASKRCVR:
; 2319 : 				push(&maintaskReceiver);

  06bd6	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  06bda	83 eb 04	 sub	 ebx, 4
  06bdd	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], OFFSET FLAT:_maintaskReceiver
  06be5	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2320 : 				next;

  06be7	e9 7a 94 ff ff	 jmp	 $L58091
$L59568:

; 2321 : 			/* cstringtexfilename cstringmaskfilename -- textureptr */
; 2322 : 			case NEWMASKEDTEXTURE: {
; 2323 : 				char *texname;						/* Texture file name or URL */
; 2324 : 				char *maskname;						/* Mask file name or URL */
; 2325 : 				char *texlocalname;					/* Texture file name in the cache */
; 2326 : 				cell tp;							/* Texture pointer returned from MemeMaskedTexture */
; 2327 : 				RFRequest *rq;						/* Remote file request struct */
; 2328 : 				cell statenum;						/* State # */
; 2329 : 
; 2330 : 				switch (tos) {

  06bec	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  06bf0	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  06bf3	0f 84 44 01 00
	00		 je	 $L59612
  06bf9	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  06bfc	0f 84 ee 00 00
	00		 je	 $L59594
  06c02	83 f8 ff	 cmp	 eax, -1
  06c05	0f 85 b6 02 00
	00		 jne	 $L59631

; 2331 : 					case (-1):						/* Request for texture file is pending */
; 2332 : 						statenum = pop;

  06c0b	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2333 : 						rq = (RFRequest *)apop;

  06c0d	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  06c10	83 c3 04	 add	 ebx, 4

; 2334 : 						maskname = (char *)apop;
; 2335 : 						WaitURL(rq);

  06c13	50		 push	 eax
  06c14	83 c3 04	 add	 ebx, 4
  06c17	89 44 24 38	 mov	 DWORD PTR _rq$59573[esp+308], eax
  06c1b	89 4c 24 30	 mov	 DWORD PTR _maskname$59570[esp+308], ecx
  06c1f	8b 13		 mov	 edx, DWORD PTR [ebx]
  06c21	83 c3 04	 add	 ebx, 4
  06c24	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  06c28	e8 00 00 00 00	 call	 _WaitURL

; 2336 : 						if (rq->status == 0) {		/* File opened */

  06c2d	8b 44 24 38	 mov	 eax, DWORD PTR _rq$59573[esp+308]
  06c31	83 c4 04	 add	 esp, 4
  06c34	8b 00		 mov	 eax, DWORD PTR [eax]
  06c36	85 c0		 test	 eax, eax
  06c38	75 62		 jne	 SHORT $L59584

; 2337 : 							texlocalname = strdup(rq->tmpname);

  06c3a	8b 4c 24 34	 mov	 ecx, DWORD PTR _rq$59573[esp+304]
  06c3e	83 c1 10	 add	 ecx, 16			; 00000010H
  06c41	51		 push	 ecx
  06c42	e8 00 00 00 00	 call	 _strdup

; 2338 : 							push(texlocalname);

  06c47	8b 54 24 10	 mov	 edx, DWORD PTR _tos$[esp+308]
  06c4b	83 eb 04	 sub	 ebx, 4

; 2339 : 							push(maskname);
; 2340 : 							push(rq);
; 2341 : 							push((cell)-2);

  06c4e	8b 4c 24 38	 mov	 ecx, DWORD PTR _rq$59573[esp+308]
  06c52	83 c4 04	 add	 esp, 4
  06c55	89 13		 mov	 DWORD PTR [ebx], edx
  06c57	83 eb 04	 sub	 ebx, 4
  06c5a	c7 44 24 0c fe
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -2 ; fffffffeH
  06c62	89 03		 mov	 DWORD PTR [ebx], eax
  06c64	8b 44 24 2c	 mov	 eax, DWORD PTR _maskname$59570[esp+304]
  06c68	83 eb 04	 sub	 ebx, 4
  06c6b	89 03		 mov	 DWORD PTR [ebx], eax

; 2342 : 							--ip;

  06c6d	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  06c70	83 eb 04	 sub	 ebx, 4
  06c73	83 e8 04	 sub	 eax, 4
  06c76	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  06c79	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2343 : 							if (*ip == EXECUTE) {

  06c7b	8b 08		 mov	 ecx, DWORD PTR [eax]
  06c7d	83 f9 34	 cmp	 ecx, 52			; 00000034H
  06c80	0f 85 ad 05 00
	00		 jne	 $pause$58247

; 2344 : 								push(NEWMASKEDTEXTURE);

  06c86	83 eb 04	 sub	 ebx, 4

; 2463 : 								push(NEWMASKEDTEXTURE);

  06c89	c7 44 24 0c 7a
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 378 ; 0000017aH
  06c91	c7 03 fe ff ff
	ff		 mov	 DWORD PTR [ebx], -2	; fffffffeH

; 2464 : 							}
; 2465 : 							goto pause;

  06c97	e9 97 05 00 00	 jmp	 $pause$58247
$L59584:

; 2345 : 							}
; 2346 : 							goto pause;
; 2347 : 						}
; 2348 : 						if (rq->status == 1) {		/* Request failed */

  06c9c	83 f8 01	 cmp	 eax, 1
  06c9f	75 2a		 jne	 SHORT $L59592

; 2349 : 							push(0);

  06ca1	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]

; 2350 : 							V_ERRNO = ETEXINVALIDTEXFILE;
; 2351 : 							free(rq);

  06ca5	8b 44 24 34	 mov	 eax, DWORD PTR _rq$59573[esp+304]
  06ca9	83 eb 04	 sub	 ebx, 4
  06cac	50		 push	 eax
  06cad	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+308], 0
  06cb5	89 13		 mov	 DWORD PTR [ebx], edx
  06cb7	c7 47 4c e0 fc
	ff ff		 mov	 DWORD PTR [edi+76], -800 ; fffffce0H
  06cbe	e8 00 00 00 00	 call	 _free
  06cc3	83 c4 04	 add	 esp, 4

; 2352 : 							next;

  06cc6	e9 9b 93 ff ff	 jmp	 $L58091
$L59592:

; 2353 : 						}
; 2354 : 						if (rq->status == -1) {		/* Request pending */

  06ccb	83 f8 ff	 cmp	 eax, -1
  06cce	75 20		 jne	 SHORT $L59594

; 2355 : 							push(maskname);

  06cd0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 2356 : 							push(rq);

  06cd4	8b 54 24 2c	 mov	 edx, DWORD PTR _maskname$59570[esp+304]
  06cd8	83 eb 04	 sub	 ebx, 4

; 2357 : 							push((cell)-1);

  06cdb	8b 44 24 34	 mov	 eax, DWORD PTR _rq$59573[esp+304]
  06cdf	89 0b		 mov	 DWORD PTR [ebx], ecx
  06ce1	83 eb 04	 sub	 ebx, 4
  06ce4	89 13		 mov	 DWORD PTR [ebx], edx
  06ce6	83 eb 04	 sub	 ebx, 4
  06ce9	89 03		 mov	 DWORD PTR [ebx], eax

; 2358 : 							--ip;
; 2359 : 							if (*ip == EXECUTE) {
; 2360 : 								push(NEWMASKEDTEXTURE);
; 2361 : 							}
; 2362 : 							goto pause;

  06ceb	e9 e5 02 00 00	 jmp	 $L61977
$L59594:

; 2363 : 						}
; 2364 : 					case (-2):						/* Texture file successfully opened--open mask file */
; 2365 : 						statenum = pop;

  06cf0	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2366 : 						rq = (RFRequest *)apop;

  06cf2	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  06cf5	83 c3 04	 add	 ebx, 4

; 2367 : 						maskname = (char *)apop;
; 2368 : 						texlocalname = (char *)apop;
; 2369 : 						OpenURL(maskname, rq, rfrqFILE);

  06cf8	6a 00		 push	 0
  06cfa	83 c3 04	 add	 ebx, 4
  06cfd	50		 push	 eax
  06cfe	51		 push	 ecx
  06cff	89 44 24 40	 mov	 DWORD PTR _rq$59573[esp+316], eax
  06d03	8b 13		 mov	 edx, DWORD PTR [ebx]
  06d05	83 c3 04	 add	 ebx, 4
  06d08	89 54 24 3c	 mov	 DWORD PTR _texlocalname$59571[esp+316], edx
  06d0c	89 4c 24 38	 mov	 DWORD PTR _maskname$59570[esp+316], ecx
  06d10	8b 13		 mov	 edx, DWORD PTR [ebx]
  06d12	83 c3 04	 add	 ebx, 4
  06d15	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  06d19	e8 00 00 00 00	 call	 _OpenURL

; 2370 : 						if (rq->status == 0) {		/* File opened */

  06d1e	8b 44 24 40	 mov	 eax, DWORD PTR _rq$59573[esp+316]
  06d22	83 c4 0c	 add	 esp, 12			; 0000000cH
  06d25	8b 00		 mov	 eax, DWORD PTR [eax]
  06d27	85 c0		 test	 eax, eax

; 2371 : 							SAVE_XCONTEXT
; 2372 : 							tp = MemeNewMaskedTexture(texlocalname, rq->tmpname);
; 2373 : 							RESTORE_XCONTEXT
; 2374 : 							push(tp);
; 2375 : 							free(texlocalname);
; 2376 : 							free(rq);
; 2377 : 							next;

  06d29	74 4f		 je	 SHORT $L61957

; 2378 : 						}
; 2379 : 						if (rq->status == 1) {		/* Request failed */

  06d2b	83 f8 01	 cmp	 eax, 1

; 2380 : 							push(0);
; 2381 : 							V_ERRNO = ETEXINVALIDMASKFILE;
; 2382 : 							free(texlocalname);
; 2383 : 							free(rq);
; 2384 : 							next;

  06d2e	0f 84 fe 00 00
	00		 je	 $L61954

; 2385 : 						}
; 2386 : 						if (rq->status == -1) {		/* Request pending */

  06d34	83 f8 ff	 cmp	 eax, -1

; 2387 : 							push(texlocalname);
; 2388 : 							push(maskname);
; 2389 : 							push(rq);
; 2390 : 							push((cell)-3);
; 2391 : 							--ip;
; 2392 : 							if (*ip == EXECUTE) {
; 2393 : 								push(NEWMASKEDTEXTURE);
; 2394 : 							}
; 2395 : 							goto pause;

  06d37	0f 84 2e 01 00
	00		 je	 $L61979
$L59612:

; 2396 : 						}
; 2397 : 					case (-3):						/* Request for mask file is pending */
; 2398 : 						statenum = pop;

  06d3d	8b 03		 mov	 eax, DWORD PTR [ebx]

; 2399 : 						rq = (RFRequest *)apop;

  06d3f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  06d42	83 c3 04	 add	 ebx, 4

; 2400 : 						maskname = (char *)apop;

  06d45	89 4c 24 2c	 mov	 DWORD PTR _maskname$59570[esp+304], ecx
  06d49	83 c3 04	 add	 ebx, 4

; 2401 : 						texlocalname = (char *)apop;
; 2402 : 						WaitURL(rq);

  06d4c	50		 push	 eax
  06d4d	89 44 24 38	 mov	 DWORD PTR _rq$59573[esp+308], eax
  06d51	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06d53	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  06d56	83 c3 04	 add	 ebx, 4
  06d59	89 4c 24 34	 mov	 DWORD PTR _texlocalname$59571[esp+308], ecx
  06d5d	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  06d61	83 c3 04	 add	 ebx, 4
  06d64	e8 00 00 00 00	 call	 _WaitURL

; 2403 : 						if (rq->status == 0) {		/* File opened */

  06d69	8b 44 24 38	 mov	 eax, DWORD PTR _rq$59573[esp+308]
  06d6d	83 c4 04	 add	 esp, 4
  06d70	8b 00		 mov	 eax, DWORD PTR [eax]
  06d72	85 c0		 test	 eax, eax
  06d74	0f 85 b3 00 00
	00		 jne	 $L59627
$L61957:

; 2404 : 							SAVE_XCONTEXT

  06d7a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  06d7e	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  06d82	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  06d86	83 eb 04	 sub	 ebx, 4
  06d89	83 ee 08	 sub	 esi, 8
  06d8c	89 0b		 mov	 DWORD PTR [ebx], ecx
  06d8e	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  06d92	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  06d98	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  06d9e	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  06da2	89 06		 mov	 DWORD PTR [esi], eax

; 2405 : 							tp = MemeNewMaskedTexture(texlocalname, rq->tmpname);

  06da4	8b 44 24 34	 mov	 eax, DWORD PTR _rq$59573[esp+304]
  06da8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  06dab	8b 4c 24 30	 mov	 ecx, DWORD PTR _texlocalname$59571[esp+304]
  06daf	83 c0 10	 add	 eax, 16			; 00000010H
  06db2	50		 push	 eax
  06db3	51		 push	 ecx
  06db4	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  06dba	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  06dc0	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  06dc6	e8 00 00 00 00	 call	 _MemeNewMaskedTexture

; 2406 : 							RESTORE_XCONTEXT

  06dcb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  06dd1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  06dd7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  06ddd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  06de3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  06de5	89 54 24 28	 mov	 DWORD PTR _frp$[esp+312], edx
  06de9	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  06dec	89 4c 24 18	 mov	 DWORD PTR _ftos$[esp+312], ecx
  06df0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  06df6	89 54 24 1c	 mov	 DWORD PTR _ftos$[esp+316], edx

; 2407 : 							push(tp);
; 2408 : 							free(texlocalname);

  06dfa	8b 54 24 38	 mov	 edx, DWORD PTR _texlocalname$59571[esp+312]
  06dfe	89 4c 24 24	 mov	 DWORD PTR _rp$[esp+312], ecx
  06e02	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  06e04	83 c6 08	 add	 esi, 8
  06e07	52		 push	 edx
  06e08	89 7c 24 34	 mov	 DWORD PTR _up$[esp+316], edi
  06e0c	89 74 24 30	 mov	 DWORD PTR _fsp$[esp+316], esi
  06e10	89 0b		 mov	 DWORD PTR [ebx], ecx
  06e12	89 44 24 18	 mov	 DWORD PTR _tos$[esp+316], eax
  06e16	e8 00 00 00 00	 call	 _free

; 2409 : 							free(rq);

  06e1b	8b 44 24 40	 mov	 eax, DWORD PTR _rq$59573[esp+316]
  06e1f	50		 push	 eax
  06e20	e8 00 00 00 00	 call	 _free
  06e25	83 c4 10	 add	 esp, 16			; 00000010H

; 2410 : 							next;

  06e28	e9 39 92 ff ff	 jmp	 $L58091
$L59627:

; 2411 : 						}
; 2412 : 						if (rq->status == 1) {		/* Request failed */

  06e2d	83 f8 01	 cmp	 eax, 1
  06e30	75 34		 jne	 SHORT $L59629
$L61954:

; 2413 : 							push(0);

  06e32	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 2414 : 							V_ERRNO = ETEXINVALIDMASKFILE;
; 2415 : 							free(texlocalname);

  06e36	8b 54 24 30	 mov	 edx, DWORD PTR _texlocalname$59571[esp+304]
  06e3a	83 eb 04	 sub	 ebx, 4
  06e3d	52		 push	 edx
  06e3e	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+308], 0
  06e46	89 0b		 mov	 DWORD PTR [ebx], ecx
  06e48	c7 47 4c df fc
	ff ff		 mov	 DWORD PTR [edi+76], -801 ; fffffcdfH
  06e4f	e8 00 00 00 00	 call	 _free

; 2416 : 							free(rq);

  06e54	8b 44 24 38	 mov	 eax, DWORD PTR _rq$59573[esp+308]
  06e58	50		 push	 eax
  06e59	e8 00 00 00 00	 call	 _free
  06e5e	83 c4 08	 add	 esp, 8

; 2417 : 							next;

  06e61	e9 00 92 ff ff	 jmp	 $L58091
$L59629:

; 2418 : 						}
; 2419 : 						if (rq->status == -1) {		/* Request pending */

  06e66	83 f8 ff	 cmp	 eax, -1
  06e69	75 56		 jne	 SHORT $L59631
$L61979:

; 2420 : 							push(texlocalname);

  06e6b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 2421 : 							push(maskname);

  06e6f	8b 54 24 30	 mov	 edx, DWORD PTR _texlocalname$59571[esp+304]
  06e73	83 eb 04	 sub	 ebx, 4

; 2422 : 							push(rq);

  06e76	8b 44 24 2c	 mov	 eax, DWORD PTR _maskname$59570[esp+304]

; 2423 : 							push((cell)-3);

  06e7a	c7 44 24 0c fd
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -3 ; fffffffdH
  06e82	89 0b		 mov	 DWORD PTR [ebx], ecx
  06e84	83 eb 04	 sub	 ebx, 4
  06e87	8b 4c 24 34	 mov	 ecx, DWORD PTR _rq$59573[esp+304]
  06e8b	89 13		 mov	 DWORD PTR [ebx], edx
  06e8d	83 eb 04	 sub	 ebx, 4
  06e90	89 03		 mov	 DWORD PTR [ebx], eax

; 2424 : 							--ip;

  06e92	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  06e95	83 eb 04	 sub	 ebx, 4
  06e98	83 e8 04	 sub	 eax, 4
  06e9b	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  06e9e	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2425 : 							if (*ip == EXECUTE) {

  06ea0	8b 08		 mov	 ecx, DWORD PTR [eax]
  06ea2	83 f9 34	 cmp	 ecx, 52			; 00000034H
  06ea5	0f 85 88 03 00
	00		 jne	 $pause$58247

; 2426 : 								push(NEWMASKEDTEXTURE);

  06eab	83 eb 04	 sub	 ebx, 4
  06eae	c7 44 24 0c 7a
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 378 ; 0000017aH
  06eb6	c7 03 fd ff ff
	ff		 mov	 DWORD PTR [ebx], -3	; fffffffdH

; 2427 : 							}
; 2428 : 							goto pause;

  06ebc	e9 72 03 00 00	 jmp	 $pause$58247
$L59631:

; 2429 : 						}
; 2430 : 					default:						/* First time through--open texture file */
; 2431 : 						maskname = (char *)apop;

  06ec1	8b 03		 mov	 eax, DWORD PTR [ebx]
  06ec3	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  06ec7	83 c3 04	 add	 ebx, 4

; 2432 : 						texname = (char *)apop;

  06eca	89 44 24 40	 mov	 DWORD PTR _texname$59569[esp+304], eax

; 2433 : 						rq = malloc(sizeof(RFRequest));

  06ece	68 10 01 00 00	 push	 272			; 00000110H
  06ed3	89 54 24 30	 mov	 DWORD PTR _maskname$59570[esp+308], edx
  06ed7	8b 03		 mov	 eax, DWORD PTR [ebx]
  06ed9	83 c3 04	 add	 ebx, 4
  06edc	89 44 24 10	 mov	 DWORD PTR _tos$[esp+308], eax
  06ee0	e8 00 00 00 00	 call	 _malloc
  06ee5	83 c4 04	 add	 esp, 4
  06ee8	89 44 24 34	 mov	 DWORD PTR _rq$59573[esp+304], eax

; 2434 : 						if (!rq) {

  06eec	85 c0		 test	 eax, eax
  06eee	75 16		 jne	 SHORT $L59645
$L59104:

; 2435 : 							push(0);

  06ef0	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  06ef4	83 eb 04	 sub	 ebx, 4
  06ef7	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+304], 0
  06eff	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2436 : 							next;

  06f01	e9 60 91 ff ff	 jmp	 $L58091
$L59645:

; 2437 : 						}
; 2438 : 						OpenURL(texname, rq, rfrqFILE);

  06f06	8b 54 24 34	 mov	 edx, DWORD PTR _rq$59573[esp+304]
  06f0a	8b 44 24 40	 mov	 eax, DWORD PTR _texname$59569[esp+304]
  06f0e	6a 00		 push	 0
  06f10	52		 push	 edx
  06f11	50		 push	 eax
  06f12	e8 00 00 00 00	 call	 _OpenURL

; 2439 : 						if (rq->status == 0) {		/* File opened */

  06f17	8b 4c 24 40	 mov	 ecx, DWORD PTR _rq$59573[esp+316]
  06f1b	83 c4 0c	 add	 esp, 12			; 0000000cH
  06f1e	8b 01		 mov	 eax, DWORD PTR [ecx]
  06f20	85 c0		 test	 eax, eax
  06f22	75 5e		 jne	 SHORT $L59647

; 2440 : 							texlocalname = strdup(rq->tmpname);

  06f24	8b d1		 mov	 edx, ecx
  06f26	83 c2 10	 add	 edx, 16			; 00000010H
  06f29	52		 push	 edx
  06f2a	e8 00 00 00 00	 call	 _strdup

; 2441 : 							push(texlocalname);

  06f2f	8b 4c 24 10	 mov	 ecx, DWORD PTR _tos$[esp+308]
  06f33	83 eb 04	 sub	 ebx, 4

; 2442 : 							push(maskname);
; 2443 : 							push(rq);

  06f36	8b 54 24 30	 mov	 edx, DWORD PTR _maskname$59570[esp+308]
  06f3a	83 c4 04	 add	 esp, 4
  06f3d	89 0b		 mov	 DWORD PTR [ebx], ecx
  06f3f	83 eb 04	 sub	 ebx, 4

; 2444 : 							push((cell)-2);

  06f42	c7 44 24 0c fe
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -2 ; fffffffeH
  06f4a	89 03		 mov	 DWORD PTR [ebx], eax
  06f4c	8b 44 24 34	 mov	 eax, DWORD PTR _rq$59573[esp+304]
  06f50	83 eb 04	 sub	 ebx, 4
  06f53	89 13		 mov	 DWORD PTR [ebx], edx
  06f55	83 eb 04	 sub	 ebx, 4
  06f58	89 03		 mov	 DWORD PTR [ebx], eax

; 2445 : 							--ip;

  06f5a	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  06f5d	83 e8 04	 sub	 eax, 4
  06f60	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2446 : 							if (*ip == EXECUTE) {

  06f63	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  06f66	0f 85 c7 02 00
	00		 jne	 $pause$58247

; 2447 : 								push(NEWMASKEDTEXTURE);

  06f6c	83 eb 04	 sub	 ebx, 4
  06f6f	c7 44 24 0c 7a
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 378 ; 0000017aH
  06f77	c7 03 fe ff ff
	ff		 mov	 DWORD PTR [ebx], -2	; fffffffeH

; 2448 : 							}
; 2449 : 							goto pause;

  06f7d	e9 b1 02 00 00	 jmp	 $pause$58247
$L59647:

; 2450 : 						}
; 2451 : 						if (rq->status == 1) {		/* Request failed */

  06f82	83 f8 01	 cmp	 eax, 1
  06f85	75 2a		 jne	 SHORT $L59655

; 2452 : 							push(0);

  06f87	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 2453 : 							V_ERRNO = ETEXINVALIDTEXFILE;
; 2454 : 							free(rq);

  06f8b	8b 54 24 34	 mov	 edx, DWORD PTR _rq$59573[esp+304]
  06f8f	83 eb 04	 sub	 ebx, 4
  06f92	52		 push	 edx
  06f93	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _tos$[esp+308], 0
  06f9b	89 0b		 mov	 DWORD PTR [ebx], ecx
  06f9d	c7 47 4c e0 fc
	ff ff		 mov	 DWORD PTR [edi+76], -800 ; fffffce0H
  06fa4	e8 00 00 00 00	 call	 _free
  06fa9	83 c4 04	 add	 esp, 4

; 2455 : 							next;

  06fac	e9 b5 90 ff ff	 jmp	 $L58091
$L59655:

; 2456 : 						}
; 2457 : 						if (rq->status == -1) {		/* Request pending */

  06fb1	83 f8 ff	 cmp	 eax, -1
  06fb4	0f 85 a8 90 ff
	ff		 jne	 $L61884

; 2458 : 							push(maskname);

  06fba	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2459 : 							push(rq);

  06fbe	8b 4c 24 2c	 mov	 ecx, DWORD PTR _maskname$59570[esp+304]
  06fc2	83 eb 04	 sub	 ebx, 4

; 2460 : 							push((cell)-1);

  06fc5	8b 54 24 34	 mov	 edx, DWORD PTR _rq$59573[esp+304]
  06fc9	89 03		 mov	 DWORD PTR [ebx], eax
  06fcb	83 eb 04	 sub	 ebx, 4
  06fce	89 0b		 mov	 DWORD PTR [ebx], ecx
  06fd0	83 eb 04	 sub	 ebx, 4
  06fd3	89 13		 mov	 DWORD PTR [ebx], edx
$L61977:

; 2461 : 							--ip;

  06fd5	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  06fd8	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  06fe0	83 e8 04	 sub	 eax, 4
  06fe3	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2462 : 							if (*ip == EXECUTE) {

  06fe6	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  06fe9	0f 85 44 02 00
	00		 jne	 $pause$58247

; 2463 : 								push(NEWMASKEDTEXTURE);

  06fef	83 eb 04	 sub	 ebx, 4
  06ff2	c7 44 24 0c 7a
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 378 ; 0000017aH
  06ffa	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1

; 2464 : 							}
; 2465 : 							goto pause;

  07000	e9 2e 02 00 00	 jmp	 $pause$58247
$L59664:

; 2466 : 						}
; 2467 : 				} /* switch (tos) */
; 2468 : 			} next;		/* Just in case; the "next" shouldn't be necessary */
; 2469 : 			/* Set the backdrop image for this camera
; 2470 : 			 * ( cstringfilename cameraobjaddr --  )
; 2471 : 			 */
; 2472 : 			case SETCAMERABACKDROP: {
; 2473 : 				Object *obj;
; 2474 : 				char *filename;
; 2475 : 				RFRequest *rq;
; 2476 : 
; 2477 : 				obj = (Object *) apop;

  07005	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  07009	83 c3 04	 add	 ebx, 4
  0700c	89 44 24 30	 mov	 DWORD PTR _obj$59665[esp+304], eax
  07010	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]

; 2478 : 				filename = (char *)apop;

  07013	8b c8		 mov	 ecx, eax
  07015	8b 03		 mov	 eax, DWORD PTR [ebx]
  07017	83 c3 04	 add	 ebx, 4
  0701a	89 4c 24 40	 mov	 DWORD PTR _filename$59666[esp+304], ecx

; 2479 : 
; 2480 : 				/* If the filename ptr is zero, call MemeSetCameraBackdroo
; 2481 : 				 * to reset the backdrop to nothing.
; 2482 : 				 */
; 2483 : 				if (filename == NULL) {

  0701e	85 c9		 test	 ecx, ecx
  07020	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  07024	0f 85 94 00 00
	00		 jne	 $L59673

; 2484 : 					SAVE_XCONTEXT

  0702a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  0702e	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  07032	83 eb 04	 sub	 ebx, 4
  07035	83 ee 08	 sub	 esi, 8

; 2485 : 					MemeSetCameraBackdrop(obj, filename);

  07038	6a 00		 push	 0
  0703a	89 03		 mov	 DWORD PTR [ebx], eax
  0703c	8b 44 24 18	 mov	 eax, DWORD PTR _ftos$[esp+312]
  07040	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  07046	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  0704c	8b 4c 24 24	 mov	 ecx, DWORD PTR _frp$[esp+308]
  07050	89 16		 mov	 DWORD PTR [esi], edx
  07052	8b 54 24 34	 mov	 edx, DWORD PTR _obj$59665[esp+308]
  07056	89 46 04	 mov	 DWORD PTR [esi+4], eax
  07059	52		 push	 edx
  0705a	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  07060	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  07066	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  0706c	e8 00 00 00 00	 call	 _MemeSetCameraBackdrop
  07071	83 c4 08	 add	 esp, 8
$L61693:

; 2486 : 					RESTORE_XCONTEXT

  07074	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  0707a	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  0707f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  07085	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0708b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0708d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  07090	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  07094	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  07099	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  0709d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0709f	83 c6 08	 add	 esi, 8
  070a2	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  070a6	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  070aa	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  070ae	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  070b2	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  070b6	83 c3 04	 add	 ebx, 4

; 2487 : 					next;

  070b9	e9 a8 8f ff ff	 jmp	 $L58091
$L59673:

; 2488 : 				}
; 2489 : 				if (filename != (char *)-1) {	/* First time, try to open URL */

  070be	83 f9 ff	 cmp	 ecx, -1
  070c1	74 37		 je	 SHORT $L59675

; 2490 : 					rq = malloc(sizeof(RFRequest));

  070c3	68 10 01 00 00	 push	 272			; 00000110H
  070c8	e8 00 00 00 00	 call	 _malloc
  070cd	83 c4 04	 add	 esp, 4
  070d0	89 44 24 2c	 mov	 DWORD PTR _rq$59667[esp+304], eax

; 2491 : 					if (!rq) {

  070d4	85 c0		 test	 eax, eax
  070d6	75 0c		 jne	 SHORT $L59677

; 2492 : 						V_ERRNO = ESCBNOSPACE;

  070d8	c7 47 4c 7b fc
	ff ff		 mov	 DWORD PTR [edi+76], -901 ; fffffc7bH

; 2493 : 						next;

  070df	e9 82 8f ff ff	 jmp	 $L58091
$L59677:

; 2494 : 					}
; 2495 : 					OpenURL(filename, rq, rfrqFILE);

  070e4	8b 54 24 2c	 mov	 edx, DWORD PTR _rq$59667[esp+304]
  070e8	8b 44 24 40	 mov	 eax, DWORD PTR _filename$59666[esp+304]
  070ec	6a 00		 push	 0
  070ee	52		 push	 edx
  070ef	50		 push	 eax
  070f0	e8 00 00 00 00	 call	 _OpenURL
  070f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2496 : 				} else {						/* We're idling */

  070f8	eb 20		 jmp	 SHORT $L59678
$L59675:

; 2497 : 					obj = (Object *)apop;
; 2498 : 					rq = (RFRequest *)apop;

  070fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  070fd	89 44 24 30	 mov	 DWORD PTR _obj$59665[esp+304], eax
  07101	8b 03		 mov	 eax, DWORD PTR [ebx]
  07103	83 c3 04	 add	 ebx, 4

; 2499 : 					WaitURL(rq);

  07106	50		 push	 eax
  07107	89 44 24 30	 mov	 DWORD PTR _rq$59667[esp+308], eax
  0710b	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  0710f	83 c3 04	 add	 ebx, 4
  07112	e8 00 00 00 00	 call	 _WaitURL
  07117	83 c4 04	 add	 esp, 4
$L59678:

; 2500 : 				}
; 2501 : 				if (rq->status == 0) {		/* File opened */

  0711a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _rq$59667[esp+304]
  0711e	8b 01		 mov	 eax, DWORD PTR [ecx]
  07120	85 c0		 test	 eax, eax
  07122	0f 85 a6 00 00
	00		 jne	 $L59683

; 2502 : 					filename = rq->tmpname;

  07128	8b d1		 mov	 edx, ecx

; 2503 : 					SAVE_XCONTEXT

  0712a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0712e	83 eb 04	 sub	 ebx, 4
  07131	83 ee 08	 sub	 esi, 8
  07134	8d 42 10	 lea	 eax, DWORD PTR [edx+16]
  07137	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0713b	89 0b		 mov	 DWORD PTR [ebx], ecx
  0713d	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  07141	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  07147	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0714b	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  07151	89 0e		 mov	 DWORD PTR [esi], ecx
  07153	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  07157	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 2504 : 					MemeSetCameraBackdrop(obj, filename);

  0715a	8b 54 24 30	 mov	 edx, DWORD PTR _obj$59665[esp+304]
  0715e	50		 push	 eax
  0715f	52		 push	 edx
  07160	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  07166	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  0716c	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  07172	e8 00 00 00 00	 call	 _MemeSetCameraBackdrop

; 2505 : 	#ifdef REMOVE
; 2506 : 					/* Don't remove temporary files anymore, because of caching */
; 2507 : 					ascr = strrchr(filename, '.');
; 2508 : 					if (ascr && !strcmp(ascr, ".tmp")) unlink(filename);
; 2509 : 	#endif
; 2510 : 					RESTORE_XCONTEXT

  07177	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  0717d	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  07182	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  07188	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  0718e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  07191	8b 0e		 mov	 ecx, DWORD PTR [esi]
  07193	89 54 24 1c	 mov	 DWORD PTR _ftos$[esp+316], edx

; 2511 : 					free(rq);

  07197	8b 54 24 34	 mov	 edx, DWORD PTR _rq$59667[esp+312]
  0719b	89 44 24 28	 mov	 DWORD PTR _frp$[esp+312], eax
  0719f	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  071a4	89 4c 24 18	 mov	 DWORD PTR _ftos$[esp+312], ecx
  071a8	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  071aa	83 c6 08	 add	 esi, 8
  071ad	52		 push	 edx
  071ae	89 7c 24 34	 mov	 DWORD PTR _up$[esp+316], edi
  071b2	89 74 24 30	 mov	 DWORD PTR _fsp$[esp+316], esi
  071b6	89 44 24 28	 mov	 DWORD PTR _rp$[esp+316], eax
  071ba	89 4c 24 18	 mov	 DWORD PTR _tos$[esp+316], ecx
  071be	83 c3 04	 add	 ebx, 4
  071c1	e8 00 00 00 00	 call	 _free
  071c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2512 : 					next;

  071c9	e9 98 8e ff ff	 jmp	 $L58091
$L59683:

; 2513 : 				}
; 2514 : 				if (rq->status == 1) {		/* Request failed */

  071ce	83 f8 01	 cmp	 eax, 1
  071d1	75 19		 jne	 SHORT $L59684

; 2515 : 					V_ERRNO = ESCBINVALIDFILE;
; 2516 : 					free(rq);

  071d3	8b 44 24 2c	 mov	 eax, DWORD PTR _rq$59667[esp+304]
  071d7	c7 47 4c 7c fc
	ff ff		 mov	 DWORD PTR [edi+76], -900 ; fffffc7cH
  071de	50		 push	 eax
  071df	e8 00 00 00 00	 call	 _free
  071e4	83 c4 04	 add	 esp, 4

; 2517 : 					next;

  071e7	e9 7a 8e ff ff	 jmp	 $L58091
$L59684:

; 2518 : 				}
; 2519 : 				if (rq->status == -1) {		/* Request pending */

  071ec	83 f8 ff	 cmp	 eax, -1
  071ef	0f 85 78 02 00
	00		 jne	 $L59685

; 2520 : 					push(rq);

  071f5	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  071f9	83 eb 04	 sub	 ebx, 4

; 2521 : 					push(obj);
; 2522 : 					push((cell)-1);

  071fc	8b 44 24 30	 mov	 eax, DWORD PTR _obj$59665[esp+304]
  07200	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR _tos$[esp+304], -1
  07208	89 13		 mov	 DWORD PTR [ebx], edx
  0720a	83 eb 04	 sub	 ebx, 4
  0720d	89 0b		 mov	 DWORD PTR [ebx], ecx
  0720f	83 eb 04	 sub	 ebx, 4
  07212	89 03		 mov	 DWORD PTR [ebx], eax

; 2523 : 					--ip;

  07214	8b 45 08	 mov	 eax, DWORD PTR _ip$[ebp]
  07217	83 e8 04	 sub	 eax, 4
  0721a	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2524 : 					if (*ip == EXECUTE) {

  0721d	83 38 34	 cmp	 DWORD PTR [eax], 52	; 00000034H
  07220	75 11		 jne	 SHORT $pause$58247
$L61974:

; 2525 : 						push(NEWTEXTURE);

  07222	83 eb 04	 sub	 ebx, 4
  07225	c7 44 24 0c 24
	01 00 00	 mov	 DWORD PTR _tos$[esp+304], 292 ; 00000124H
  0722d	c7 03 ff ff ff
	ff		 mov	 DWORD PTR [ebx], -1
$pause$58247:
  07233	a1 00 00 00 00	 mov	 eax, DWORD PTR _multitasking
  07238	85 c0		 test	 eax, eax
  0723a	0f 84 9f 01 00
	00		 je	 $L58932
  07240	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  07244	8b 55 08	 mov	 edx, DWORD PTR _ip$[ebp]
  07247	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  0724b	83 eb 04	 sub	 ebx, 4
  0724e	83 ee 08	 sub	 esi, 8
  07251	89 0b		 mov	 DWORD PTR [ebx], ecx
  07253	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  07257	89 57 64	 mov	 DWORD PTR [edi+100], edx
  0725a	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  0725e	89 47 68	 mov	 DWORD PTR [edi+104], eax
  07261	89 5f 6c	 mov	 DWORD PTR [edi+108], ebx
  07264	89 0e		 mov	 DWORD PTR [esi], ecx
  07266	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  0726a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0726d	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  07271	89 b7 94 00 00
	00		 mov	 DWORD PTR [edi+148], esi
  07277	83 eb 04	 sub	 ebx, 4
  0727a	89 8f a8 00 00
	00		 mov	 DWORD PTR [edi+168], ecx
  07280	8b 7f 5c	 mov	 edi, DWORD PTR [edi+92]
  07283	89 13		 mov	 DWORD PTR [ebx], edx
  07285	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  07289	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  0728e	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  07292	83 ee 08	 sub	 esi, 8
  07295	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0729b	89 06		 mov	 DWORD PTR [esi], eax
  0729d	89 56 04	 mov	 DWORD PTR [esi+4], edx
  072a0	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  072a6	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  072ac	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  072b2	e8 00 00 00 00	 call	 _MemeOften
  072b7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  072bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  072c2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  072c8	89 44 24 20	 mov	 DWORD PTR _frp$[esp+304], eax
  072cc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  072ce	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  072d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  072d6	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx
  072da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  072e0	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  072e4	8b 13		 mov	 edx, DWORD PTR [ebx]
  072e6	83 c6 08	 add	 esi, 8
  072e9	89 44 24 28	 mov	 DWORD PTR _up$[esp+304], eax
  072ed	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  072f1	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  072f5	83 c3 04	 add	 ebx, 4
$task_dispatcher$58939:
  072f8	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  072fb	85 c9		 test	 ecx, ecx
  072fd	0f 85 96 00 00
	00		 jne	 $L58942
$L58941:

; 1169 : #if 1
; 1170 : 			case PAUSE:	/* ( -- ) Curr task relinquishes control of CPU */
; 1171 : pause:			if (multitasking) {
; 1172 : 			    	SAVE_TASKCONTEXT
; 1173 : 					up = (cell *) V_LINK;
; 1174 : 					SAVE_XCONTEXT MemeOften(); RESTORE_XCONTEXT
; 1175 : task_dispatcher:	while (!V_TASK_ACTIVE) {
; 1176 : 						up = (cell *) V_LINK;

  07303	8b 44 24 28	 mov	 eax, DWORD PTR _up$[esp+304]

; 1177 : 						SAVE_XCONTEXT MemeOften(); RESTORE_XCONTEXT

  07307	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0730b	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  0730f	83 eb 04	 sub	 ebx, 4
  07312	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  07315	83 ee 08	 sub	 esi, 8
  07318	89 0b		 mov	 DWORD PTR [ebx], ecx
  0731a	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  0731e	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  07324	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  07328	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0732e	89 0e		 mov	 DWORD PTR [esi], ecx
  07330	89 56 04	 mov	 DWORD PTR [esi+4], edx
  07333	a3 00 00 00 00	 mov	 DWORD PTR _xup, eax
  07338	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  0733c	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  07342	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  07347	e8 00 00 00 00	 call	 _MemeOften
  0734c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  07352	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  07358	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  0735e	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  07363	8b 16		 mov	 edx, DWORD PTR [esi]
  07365	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  07369	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0736c	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  07370	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  07376	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  0737a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0737c	83 c6 08	 add	 esi, 8
  0737f	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx
  07383	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  07386	83 c3 04	 add	 ebx, 4
  07389	89 44 24 28	 mov	 DWORD PTR _up$[esp+304], eax
  0738d	85 c9		 test	 ecx, ecx
  0738f	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
  07393	0f 84 6a ff ff
	ff		 je	 $L58941
$L58942:

; 1178 : 					}
; 1179 : 		    		RESTORE_TASKCONTEXT

  07399	8b 7c 24 28	 mov	 edi, DWORD PTR _up$[esp+304]
  0739d	8b b7 94 00 00
	00		 mov	 esi, DWORD PTR [edi+148]
  073a3	8b 97 a8 00 00
	00		 mov	 edx, DWORD PTR [edi+168]
  073a9	8b 5f 6c	 mov	 ebx, DWORD PTR [edi+108]
  073ac	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  073b0	8b 06		 mov	 eax, DWORD PTR [esi]
  073b2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  073b5	8b 13		 mov	 edx, DWORD PTR [ebx]
  073b7	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  073bb	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  073be	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  073c2	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  073c5	83 c6 08	 add	 esi, 8
  073c8	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  073cc	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  073d0	83 c3 04	 add	 ebx, 4
  073d3	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  073d7	89 4d 08	 mov	 DWORD PTR _ip$[ebp], ecx

; 1180 : 					next;

  073da	e9 87 8c ff ff	 jmp	 $L58091
$L58932:

; 1181 : 				}
; 1182 : 				SAVE_XCONTEXT MemeOften(); RESTORE_XCONTEXT

  073df	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  073e3	8b 44 24 1c	 mov	 eax, DWORD PTR _rp$[esp+304]
  073e7	8b 4c 24 10	 mov	 ecx, DWORD PTR _ftos$[esp+304]
  073eb	83 eb 04	 sub	 ebx, 4
  073ee	83 ee 08	 sub	 esi, 8
  073f1	89 13		 mov	 DWORD PTR [ebx], edx
  073f3	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  073f7	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  073fd	a3 00 00 00 00	 mov	 DWORD PTR _xrp, eax
  07402	8b 44 24 20	 mov	 eax, DWORD PTR _frp$[esp+304]
  07406	89 0e		 mov	 DWORD PTR [esi], ecx
  07408	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0740b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  07411	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  07417	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  0741c	e8 00 00 00 00	 call	 _MemeOften
  07421	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  07427	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xfrp
  0742d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  07433	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  07439	8b 16		 mov	 edx, DWORD PTR [esi]
  0743b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0743e	89 4c 24 20	 mov	 DWORD PTR _frp$[esp+304], ecx
  07442	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xrp
  07448	89 54 24 10	 mov	 DWORD PTR _ftos$[esp+304], edx
  0744c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0744e	83 c6 08	 add	 esi, 8
  07451	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  07455	89 44 24 14	 mov	 DWORD PTR _ftos$[esp+308], eax
  07459	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0745d	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  07461	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx

; 2486 : 					RESTORE_XCONTEXT

  07465	83 c3 04	 add	 ebx, 4

; 2487 : 					next;

  07468	e9 f9 8b ff ff	 jmp	 $L58091
$L59685:

; 2526 : 					}
; 2527 : 					goto pause;
; 2528 : 				}
; 2529 : 			}
; 2530 : 			/* parent linktype textureptr -- objaddr */
; 2531 : 			case NEWSPRITE:
; 2532 : 				ascr1 = apop;			/* textureptr */

  0746d	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  07471	83 c3 04	 add	 ebx, 4
  07474	89 44 24 3c	 mov	 DWORD PTR _ascr1$[esp+304], eax
  07478	8b 4b fc	 mov	 ecx, DWORD PTR [ebx-4]

; 2533 : 				scr = pop;				/* linktype */

  0747b	8b 13		 mov	 edx, DWORD PTR [ebx]
  0747d	83 c3 04	 add	 ebx, 4

; 2534 : 				ascr = apop;			/* parent */

  07480	89 54 24 34	 mov	 DWORD PTR _ascr$[esp+304], edx

; 2535 : 				ascr = (char *)NewSpriteObject( (Object *)ascr, scr, (cell)ascr1 );

  07484	50		 push	 eax
  07485	8b 44 24 38	 mov	 eax, DWORD PTR _ascr$[esp+308]
  07489	8b 13		 mov	 edx, DWORD PTR [ebx]
  0748b	51		 push	 ecx
  0748c	50		 push	 eax
  0748d	89 54 24 18	 mov	 DWORD PTR _tos$[esp+316], edx
  07491	e8 00 00 00 00	 call	 _NewSpriteObject

; 2536 : 				push(ascr);

  07496	8b 4c 24 18	 mov	 ecx, DWORD PTR _tos$[esp+316]
  0749a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0749d	89 0b		 mov	 DWORD PTR [ebx], ecx
  0749f	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2537 : 				next;

  074a3	e9 be 8b ff ff	 jmp	 $L58091
$L59699:

; 2538 : 			/* index objaddr -- polygonptr */
; 2539 : 			case GETPOLYGON:
; 2540 : 				ascr = apop;

  074a8	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2541 : 				scr = pop;

  074aa	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  074ad	83 c3 04	 add	 ebx, 4
  074b0	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2542 : 				SAVE_XCONTEXT

  074b4	83 ee 08	 sub	 esi, 8

; 2543 : 				ascr1 = (u_char *)MemeGetPolygon((Object *)ascr, scr);

  074b7	51		 push	 ecx
  074b8	89 13		 mov	 DWORD PTR [ebx], edx
  074ba	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  074be	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  074c4	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  074c8	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  074ce	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  074d2	89 16		 mov	 DWORD PTR [esi], edx
  074d4	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  074d8	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  074db	50		 push	 eax
  074dc	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  074e2	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  074e8	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  074ee	e8 00 00 00 00	 call	 _MemeGetPolygon

; 2544 : 				RESTORE_XCONTEXT

  074f3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  074f9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  074ff	89 44 24 44	 mov	 DWORD PTR _ascr1$[esp+312], eax
  07503	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfrp
  07508	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0750a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  07510	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  07513	89 44 24 28	 mov	 DWORD PTR _frp$[esp+312], eax
  07517	a1 00 00 00 00	 mov	 eax, DWORD PTR _xrp
  0751c	83 c4 08	 add	 esp, 8
  0751f	89 44 24 1c	 mov	 DWORD PTR _rp$[esp+304], eax
  07523	8b 03		 mov	 eax, DWORD PTR [ebx]
  07525	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx

; 2545 : 				push(ascr1);

  07529	89 03		 mov	 DWORD PTR [ebx], eax
  0752b	8b 4c 24 3c	 mov	 ecx, DWORD PTR _ascr1$[esp+304]
  0752f	83 c6 08	 add	 esi, 8
  07532	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  07536	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  0753a	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  0753e	89 4c 24 0c	 mov	 DWORD PTR _tos$[esp+304], ecx

; 2546 : 				next;

  07542	e9 1f 8b ff ff	 jmp	 $L58091
$L59704:

; 2547 : 			/* x y cameraobjaddr -- */
; 2548 : 			case SETCAMERABACKDROPOFFSET: {
; 2549 : 				cell x, y;
; 2550 : 				ascr = apop; y = pop; x = pop;

  07547	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  07549	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0754c	83 c3 04	 add	 ebx, 4
  0754f	89 54 24 40	 mov	 DWORD PTR _x$59705[esp+304], edx
  07553	83 c3 04	 add	 ebx, 4
  07556	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2551 : 				SAVE_XCONTEXT

  0755a	83 ee 08	 sub	 esi, 8

; 2552 : 				MemeSetCameraBackdropOffset((Object *)ascr, x, y);

  0755d	51		 push	 ecx
  0755e	8b 13		 mov	 edx, DWORD PTR [ebx]
  07560	8b 4c 24 44	 mov	 ecx, DWORD PTR _x$59705[esp+308]
  07564	89 13		 mov	 DWORD PTR [ebx], edx
  07566	8b 54 24 20	 mov	 edx, DWORD PTR _rp$[esp+308]
  0756a	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  07570	8b 54 24 14	 mov	 edx, DWORD PTR _ftos$[esp+308]
  07574	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0757a	8b 5c 24 18	 mov	 ebx, DWORD PTR _ftos$[esp+312]
  0757e	89 16		 mov	 DWORD PTR [esi], edx
  07580	8b 54 24 24	 mov	 edx, DWORD PTR _frp$[esp+308]
  07584	51		 push	 ecx
  07585	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  07588	50		 push	 eax
  07589	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  0758f	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  07595	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx
  0759b	e8 00 00 00 00	 call	 _MemeSetCameraBackdropOffset
$L61949:
  075a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 452  : 				SAVE_XCONTEXT udot((u_cell)scr ); RESTORE_XCONTEXT 

$L60948:

; 2553 : 				RESTORE_XCONTEXT

  075a3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfsp
  075a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfrp
  075af	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup
  075b5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xsp
  075bb	8b 06		 mov	 eax, DWORD PTR [esi]
  075bd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  075c0	89 54 24 20	 mov	 DWORD PTR _frp$[esp+304], edx
  075c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xrp
  075ca	83 c6 08	 add	 esi, 8
  075cd	89 7c 24 28	 mov	 DWORD PTR _up$[esp+304], edi
  075d1	89 44 24 10	 mov	 DWORD PTR _ftos$[esp+304], eax
  075d5	89 4c 24 14	 mov	 DWORD PTR _ftos$[esp+308], ecx
  075d9	89 74 24 24	 mov	 DWORD PTR _fsp$[esp+304], esi
  075dd	89 54 24 1c	 mov	 DWORD PTR _rp$[esp+304], edx
$L58231:
  075e1	8b 03		 mov	 eax, DWORD PTR [ebx]
  075e3	83 c3 04	 add	 ebx, 4
  075e6	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2554 : 			} next;

  075ea	e9 77 8a ff ff	 jmp	 $L58091
$L59709:

; 2555 : 			/* addr1 newsize -- addr2 */
; 2556 : 			case REALLOC_MEM:	
; 2557 : 				scr = pop;	tos = (cell)realloc((void *)tos, scr);	next;

  075ef	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  075f3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  075f5	50		 push	 eax
  075f6	51		 push	 ecx
  075f7	83 c3 04	 add	 ebx, 4
  075fa	e8 00 00 00 00	 call	 _realloc
  075ff	83 c4 08	 add	 esp, 8
  07602	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  07606	e9 5b 8a ff ff	 jmp	 $L58091
$L59712:

; 2558 : 			/* -- dictsize */
; 2559 : 			case DICTIONARYSIZE:	push(DICT_SIZE);	next;

  0760b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0760f	83 eb 04	 sub	 ebx, 4
  07612	c7 44 24 0c 00
	00 04 00	 mov	 DWORD PTR _tos$[esp+304], 262144 ; 00040000H
  0761a	89 0b		 mov	 DWORD PTR [ebx], ecx
  0761c	e9 45 8a ff ff	 jmp	 $L58091
$L59714:

; 2560 : 			/* materialp polygonp -- */
; 2561 : 			case GETPOLYGONMATERIAL:
; 2562 : 				ascr = apop;

  07621	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  07623	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2563 : 				scr = pop;

  07627	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0762a	83 c3 04	 add	 ebx, 4

; 2564 : 				MemeGetPolygonMaterial(ascr, (mMat *)scr);

  0762d	51		 push	 ecx
  0762e	50		 push	 eax
  0762f	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  07633	83 c3 04	 add	 ebx, 4
  07636	e8 00 00 00 00	 call	 _MemeGetPolygonMaterial
  0763b	83 c4 08	 add	 esp, 8

; 2565 : 				next;

  0763e	e9 23 8a ff ff	 jmp	 $L58091
$L59717:

; 2566 : 			/* objaddr -- */
; 2567 : 			case EMPTYSHAPE:
; 2568 : 				ascr = apop;

  07643	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  07647	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2569 : 				MemeEmptyShape((Object *)ascr);

  07649	50		 push	 eax
  0764a	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  0764e	83 c3 04	 add	 ebx, 4
  07651	e8 00 00 00 00	 call	 _MemeEmptyShape
  07656	83 c4 04	 add	 esp, 4

; 2570 : 				next;

  07659	e9 08 8a ff ff	 jmp	 $L58091
$L59720:

; 2571 : 			/* objaddr -- vindex */  /* [float] x y z -- */
; 2572 : 			case ADDVERTEX: {
; 2573 : 				double x, y, z;
; 2574 : 				z = flpop; y = flpop; x = flpop;

  0765e	dd 06		 fld	 QWORD PTR [esi]
  07660	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  07664	83 c6 08	 add	 esi, 8
  07667	dd 5c 24 40	 fstp	 QWORD PTR _y$59722[esp+304]
  0766b	dd 06		 fld	 QWORD PTR [esi]
  0766d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  07670	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  07674	83 c6 08	 add	 esi, 8
  07677	89 4c 24 10	 mov	 DWORD PTR _ftos$[esp+304], ecx

; 2575 : 				ascr = apop;

  0767b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0767d	89 94 24 b0 00
	00 00		 mov	 DWORD PTR _z$59723[esp+304], edx
  07684	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  07687	89 84 24 b4 00
	00 00		 mov	 DWORD PTR _z$59723[esp+308], eax
  0768e	dd 5c 24 50	 fstp	 QWORD PTR _x$59721[esp+304]

; 2576 : 				push(MemeAddVertex((Object *)ascr, x, y, z));

  07692	89 0b		 mov	 DWORD PTR [ebx], ecx
  07694	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR _z$59723[esp+308]
  0769b	89 54 24 14	 mov	 DWORD PTR _ftos$[esp+308], edx
  0769f	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR _z$59723[esp+304]
  076a6	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  076aa	51		 push	 ecx
  076ab	8b 4c 24 48	 mov	 ecx, DWORD PTR _y$59722[esp+312]
  076af	52		 push	 edx
  076b0	8b 54 24 48	 mov	 edx, DWORD PTR _y$59722[esp+312]
  076b4	51		 push	 ecx
  076b5	8b 4c 24 60	 mov	 ecx, DWORD PTR _x$59721[esp+320]
  076b9	52		 push	 edx
  076ba	8b 54 24 60	 mov	 edx, DWORD PTR _x$59721[esp+320]
  076be	51		 push	 ecx
  076bf	83 c6 08	 add	 esi, 8
  076c2	52		 push	 edx
  076c3	50		 push	 eax
  076c4	89 74 24 40	 mov	 DWORD PTR _fsp$[esp+332], esi
  076c8	e8 00 00 00 00	 call	 _MemeAddVertex
  076cd	83 c4 1c	 add	 esp, 28			; 0000001cH
  076d0	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2577 : 				next;

  076d4	e9 8d 89 ff ff	 jmp	 $L58091
$L59727:

; 2578 : 			}
; 2579 : 			/* vindexlistaddr n objaddr -- polygonptr */
; 2580 : 			case ADDPOLYGON: {
; 2581 : 				Object *obj;
; 2582 : 				cell n;
; 2583 : 				void *vindexaddr;
; 2584 : 				obj = (Object *)apop; n = pop; vindexaddr = apop;

  076d9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  076db	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  076de	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  076e2	83 c3 04	 add	 ebx, 4
  076e5	89 54 24 40	 mov	 DWORD PTR _vindexaddr$59730[esp+304], edx
  076e9	83 c3 04	 add	 ebx, 4

; 2585 : 				push(MemeAddPolygon(obj, vindexaddr, n));

  076ec	51		 push	 ecx
  076ed	8b 4c 24 44	 mov	 ecx, DWORD PTR _vindexaddr$59730[esp+308]
  076f1	8b 13		 mov	 edx, DWORD PTR [ebx]
  076f3	51		 push	 ecx
  076f4	50		 push	 eax
  076f5	89 13		 mov	 DWORD PTR [ebx], edx
  076f7	e8 00 00 00 00	 call	 _MemeAddPolygon
  076fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  076ff	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax

; 2586 : 				next;

  07703	e9 5e 89 ff ff	 jmp	 $L58091
$L59735:

; 2587 : 			}
; 2588 : 			/* srcobjaddr destobjaddr -- */
; 2589 : 			case ADDSHAPE: {
; 2590 : 				Object *srcobj, *destobj;
; 2591 : 				destobj = (Object *)apop;

  07708	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0770a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2592 : 				srcobj = (Object *)apop;

  0770e	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  07711	83 c3 04	 add	 ebx, 4

; 2593 : 				MemeAddShape(srcobj, destobj);

  07714	50		 push	 eax
  07715	51		 push	 ecx
  07716	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  0771a	83 c3 04	 add	 ebx, 4
  0771d	e8 00 00 00 00	 call	 _MemeAddShape
  07722	83 c4 08	 add	 esp, 8

; 2594 : 				next;

  07725	e9 3c 89 ff ff	 jmp	 $L58091
$L59742:

; 2595 : 			}
; 2596 : 			/* polygonptr -- */
; 2597 : 			case REVERSEPOLYGONNORMAL: {
; 2598 : 				void *polyp = apop;

  0772a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0772e	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2599 : 				MemeReversePolygonNormal(polyp);

  07730	50		 push	 eax
  07731	89 4c 24 10	 mov	 DWORD PTR _tos$[esp+308], ecx
  07735	83 c3 04	 add	 ebx, 4
  07738	e8 00 00 00 00	 call	 _MemeReversePolygonNormal
  0773d	83 c4 04	 add	 esp, 4

; 2600 : 				next;

  07740	e9 21 89 ff ff	 jmp	 $L58091
$L59745:

; 2601 : 			}
; 2602 : 			/* objaddr -- */
; 2603 : 			case REVERSESHAPENORMALS: {
; 2604 : 				Object *obj = (Object *)apop;

  07745	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  07749	8b 13		 mov	 edx, DWORD PTR [ebx]

; 2605 : 				MemeReverseShapeNormals(obj);

  0774b	50		 push	 eax
  0774c	89 54 24 10	 mov	 DWORD PTR _tos$[esp+308], edx
  07750	83 c3 04	 add	 ebx, 4
  07753	e8 00 00 00 00	 call	 _MemeReverseShapeNormals
  07758	83 c4 04	 add	 esp, 4

; 2606 : 				next;

  0775b	e9 06 89 ff ff	 jmp	 $L58091
$L59749:

; 2607 : 			}
; 2608 : 			/* objaddr textureptr -- */
; 2609 : 			case TEXTURECAMERA: {
; 2610 : 				cell tex;
; 2611 : 				Object *cam;
; 2612 : 				tex = pop;

  07760	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  07762	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]

; 2613 : 				cam = (Object *)apop;

  07766	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  07769	83 c3 04	 add	 ebx, 4

; 2614 : 				MemeTextureCamera(cam, tex);

  0776c	50		 push	 eax
  0776d	51		 push	 ecx
  0776e	89 54 24 14	 mov	 DWORD PTR _tos$[esp+312], edx
  07772	83 c3 04	 add	 ebx, 4
  07775	e8 00 00 00 00	 call	 _MemeTextureCamera
  0777a	83 c4 08	 add	 esp, 8

; 2615 : 				next;

  0777d	e9 e4 88 ff ff	 jmp	 $L58091
$L59759:

; 2620 : 					case DOCOLON:	*--rp = ip; ip = token; next;

  07782	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  07786	8b 55 08	 mov	 edx, DWORD PTR _ip$[ebp]
  07789	83 e9 04	 sub	 ecx, 4
  0778c	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax
  0778f	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  07793	89 11		 mov	 DWORD PTR [ecx], edx
  07795	e9 cc 88 ff ff	 jmp	 $L58091
$L59760:

; 2621 : 					case DOCON:		push ( *(cell *) (token) ); next;

  0779a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  0779e	83 eb 04	 sub	 ebx, 4
  077a1	89 0b		 mov	 DWORD PTR [ebx], ecx
  077a3	8b 10		 mov	 edx, DWORD PTR [eax]
  077a5	89 54 24 0c	 mov	 DWORD PTR _tos$[esp+304], edx
  077a9	e9 b8 88 ff ff	 jmp	 $L58091
$L59763:

; 2622 : 					case DOVAR:		push ( token ); next;

  077ae	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  077b2	83 eb 04	 sub	 ebx, 4
  077b5	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  077b9	89 0b		 mov	 DWORD PTR [ebx], ecx
  077bb	e9 a6 88 ff ff	 jmp	 $L58091
$L59765:

; 2623 : 					case DOUSER:	push ( *(cell *) token + (cell) up ); next;

  077c0	8b 54 24 0c	 mov	 edx, DWORD PTR _tos$[esp+304]
  077c4	83 eb 04	 sub	 ebx, 4
  077c7	89 13		 mov	 DWORD PTR [ebx], edx
  077c9	8b 00		 mov	 eax, DWORD PTR [eax]
  077cb	03 c7		 add	 eax, edi
  077cd	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  077d1	e9 90 88 ff ff	 jmp	 $L58091
$L59771:

; 2625 : 					case DOVOC:		V_CONTEXT = (cell)(token-1); next;

  077d6	83 c0 fc	 add	 eax, -4			; fffffffcH
  077d9	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax
  077df	e9 82 88 ff ff	 jmp	 $L58091
$L59773:

; 2626 : #ifdef REMOVE
; 2627 : 					case DOCODE:
; 2628 : # ifndef lint
; 2629 : 						(*(void (*) ())token)(); next;
; 2630 : # endif
; 2631 : #endif
; 2632 : 					default:	       /* DOES> meme */
; 2633 : 						/* Push parameter field address */
; 2634 : 						push ( token );

  077e4	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]

; 2635 : 	   					/* Use the code field as the address of a colon definition */
; 2636 : 	   					/* Maybe we should pick it up as a token? Then */
; 2637 : 	   					/* we could do ;code stuff by adding its code to the switch */
; 2638 : 						*--rp = ip;

  077e8	8b 55 08	 mov	 edx, DWORD PTR _ip$[ebp]
  077eb	83 eb 04	 sub	 ebx, 4
  077ee	89 44 24 0c	 mov	 DWORD PTR _tos$[esp+304], eax
  077f2	89 0b		 mov	 DWORD PTR [ebx], ecx
  077f4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  077f8	83 e9 04	 sub	 ecx, 4

; 2639 : 						ip = (token_t *)*--token;

  077fb	83 e8 04	 sub	 eax, 4
  077fe	89 4c 24 1c	 mov	 DWORD PTR _rp$[esp+304], ecx
  07802	89 11		 mov	 DWORD PTR [ecx], edx
  07804	8b 00		 mov	 eax, DWORD PTR [eax]
  07806	89 45 08	 mov	 DWORD PTR _ip$[ebp], eax

; 2640 : 						next;

  07809	e9 58 88 ff ff	 jmp	 $L58091
$L58322:

; 437  : 					}
; 438  : 				}
; 439  : 				/*
; 440  : 				 * Restore the local copies of the virtual machine registers
; 441  : 				 * to external copies and exit to the outer interpreter.
; 442  : 				 */
; 443  : 				SAVE_XCONTEXT

  0780e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _tos$[esp+304]
  07812	8b 54 24 1c	 mov	 edx, DWORD PTR _rp$[esp+304]
  07816	8b 44 24 10	 mov	 eax, DWORD PTR _ftos$[esp+304]
  0781a	83 eb 04	 sub	 ebx, 4
  0781d	83 ee 08	 sub	 esi, 8
  07820	89 0b		 mov	 DWORD PTR [ebx], ecx
  07822	8b 4c 24 14	 mov	 ecx, DWORD PTR _ftos$[esp+308]
  07826	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  0782c	89 15 00 00 00
	00		 mov	 DWORD PTR _xrp, edx
  07832	8b 54 24 20	 mov	 edx, DWORD PTR _frp$[esp+304]
  07836	89 06		 mov	 DWORD PTR [esi], eax
  07838	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0783b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi
  07841	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  07847	89 15 00 00 00
	00		 mov	 DWORD PTR _xfrp, edx

; 444  : 				return(0);

  0784d	33 c0		 xor	 eax, eax

; 2641 : 				}
; 2642 : 		} /* End of top level switch */
; 2643 : 	} /* End of for (;;) */
; 2644 : }

  0784f	5f		 pop	 edi
  07850	5e		 pop	 esi
  07851	5b		 pop	 ebx
  07852	8b e5		 mov	 esp, ebp
  07854	5d		 pop	 ebp
  07855	c3		 ret	 0
$L58325:

; 447  : 			case COLD:			longjmp(env, SETJMPRTNCOLDSTART);

  07856	68 c7 cf ff ff	 push	 -12345			; ffffcfc7H
  0785b	68 00 00 00 00	 push	 OFFSET FLAT:_env
  07860	e8 00 00 00 00	 call	 _longjmp
$L58304:

; 413  : 				}
; 414  : 				pop_all();

  07865	e8 00 00 00 00	 call	 _pop_all

; 415  : 				/*
; 416  : 				 * Restore the local copies of the virtual machine
; 417  : 				 * registers to the external copies and exit to the
; 418  : 				 * outer interpreter.
; 419  : 				 */
; 420  : 				V_BLK = 0;
; 421  : 				V_TICK_TIB = (cell)&tibbuf[0];
; 422  : 				SAVE_XCONTEXT

  0786a	8b 44 24 0c	 mov	 eax, DWORD PTR _tos$[esp+304]
  0786e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _rp$[esp+304]
  07872	8b 54 24 10	 mov	 edx, DWORD PTR _ftos$[esp+304]
  07876	83 eb 04	 sub	 ebx, 4
  07879	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  07880	c7 87 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+140], OFFSET FLAT:_tibbuf
  0788a	83 ee 08	 sub	 esi, 8
  0788d	89 03		 mov	 DWORD PTR [ebx], eax
  0788f	8b 44 24 14	 mov	 eax, DWORD PTR _ftos$[esp+308]
  07893	89 1d 00 00 00
	00		 mov	 DWORD PTR _xsp, ebx
  07899	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx
  0789f	8b 4c 24 20	 mov	 ecx, DWORD PTR _frp$[esp+304]
  078a3	89 16		 mov	 DWORD PTR [esi], edx
  078a5	89 46 04	 mov	 DWORD PTR [esi+4], eax
  078a8	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi
  078ae	89 35 00 00 00
	00		 mov	 DWORD PTR _xfsp, esi

; 2641 : 				}
; 2642 : 		} /* End of top level switch */
; 2643 : 	} /* End of for (;;) */
; 2644 : }

  078b4	5f		 pop	 edi
  078b5	5e		 pop	 esi
  078b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfrp, ecx
  078bc	b8 01 00 00 00	 mov	 eax, 1
  078c1	5b		 pop	 ebx
  078c2	8b e5		 mov	 esp, ebp
  078c4	5d		 pop	 ebp
  078c5	c3		 ret	 0
$L61945:
  078c6	8b ff		 npad	 2
$L61987:
  078c8	00 00 00 00	 DD	 $L58100
  078cc	00 00 00 00	 DD	 $L58104
  078d0	00 00 00 00	 DD	 $L58105
  078d4	00 00 00 00	 DD	 $L58106
  078d8	00 00 00 00	 DD	 $L58107
  078dc	00 00 00 00	 DD	 $L58108
  078e0	00 00 00 00	 DD	 $L58109
  078e4	00 00 00 00	 DD	 $L58110
  078e8	00 00 00 00	 DD	 $L58111
  078ec	00 00 00 00	 DD	 $L58116
  078f0	00 00 00 00	 DD	 $L58132
  078f4	00 00 00 00	 DD	 $L58133
  078f8	00 00 00 00	 DD	 $L58134
  078fc	00 00 00 00	 DD	 $L58135
  07900	00 00 00 00	 DD	 $L58137
  07904	00 00 00 00	 DD	 $L58138
  07908	00 00 00 00	 DD	 $L58139
  0790c	00 00 00 00	 DD	 $L58141
  07910	00 00 00 00	 DD	 $L58143
  07914	00 00 00 00	 DD	 $L58146
  07918	00 00 00 00	 DD	 $L58149
  0791c	00 00 00 00	 DD	 $L58152
  07920	00 00 00 00	 DD	 $L58153
  07924	00 00 00 00	 DD	 $L58154
  07928	00 00 00 00	 DD	 $L58155
  0792c	00 00 00 00	 DD	 $L58156
  07930	00 00 00 00	 DD	 $L58157
  07934	00 00 00 00	 DD	 $L58158
  07938	00 00 00 00	 DD	 $L58161
  0793c	00 00 00 00	 DD	 $L58162
  07940	00 00 00 00	 DD	 $L58163
  07944	00 00 00 00	 DD	 $L58164
  07948	00 00 00 00	 DD	 $L58167
  0794c	00 00 00 00	 DD	 $L58168
  07950	00 00 00 00	 DD	 $L58170
  07954	00 00 00 00	 DD	 $L58172
  07958	00 00 00 00	 DD	 $L58174
  0795c	00 00 00 00	 DD	 $L58175
  07960	00 00 00 00	 DD	 $L58177
  07964	00 00 00 00	 DD	 $L58179
  07968	00 00 00 00	 DD	 $L58181
  0796c	00 00 00 00	 DD	 $L58183
  07970	00 00 00 00	 DD	 $L58186
  07974	00 00 00 00	 DD	 $L58189
  07978	00 00 00 00	 DD	 $L58191
  0797c	00 00 00 00	 DD	 $L58195
  07980	00 00 00 00	 DD	 $L58199
  07984	00 00 00 00	 DD	 $L58204
  07988	00 00 00 00	 DD	 $L58208
  0798c	00 00 00 00	 DD	 $L58218
  07990	00 00 00 00	 DD	 $L58222
  07994	00 00 00 00	 DD	 $L58235
  07998	00 00 00 00	 DD	 $L58236
  0799c	00 00 00 00	 DD	 $L58243
  079a0	00 00 00 00	 DD	 $L58251
  079a4	00 00 00 00	 DD	 $L58262
  079a8	00 00 00 00	 DD	 $L58272
  079ac	00 00 00 00	 DD	 $L58274
  079b0	00 00 00 00	 DD	 $L58213
  079b4	00 00 00 00	 DD	 $L58636
  079b8	00 00 00 00	 DD	 $L58277
  079bc	00 00 00 00	 DD	 $abort$58103
  079c0	00 00 00 00	 DD	 $throwexit$58294
  079c4	00 00 00 00	 DD	 $L58323
  079c8	00 00 00 00	 DD	 $L58324
  079cc	00 00 00 00	 DD	 $L58325
  079d0	00 00 00 00	 DD	 $L58326
  079d4	00 00 00 00	 DD	 $L58329
  079d8	00 00 00 00	 DD	 $L58331
  079dc	00 00 00 00	 DD	 $L58332
  079e0	00 00 00 00	 DD	 $L58334
  079e4	00 00 00 00	 DD	 $L58338
  079e8	00 00 00 00	 DD	 $L58454
  079ec	00 00 00 00	 DD	 $L58341
  079f0	00 00 00 00	 DD	 $L58344
  079f4	00 00 00 00	 DD	 $L58348
  079f8	00 00 00 00	 DD	 $L58352
  079fc	00 00 00 00	 DD	 $L58472
  07a00	00 00 00 00	 DD	 $L58355
  07a04	00 00 00 00	 DD	 $L58358
  07a08	00 00 00 00	 DD	 $L58363
  07a0c	00 00 00 00	 DD	 $L58368
  07a10	00 00 00 00	 DD	 $L58377
  07a14	00 00 00 00	 DD	 $L58374
  07a18	00 00 00 00	 DD	 $L58423
  07a1c	00 00 00 00	 DD	 $L58383
  07a20	00 00 00 00	 DD	 $L58393
  07a24	00 00 00 00	 DD	 $L58386
  07a28	00 00 00 00	 DD	 $L58382
  07a2c	00 00 00 00	 DD	 $L58468
  07a30	00 00 00 00	 DD	 $L58418
  07a34	00 00 00 00	 DD	 $L58441
  07a38	00 00 00 00	 DD	 $L58491
  07a3c	00 00 00 00	 DD	 $L58403
  07a40	00 00 00 00	 DD	 $L58504
  07a44	00 00 00 00	 DD	 $L58484
  07a48	00 00 00 00	 DD	 $L58514
  07a4c	00 00 00 00	 DD	 $L58522
  07a50	00 00 00 00	 DD	 $L58525
  07a54	00 00 00 00	 DD	 $L58526
  07a58	00 00 00 00	 DD	 $L58253
  07a5c	00 00 00 00	 DD	 $L58254
  07a60	00 00 00 00	 DD	 $L61904
  07a64	00 00 00 00	 DD	 $L58260
  07a68	00 00 00 00	 DD	 $L58516
  07a6c	00 00 00 00	 DD	 $L58306
  07a70	00 00 00 00	 DD	 $L58580
  07a74	00 00 00 00	 DD	 $L58215
  07a78	00 00 00 00	 DD	 $L58235
  07a7c	00 00 00 00	 DD	 $L58534
  07a80	00 00 00 00	 DD	 $L58538
  07a84	00 00 00 00	 DD	 $L58546
  07a88	00 00 00 00	 DD	 $L58565
  07a8c	00 00 00 00	 DD	 $L58563
  07a90	00 00 00 00	 DD	 $L58556
  07a94	00 00 00 00	 DD	 $L58573
  07a98	00 00 00 00	 DD	 $L58570
  07a9c	00 00 00 00	 DD	 $L58226
  07aa0	00 00 00 00	 DD	 $L58228
  07aa4	00 00 00 00	 DD	 $L58577
  07aa8	00 00 00 00	 DD	 $L58581
  07aac	00 00 00 00	 DD	 $L58583
  07ab0	00 00 00 00	 DD	 $L58585
  07ab4	00 00 00 00	 DD	 $L58588
  07ab8	00 00 00 00	 DD	 $L58590
  07abc	00 00 00 00	 DD	 $L58592
  07ac0	00 00 00 00	 DD	 $L58594
  07ac4	00 00 00 00	 DD	 $L58596
  07ac8	00 00 00 00	 DD	 $L58413
  07acc	00 00 00 00	 DD	 $L58409
  07ad0	00 00 00 00	 DD	 $L58475
  07ad4	00 00 00 00	 DD	 $L58478
  07ad8	00 00 00 00	 DD	 $L58371
  07adc	00 00 00 00	 DD	 $L58598
  07ae0	00 00 00 00	 DD	 $L58619
  07ae4	00 00 00 00	 DD	 $L58623
  07ae8	00 00 00 00	 DD	 $L58432
  07aec	00 00 00 00	 DD	 $L58528
  07af0	00 00 00 00	 DD	 $L58467
  07af4	00 00 00 00	 DD	 $L58249
  07af8	00 00 00 00	 DD	 $L58126
  07afc	00 00 00 00	 DD	 $L58630
  07b00	00 00 00 00	 DD	 $L58631
  07b04	00 00 00 00	 DD	 $L58632
  07b08	00 00 00 00	 DD	 $L58634
  07b0c	00 00 00 00	 DD	 $L58638
  07b10	00 00 00 00	 DD	 $L58637
  07b14	00 00 00 00	 DD	 $L58640
  07b18	00 00 00 00	 DD	 $L58643
  07b1c	00 00 00 00	 DD	 $L58645
  07b20	00 00 00 00	 DD	 $L58647
  07b24	00 00 00 00	 DD	 $L58091
  07b28	00 00 00 00	 DD	 $L58651
  07b2c	00 00 00 00	 DD	 $L58674
  07b30	00 00 00 00	 DD	 $L58676
  07b34	00 00 00 00	 DD	 $L58677
  07b38	00 00 00 00	 DD	 $L58679
  07b3c	00 00 00 00	 DD	 $L58682
  07b40	00 00 00 00	 DD	 $L58704
  07b44	00 00 00 00	 DD	 $L58707
  07b48	00 00 00 00	 DD	 $L58712
  07b4c	00 00 00 00	 DD	 $L58715
  07b50	00 00 00 00	 DD	 $L58721
  07b54	00 00 00 00	 DD	 $L58731
  07b58	00 00 00 00	 DD	 $L58737
  07b5c	00 00 00 00	 DD	 $L58741
  07b60	00 00 00 00	 DD	 $L58745
  07b64	00 00 00 00	 DD	 $L58748
  07b68	00 00 00 00	 DD	 $L58753
  07b6c	00 00 00 00	 DD	 $L58756
  07b70	00 00 00 00	 DD	 $L58760
  07b74	00 00 00 00	 DD	 $L58654
  07b78	00 00 00 00	 DD	 $L58611
  07b7c	00 00 00 00	 DD	 $L58664
  07b80	00 00 00 00	 DD	 $L58669
  07b84	00 00 00 00	 DD	 $L58131
  07b88	00 00 00 00	 DD	 $L58762
  07b8c	00 00 00 00	 DD	 $L58783
  07b90	00 00 00 00	 DD	 $L58784
  07b94	00 00 00 00	 DD	 $L58785
  07b98	00 00 00 00	 DD	 $L58786
  07b9c	00 00 00 00	 DD	 $L58787
  07ba0	00 00 00 00	 DD	 $L58788
  07ba4	00 00 00 00	 DD	 $L58789
  07ba8	00 00 00 00	 DD	 $L58790
  07bac	00 00 00 00	 DD	 $L58791
  07bb0	00 00 00 00	 DD	 $L58792
  07bb4	00 00 00 00	 DD	 $L58793
  07bb8	00 00 00 00	 DD	 $L58794
  07bbc	00 00 00 00	 DD	 $L58795
  07bc0	00 00 00 00	 DD	 $L58796
  07bc4	00 00 00 00	 DD	 $L58797
  07bc8	00 00 00 00	 DD	 $L58798
  07bcc	00 00 00 00	 DD	 $L58799
  07bd0	00 00 00 00	 DD	 $L58800
  07bd4	00 00 00 00	 DD	 $L58801
  07bd8	00 00 00 00	 DD	 $L58802
  07bdc	00 00 00 00	 DD	 $L58803
  07be0	00 00 00 00	 DD	 $L58804
  07be4	00 00 00 00	 DD	 $L58805
  07be8	00 00 00 00	 DD	 $L58806
  07bec	00 00 00 00	 DD	 $L58807
  07bf0	00 00 00 00	 DD	 $L58808
  07bf4	00 00 00 00	 DD	 $L58809
  07bf8	00 00 00 00	 DD	 $L58810
  07bfc	00 00 00 00	 DD	 $L58811
  07c00	00 00 00 00	 DD	 $L58812
  07c04	00 00 00 00	 DD	 $L58813
  07c08	00 00 00 00	 DD	 $L58817
  07c0c	00 00 00 00	 DD	 $L58819
  07c10	00 00 00 00	 DD	 $L58821
  07c14	00 00 00 00	 DD	 $L58823
  07c18	00 00 00 00	 DD	 $L58831
  07c1c	00 00 00 00	 DD	 $L58833
  07c20	00 00 00 00	 DD	 $L58836
  07c24	00 00 00 00	 DD	 $L58839
  07c28	00 00 00 00	 DD	 $L58845
  07c2c	00 00 00 00	 DD	 $L58851
  07c30	00 00 00 00	 DD	 $L58853
  07c34	00 00 00 00	 DD	 $L58855
  07c38	00 00 00 00	 DD	 $L58857
  07c3c	00 00 00 00	 DD	 $L58859
  07c40	00 00 00 00	 DD	 $L58861
  07c44	00 00 00 00	 DD	 $L58863
  07c48	00 00 00 00	 DD	 $L58865
  07c4c	00 00 00 00	 DD	 $L58867
  07c50	00 00 00 00	 DD	 $L58869
  07c54	00 00 00 00	 DD	 $L58871
  07c58	00 00 00 00	 DD	 $L58873
  07c5c	00 00 00 00	 DD	 $L58875
  07c60	00 00 00 00	 DD	 $L58876
  07c64	00 00 00 00	 DD	 $L58880
  07c68	00 00 00 00	 DD	 $L58882
  07c6c	00 00 00 00	 DD	 $L59131
  07c70	00 00 00 00	 DD	 $L58606
  07c74	00 00 00 00	 DD	 $L58601
  07c78	00 00 00 00	 DD	 $L58600
  07c7c	00 00 00 00	 DD	 $L58120
  07c80	00 00 00 00	 DD	 $L58887
  07c84	00 00 00 00	 DD	 $L58916
  07c88	00 00 00 00	 DD	 $L58919
  07c8c	00 00 00 00	 DD	 $L58920
  07c90	00 00 00 00	 DD	 $L58921
  07c94	00 00 00 00	 DD	 $L58927
  07c98	00 00 00 00	 DD	 $L58928
  07c9c	00 00 00 00	 DD	 $L58287
  07ca0	00 00 00 00	 DD	 $L58659
  07ca4	00 00 00 00	 DD	 $L58279
  07ca8	00 00 00 00	 DD	 $L58242
  07cac	00 00 00 00	 DD	 $pause$58247
  07cb0	00 00 00 00	 DD	 $L58949
  07cb4	00 00 00 00	 DD	 $L58950
  07cb8	00 00 00 00	 DD	 $L58951
  07cbc	00 00 00 00	 DD	 $L58955
  07cc0	00 00 00 00	 DD	 $L58958
  07cc4	00 00 00 00	 DD	 $L58971
  07cc8	00 00 00 00	 DD	 $L58973
  07ccc	00 00 00 00	 DD	 $L58975
  07cd0	00 00 00 00	 DD	 $L58977
  07cd4	00 00 00 00	 DD	 $L58979
  07cd8	00 00 00 00	 DD	 $L58986
  07cdc	00 00 00 00	 DD	 $L58987
  07ce0	00 00 00 00	 DD	 $L58988
  07ce4	00 00 00 00	 DD	 $L58990
  07ce8	00 00 00 00	 DD	 $L58993
  07cec	00 00 00 00	 DD	 $L58994
  07cf0	00 00 00 00	 DD	 $L58996
  07cf4	00 00 00 00	 DD	 $L59008
  07cf8	00 00 00 00	 DD	 $L59015
  07cfc	00 00 00 00	 DD	 $L59042
  07d00	00 00 00 00	 DD	 $L59050
  07d04	00 00 00 00	 DD	 $L59056
  07d08	00 00 00 00	 DD	 $L59059
  07d0c	00 00 00 00	 DD	 $L59061
  07d10	00 00 00 00	 DD	 $L59063
  07d14	00 00 00 00	 DD	 $L59065
  07d18	00 00 00 00	 DD	 $L59074
  07d1c	00 00 00 00	 DD	 $L59075
  07d20	00 00 00 00	 DD	 $L59081
  07d24	00 00 00 00	 DD	 $L59086
  07d28	00 00 00 00	 DD	 $L59092
  07d2c	00 00 00 00	 DD	 $L59099
  07d30	00 00 00 00	 DD	 $L59106
  07d34	00 00 00 00	 DD	 $L59110
  07d38	00 00 00 00	 DD	 $L59112
  07d3c	00 00 00 00	 DD	 $L59115
  07d40	00 00 00 00	 DD	 $L59117
  07d44	00 00 00 00	 DD	 $L59119
  07d48	00 00 00 00	 DD	 $L59121
  07d4c	00 00 00 00	 DD	 $L59124
  07d50	00 00 00 00	 DD	 $L59135
  07d54	00 00 00 00	 DD	 $L59143
  07d58	00 00 00 00	 DD	 $L59147
  07d5c	00 00 00 00	 DD	 $L59104
  07d60	00 00 00 00	 DD	 $L59176
  07d64	00 00 00 00	 DD	 $L59178
  07d68	00 00 00 00	 DD	 $L59180
  07d6c	00 00 00 00	 DD	 $L59182
  07d70	00 00 00 00	 DD	 $L59184
  07d74	00 00 00 00	 DD	 $L59186
  07d78	00 00 00 00	 DD	 $L59191
  07d7c	00 00 00 00	 DD	 $L59197
  07d80	00 00 00 00	 DD	 $L59199
  07d84	00 00 00 00	 DD	 $L59201
  07d88	00 00 00 00	 DD	 $L59204
  07d8c	00 00 00 00	 DD	 $L59208
  07d90	00 00 00 00	 DD	 $L59211
  07d94	00 00 00 00	 DD	 $L59214
  07d98	00 00 00 00	 DD	 $L59216
  07d9c	00 00 00 00	 DD	 $L59221
  07da0	00 00 00 00	 DD	 $L59223
  07da4	00 00 00 00	 DD	 $L59227
  07da8	00 00 00 00	 DD	 $L59233
  07dac	00 00 00 00	 DD	 $L59242
  07db0	00 00 00 00	 DD	 $L59131
  07db4	00 00 00 00	 DD	 $L59247
  07db8	00 00 00 00	 DD	 $L59249
  07dbc	00 00 00 00	 DD	 $L59252
  07dc0	00 00 00 00	 DD	 $L59272
  07dc4	00 00 00 00	 DD	 $L59293
  07dc8	00 00 00 00	 DD	 $L59297
  07dcc	00 00 00 00	 DD	 $L59299
  07dd0	00 00 00 00	 DD	 $L59301
  07dd4	00 00 00 00	 DD	 $L59308
  07dd8	00 00 00 00	 DD	 $L59311
  07ddc	00 00 00 00	 DD	 $L59316
  07de0	00 00 00 00	 DD	 $L59321
  07de4	00 00 00 00	 DD	 $L59327
  07de8	00 00 00 00	 DD	 $L59331
  07dec	00 00 00 00	 DD	 $L59335
  07df0	00 00 00 00	 DD	 $L59339
  07df4	00 00 00 00	 DD	 $L59342
  07df8	00 00 00 00	 DD	 $L59345
  07dfc	00 00 00 00	 DD	 $L59299
  07e00	00 00 00 00	 DD	 $L59350
  07e04	00 00 00 00	 DD	 $L59353
  07e08	00 00 00 00	 DD	 $L59356
  07e0c	00 00 00 00	 DD	 $L59357
  07e10	00 00 00 00	 DD	 $L59359
  07e14	00 00 00 00	 DD	 $L59361
  07e18	00 00 00 00	 DD	 $L59368
  07e1c	00 00 00 00	 DD	 $L59371
  07e20	00 00 00 00	 DD	 $L59379
  07e24	00 00 00 00	 DD	 $L59387
  07e28	00 00 00 00	 DD	 $L59393
  07e2c	00 00 00 00	 DD	 $L59399
  07e30	00 00 00 00	 DD	 $L59407
  07e34	00 00 00 00	 DD	 $L59415
  07e38	00 00 00 00	 DD	 $L59421
  07e3c	00 00 00 00	 DD	 $L59426
  07e40	00 00 00 00	 DD	 $L59431
  07e44	00 00 00 00	 DD	 $L59433
  07e48	00 00 00 00	 DD	 $L59436
  07e4c	00 00 00 00	 DD	 $L59440
  07e50	00 00 00 00	 DD	 $L59443
  07e54	00 00 00 00	 DD	 $L59450
  07e58	00 00 00 00	 DD	 $L59452
  07e5c	00 00 00 00	 DD	 $L59455
  07e60	00 00 00 00	 DD	 $L59461
  07e64	00 00 00 00	 DD	 $L59469
  07e68	00 00 00 00	 DD	 $L59473
  07e6c	00 00 00 00	 DD	 $L59480
  07e70	00 00 00 00	 DD	 $L59485
  07e74	00 00 00 00	 DD	 $L59500
  07e78	00 00 00 00	 DD	 $L59522
  07e7c	00 00 00 00	 DD	 $L59530
  07e80	00 00 00 00	 DD	 $L59532
  07e84	00 00 00 00	 DD	 $L59534
  07e88	00 00 00 00	 DD	 $L59536
  07e8c	00 00 00 00	 DD	 $L59542
  07e90	00 00 00 00	 DD	 $L59547
  07e94	00 00 00 00	 DD	 $L59550
  07e98	00 00 00 00	 DD	 $L59552
  07e9c	00 00 00 00	 DD	 $L59555
  07ea0	00 00 00 00	 DD	 $L59557
  07ea4	00 00 00 00	 DD	 $L59559
  07ea8	00 00 00 00	 DD	 $L59560
  07eac	00 00 00 00	 DD	 $L59566
  07eb0	00 00 00 00	 DD	 $L59568
  07eb4	00 00 00 00	 DD	 $L59664
  07eb8	00 00 00 00	 DD	 $L59685
  07ebc	00 00 00 00	 DD	 $L59699
  07ec0	00 00 00 00	 DD	 $L59704
  07ec4	00 00 00 00	 DD	 $L59709
  07ec8	00 00 00 00	 DD	 $L59712
  07ecc	00 00 00 00	 DD	 $L59714
  07ed0	00 00 00 00	 DD	 $L59717
  07ed4	00 00 00 00	 DD	 $L59720
  07ed8	00 00 00 00	 DD	 $L59727
  07edc	00 00 00 00	 DD	 $L59735
  07ee0	00 00 00 00	 DD	 $L59742
  07ee4	00 00 00 00	 DD	 $L59745
  07ee8	00 00 00 00	 DD	 $L59749
$L61988:
  07eec	00 00 00 00	 DD	 $L59759
  07ef0	00 00 00 00	 DD	 $L59760
  07ef4	00 00 00 00	 DD	 $L59763
  07ef8	00 00 00 00	 DD	 $L59765
  07efc	00 00 00 00	 DD	 $L59769
  07f00	00 00 00 00	 DD	 $L59773
  07f04	00 00 00 00	 DD	 $L59771
$L61990:
  07f08	00 00 00 00	 DD	 $L61644
  07f0c	00 00 00 00	 DD	 $L61649
  07f10	00 00 00 00	 DD	 $L61650
$L61989:
  07f14	00		 DB	 0
  07f15	02		 DB	 2
  07f16	00		 DB	 0
  07f17	00		 DB	 0
  07f18	02		 DB	 2
  07f19	00		 DB	 0
  07f1a	00		 DB	 0
  07f1b	00		 DB	 0
  07f1c	00		 DB	 0
  07f1d	00		 DB	 0
  07f1e	00		 DB	 0
  07f1f	00		 DB	 0
  07f20	00		 DB	 0
  07f21	00		 DB	 0
  07f22	00		 DB	 0
  07f23	02		 DB	 2
  07f24	02		 DB	 2
  07f25	02		 DB	 2
  07f26	02		 DB	 2
  07f27	02		 DB	 2
  07f28	02		 DB	 2
  07f29	02		 DB	 2
  07f2a	02		 DB	 2
  07f2b	02		 DB	 2
  07f2c	02		 DB	 2
  07f2d	02		 DB	 2
  07f2e	01		 DB	 1
  07f2f	02		 DB	 2
  07f30	02		 DB	 2
  07f31	02		 DB	 2
  07f32	02		 DB	 2
  07f33	02		 DB	 2
  07f34	02		 DB	 2
  07f35	02		 DB	 2
  07f36	02		 DB	 2
  07f37	02		 DB	 2
  07f38	02		 DB	 2
  07f39	02		 DB	 2
  07f3a	02		 DB	 2
  07f3b	02		 DB	 2
  07f3c	02		 DB	 2
  07f3d	02		 DB	 2
  07f3e	02		 DB	 2
  07f3f	02		 DB	 2
  07f40	02		 DB	 2
  07f41	02		 DB	 2
  07f42	02		 DB	 2
  07f43	02		 DB	 2
  07f44	02		 DB	 2
  07f45	02		 DB	 2
  07f46	02		 DB	 2
  07f47	02		 DB	 2
  07f48	02		 DB	 2
  07f49	02		 DB	 2
  07f4a	02		 DB	 2
  07f4b	02		 DB	 2
  07f4c	02		 DB	 2
  07f4d	02		 DB	 2
  07f4e	01		 DB	 1
_inner_interpreter ENDP
_TEXT	ENDS
PUBLIC	_init_dictionary
PUBLIC	_init_entries
_TEXT	SEGMENT
_init_dictionary PROC NEAR

; 2656 :     XV_NUM_USER = NEXT_VAR*sizeof(cell);

  07f50	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  07f55	56		 push	 esi
  07f56	c7 00 f0 00 00
	00		 mov	 DWORD PTR [eax], 240	; 000000f0H

; 2657 :     XV_TICK_TIB = (cell)&tibbuf[0];

  07f5c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  07f62	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], OFFSET FLAT:_tibbuf

; 2658 : 
; 2659 :     tokstore((token_t)origin, &XV_DP);

  07f6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  07f72	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin
  07f77	83 c2 70	 add	 edx, 112		; 00000070H
  07f7a	52		 push	 edx
  07f7b	50		 push	 eax
  07f7c	e8 00 00 00 00	 call	 _tokstore

; 2660 : 
; 2661 :     /* reserve space for an array of pointers to the cfa of prim headers */
; 2662 :     XDP += (cell)NEXT_PRIM;

  07f81	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup

; 2663 :     tempvoc.code_field= (token_t)DOVOC;
; 2664 :     tempvoc.last_word = (dict_entry_t *)origin;
; 2665 :     tempvoc.voc_link  = (cell *)origin;
; 2666 : 
; 2667 :     XV_CURRENT = (cell)&tempvoc;
; 2668 :     XV_CONTEXT = (cell)&tempvoc;
; 2669 : 
; 2670 :     /* Make the initial dictionary entry header and code field */
; 2671 :     quote_create((u_char *)"\4main", (token_t)DOVOC);

  07f86	68 97 01 00 00	 push	 407			; 00000197H
  07f8b	68 00 00 00 00	 push	 OFFSET FLAT:$SG59790
  07f90	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  07f93	81 c1 24 06 00
	00		 add	 ecx, 1572		; 00000624H
  07f99	89 48 70	 mov	 DWORD PTR [eax+112], ecx
  07f9c	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin
  07fa1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  07fa7	a3 04 00 00 00	 mov	 DWORD PTR _tempvoc+4, eax
  07fac	a3 08 00 00 00	 mov	 DWORD PTR _tempvoc+8, eax
  07fb1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_tempvoc
  07fb6	c7 05 00 00 00
	00 97 01 00 00	 mov	 DWORD PTR _tempvoc, 407	; 00000197H
  07fc0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  07fc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  07fc9	89 82 b0 00 00
	00		 mov	 DWORD PTR [edx+176], eax
  07fcf	e8 00 00 00 00	 call	 _quote_create

; 2672 : 
; 2673 : 
; 2674 :     /* Set current and context to point at the code field of the initial
; 2675 :      * dictionary entry
; 2676 :      */
; 2677 :     tokstore((token_t)(XDP-1), &XV_CONTEXT);

  07fd4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  07fd9	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  07fdc	8d 88 b0 00 00
	00		 lea	 ecx, DWORD PTR [eax+176]
  07fe2	83 ea 04	 sub	 edx, 4
  07fe5	51		 push	 ecx
  07fe6	52		 push	 edx
  07fe7	e8 00 00 00 00	 call	 _tokstore

; 2678 :     tokstore((token_t)(XDP-1), &XV_CURRENT);

  07fec	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  07ff1	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  07ff4	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  07ff7	83 ea 04	 sub	 edx, 4
  07ffa	51		 push	 ecx
  07ffb	52		 push	 edx
  07ffc	e8 00 00 00 00	 call	 _tokstore

; 2679 : 
; 2680 : /* This needs to be changed for hashing */
; 2681 : #ifdef RELOCATE
; 2682 :     set_relocation_bit(XDP);

  08001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08007	83 c4 20	 add	 esp, 32			; 00000020H
  0800a	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  08010	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  08013	85 d2		 test	 edx, edx
  08015	74 13		 je	 SHORT $L62007
  08017	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0801a	2b c1		 sub	 eax, ecx

; 2694 : 
; 2695 :     init_entries();

  0801c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0801f	c1 f8 02	 sar	 eax, 2
  08022	03 c2		 add	 eax, edx
  08024	c6 04 08 03	 mov	 BYTE PTR [eax+ecx], 3
  08028	eb 62		 jmp	 SHORT $L62021

; 2679 : 
; 2680 : /* This needs to be changed for hashing */
; 2681 : #ifdef RELOCATE
; 2682 :     set_relocation_bit(XDP);

$L62007:
  0802a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _origin
  08030	8b d0		 mov	 edx, eax
  08032	2b d6		 sub	 edx, esi
  08034	c1 fa 02	 sar	 edx, 2
  08037	78 26		 js	 SHORT $L62017
  08039	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR _main_task+112
  0803f	77 1e		 ja	 SHORT $L62017
  08041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _relmap
  08047	8b c2		 mov	 eax, edx
  08049	c1 f8 03	 sar	 eax, 3
  0804c	03 c1		 add	 eax, ecx
  0804e	83 e2 07	 and	 edx, 7
  08051	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _bit[edx]
  08057	8a 08		 mov	 cl, BYTE PTR [eax]
  08059	0a ca		 or	 cl, dl
  0805b	88 08		 mov	 BYTE PTR [eax], cl
  0805d	eb 2d		 jmp	 SHORT $L62021
$L62017:
  0805f	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:_main_task
  08064	c1 f8 02	 sar	 eax, 2
  08067	78 29		 js	 SHORT $L62018
  08069	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0806e	73 22		 jae	 SHORT $L62018
  08070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _urelmap
  08076	8b c8		 mov	 ecx, eax
  08078	c1 f9 03	 sar	 ecx, 3
  0807b	03 ca		 add	 ecx, edx
  0807d	83 e0 07	 and	 eax, 7
  08080	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _bit[eax]
  08086	8a 11		 mov	 dl, BYTE PTR [ecx]
  08088	0a d0		 or	 dl, al
  0808a	88 11		 mov	 BYTE PTR [ecx], dl
$L62021:
  0808c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
$L62018:

; 2683 : #endif
; 2684 : 
; 2685 :     /* Comma the top word in the dictionary */
; 2686 :     xlinkcomma(tempvoc.last_word);

  08092	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  08095	50		 push	 eax
  08096	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  08099	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  0809c	a1 04 00 00 00	 mov	 eax, DWORD PTR _tempvoc+4
  080a1	50		 push	 eax
  080a2	e8 00 00 00 00	 call	 _tokstore

; 2687 : 
; 2688 : 
; 2689 :     /* Set the VOC-LINK user variable */
; 2690 :     tokstore((token_t)XDP, &XV_VOC_LINK);

  080a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  080ac	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  080af	8d 48 3c	 lea	 ecx, DWORD PTR [eax+60]
  080b2	51		 push	 ecx
  080b3	52		 push	 edx
  080b4	e8 00 00 00 00	 call	 _tokstore

; 2691 : 
; 2692 :     /* Compile the vocabulary link pointer */
; 2693 :     xlinkcomma(0);		/* voc-link XXX should be origin */

  080b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  080bf	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  080c2	50		 push	 eax
  080c3	6a 00		 push	 0
  080c5	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  080c8	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  080cb	e8 00 00 00 00	 call	 _tokstore
  080d0	83 c4 18	 add	 esp, 24			; 00000018H

; 2694 : 
; 2695 :     init_entries();

  080d3	e8 00 00 00 00	 call	 _init_entries
  080d8	5e		 pop	 esi

; 2696 : }

  080d9	c3		 ret	 0
_init_dictionary ENDP
_TEXT	ENDS
PUBLIC	_init_variables
EXTRN	_parameter_stack:BYTE
EXTRN	_return_stack:BYTE
EXTRN	_floatstack:BYTE
EXTRN	_DeckModule:DWORD
EXTRN	_currentDay:DWORD
EXTRN	_currentMonth:DWORD
EXTRN	_currentYear:DWORD
_TEXT	SEGMENT
_timevar$ = -4
_init_variables PROC NEAR

; 2700 : {

  080e0	51		 push	 ecx

; 2701 : 	struct tm *curTime;
; 2702 : 	time_t timevar;
; 2703 : 
; 2704 :     comp_level = 0;
; 2705 :     nlocnames = 0;
; 2706 :     XV_SPAN = XV_TO_IN = XV_BLK = XV_NUM_TIB = 0;

  080e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  080e7	33 c0		 xor	 eax, eax
  080e9	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax
  080ee	a3 00 00 00 00	 mov	 DWORD PTR _nlocnames, eax
  080f3	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  080f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup

; 2707 :     XV_NUM_OUT = XV_NUM_LINE = 0;
; 2708 :     /* This is not redundant with the similar line in init_dictionary,
; 2709 :      * because init_dictionary is not executed when loading from a .dic file.
; 2710 :      */
; 2711 :     XV_TICK_TIB = (cell)&tibbuf[0];
; 2712 :     XV_BASE = 10;
; 2713 :     XV_TICK_EXPECT = (cell)SYS_EXPECT;
; 2714 :     XV_STATE = INTERPRETING;
; 2715 :     XV_SPZERO  = (cell)ps_top;
; 2716 :     XV_RPZERO  = (cell)&return_stack[RSSIZE];
; 2717 :     XV_UPZERO  = (cell)xup;
; 2718 :     XV_FPZERO  = (cell)&floatstack[FSTKLEN];
; 2719 :     XV_LINK = (cell)xup;		/* Link main task to self */
; 2720 :     multitasking = -1;
; 2721 :     XV_TASK_ACTIVE = -1;
; 2722 :     XV_WARNING = 1;
; 2723 :     XV_DPL = -1;
; 2724 :     XV_CNT = -1;		/* Signifies debug support not present */
; 2725 :     XV_DEBUGGING = XV_IP_L = XV_IP_H = 0;
; 2726 :     XV_MOD_COMP = 0;	/* Not compiling into a module -MdG */
; 2727 :     XV_MOD_LINK = 0;	/* No named modules currently exist */
; 2728 : 	XV_NAMEDTASK = 0;	/* The main task is unnamed.  Even though .Task
; 2729 : 						 * doesn't use this variable for printing the main
; 2730 : 						 * task, this variable is copied from the main task
; 2731 : 						 * when a new task is initialized.  This is a
; 2732 : 						 * way of initializing it.
; 2733 : 						 */
; 2734 : 	XV_PERTASK = 0;
; 2735 : 	XV_REGIONVAR = 0;
; 2736 :     DebuggerData._debug_in_progress = 0;
; 2737 : 	DeckModule = 0;		/* Reset the deck module ID if re-entering after
; 2738 : 						 * handling a signal
; 2739 : 						 */
; 2740 : 	maintaskReceiver = 0;
; 2741 : 
; 2742 : 	timevar = time((time_t *)0);

  080fc	50		 push	 eax
  080fd	89 42 10	 mov	 DWORD PTR [edx+16], eax
  08100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08106	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  08109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0810f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  08112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08118	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0811b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08121	89 42 34	 mov	 DWORD PTR [edx+52], eax
  08124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  0812a	c7 81 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+140], OFFSET FLAT:_tibbuf
  08134	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0813a	c7 42 0c 0a 00
	00 00		 mov	 DWORD PTR [edx+12], 10	; 0000000aH
  08141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08147	c7 41 58 f7 00
	00 00		 mov	 DWORD PTR [ecx+88], 247	; 000000f7H
  0814e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08154	89 42 18	 mov	 DWORD PTR [edx+24], eax
  08157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  0815d	c7 41 24 00 04
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET FLAT:_parameter_stack+1024
  08164	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0816a	c7 42 28 00 04
	00 00		 mov	 DWORD PTR [edx+40], OFFSET FLAT:_return_stack+1024
  08171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08177	89 49 2c	 mov	 DWORD PTR [ecx+44], ecx
  0817a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08180	c7 81 98 00 00
	00 00 01 00 00	 mov	 DWORD PTR [ecx+152], OFFSET FLAT:_floatstack+256
  0818a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08190	89 49 5c	 mov	 DWORD PTR [ecx+92], ecx
  08193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08199	83 c9 ff	 or	 ecx, -1
  0819c	89 0d 00 00 00
	00		 mov	 DWORD PTR _multitasking, ecx
  081a2	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
  081a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  081ab	c7 42 44 01 00
	00 00		 mov	 DWORD PTR [edx+68], 1
  081b2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  081b8	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
  081bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  081c1	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx
  081c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  081cd	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax
  081d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  081d9	89 42 7c	 mov	 DWORD PTR [edx+124], eax
  081dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  081e2	89 41 74	 mov	 DWORD PTR [ecx+116], eax
  081e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  081eb	89 82 88 00 00
	00		 mov	 DWORD PTR [edx+136], eax
  081f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  081f7	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax
  081fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08203	89 82 a0 00 00
	00		 mov	 DWORD PTR [edx+160], eax
  08209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  0820f	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax
  08215	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0821b	89 82 ac 00 00
	00		 mov	 DWORD PTR [edx+172], eax
  08221	a3 08 00 00 00	 mov	 DWORD PTR _DebuggerData+8, eax
  08226	a3 00 00 00 00	 mov	 DWORD PTR _DeckModule, eax
  0822b	a3 00 00 00 00	 mov	 DWORD PTR _maintaskReceiver, eax
  08230	e8 00 00 00 00	 call	 _time
  08235	89 44 24 04	 mov	 DWORD PTR _timevar$[esp+8], eax

; 2743 : 	curTime = localtime(&timevar);

  08239	8d 44 24 04	 lea	 eax, DWORD PTR _timevar$[esp+8]
  0823d	50		 push	 eax
  0823e	e8 00 00 00 00	 call	 _localtime

; 2744 : 	currentDay = curTime->tm_mday;

  08243	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  08246	89 0d 00 00 00
	00		 mov	 DWORD PTR _currentDay, ecx

; 2745 : 	currentMonth = curTime->tm_mon;

  0824c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0824f	89 15 00 00 00
	00		 mov	 DWORD PTR _currentMonth, edx

; 2746 : 	currentYear = curTime->tm_year;

  08255	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  08258	a3 00 00 00 00	 mov	 DWORD PTR _currentYear, eax

; 2747 : }

  0825d	83 c4 0c	 add	 esp, 12			; 0000000cH
  08260	c3		 ret	 0
_init_variables ENDP
_TEXT	ENDS
EXTRN	__imp__MessageBoxA@16:NEAR
_TEXT	SEGMENT
_next_uvar$ = -4
_init_entries PROC NEAR

; 2751 : {

  08270	51		 push	 ecx
  08271	53		 push	 ebx
  08272	55		 push	 ebp
  08273	56		 push	 esi
  08274	57		 push	 edi

; 2752 :     u_char *command;
; 2753 :     int immediate;
; 2754 :     int next_prim = 1;
; 2755 :     int next_uvar = 0;
; 2756 : 
; 2757 :     load((u_char *)INIT_FILENAME);

  08275	68 00 00 00 00	 push	 OFFSET FLAT:$SG59819
  0827a	bb 01 00 00 00	 mov	 ebx, 1
  0827f	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _next_uvar$[esp+24], 0
  08287	e8 00 00 00 00	 call	 _load
  0828c	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__MessageBoxA@16
  08292	83 c4 04	 add	 esp, 4
$L59821:

; 2758 :     while (1) {
; 2759 : 	cexpect(tibbuf, (cell)TIBSIZE);

  08295	68 00 01 00 00	 push	 256			; 00000100H
  0829a	68 00 00 00 00	 push	 OFFSET FLAT:_tibbuf
  0829f	e8 00 00 00 00	 call	 _cexpect

; 2760 : 	XV_NUM_TIB = XV_SPAN;

  082a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup

; 2761 : 	XV_TO_IN = 0;

  082a9	33 f6		 xor	 esi, esi
  082ab	83 c4 08	 add	 esp, 8
  082ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  082b1	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  082b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  082ba	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 2762 : 
; 2763 : 	command = blword();

  082bd	e8 00 00 00 00	 call	 _blword

; 2764 : 	if ( *command == 0 )

  082c2	80 38 00	 cmp	 BYTE PTR [eax], 0
  082c5	0f 84 10 01 00
	00		 je	 $L62028

; 2765 : 	    break;
; 2766 : #ifdef NOISY
; 2767 : printf("Word: %s\n", tibbuf);
; 2768 : #endif
; 2769 : 	immediate = 0;
; 2770 : 	switch ( command[1] ) {

  082cb	33 c9		 xor	 ecx, ecx
  082cd	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  082d0	83 c1 9b	 add	 ecx, -101		; ffffff9bH
  082d3	83 f9 11	 cmp	 ecx, 17			; 00000011H
  082d6	0f 87 91 00 00
	00		 ja	 $L59841
  082dc	33 d2		 xor	 edx, edx
  082de	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR $L62029[ecx]
  082e4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L62030[edx*4]
$L59829:

; 2771 : 	case 'i':
; 2772 : 		immediate  = 1;

  082eb	be 01 00 00 00	 mov	 esi, 1
$L59830:

; 2773 : 	case 'p':
; 2774 : 		quote_create( blword(), (token_t)next_prim );

  082f0	53		 push	 ebx
  082f1	e8 00 00 00 00	 call	 _blword
  082f6	50		 push	 eax
  082f7	e8 00 00 00 00	 call	 _quote_create
  082fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin

; 2775 : 		tokstore((token_t)(XDP-1), &origin[next_prim]);

  08301	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08307	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  0830a	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  0830d	83 e8 04	 sub	 eax, 4
  08310	51		 push	 ecx
  08311	50		 push	 eax
  08312	e8 00 00 00 00	 call	 _tokstore
  08317	83 c4 10	 add	 esp, 16			; 00000010H

; 2776 : 		if ( immediate ) makeimmediate();

  0831a	85 f6		 test	 esi, esi
  0831c	74 0d		 je	 SHORT $L62025
  0831e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08324	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  08327	80 48 04 01	 or	 BYTE PTR [eax+4], 1
$L62025:

; 2777 : 		next_prim++;

  0832b	43		 inc	 ebx

; 2778 : 		break;

  0832c	e9 64 ff ff ff	 jmp	 $L59821
$L59835:

; 2779 : 	case 'v':
; 2780 : 	case 'u':
; 2781 : 		quote_create( blword(), (token_t)DOUSER );

  08331	68 94 01 00 00	 push	 404			; 00000194H
  08336	e8 00 00 00 00	 call	 _blword
  0833b	50		 push	 eax
  0833c	e8 00 00 00 00	 call	 _quote_create

; 2782 : #ifdef REMOVE
; 2783 : 		ncomma(next_uvar);
; 2784 : #else
; 2785 : 		*XDP++ = (cell)next_uvar;

  08341	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08347	8b 4c 24 18	 mov	 ecx, DWORD PTR _next_uvar$[esp+28]
  0834b	83 c4 08	 add	 esp, 8
  0834e	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  08351	89 08		 mov	 DWORD PTR [eax], ecx
  08353	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08358	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  0835b	83 c2 04	 add	 edx, 4

; 2786 : #endif
; 2787 : 		next_uvar += sizeof(cell);

  0835e	83 c1 04	 add	 ecx, 4
  08361	89 50 70	 mov	 DWORD PTR [eax+112], edx
  08364	89 4c 24 10	 mov	 DWORD PTR _next_uvar$[esp+20], ecx

; 2788 : 		break;

  08368	e9 28 ff ff ff	 jmp	 $L59821
$L59841:

; 2789 : 	case 'e':
; 2790 : 		return;
; 2791 : 	default:
; 2792 : 		strcpy(errMsg, "Unknown command while initializing the dictionary: ");

  0836d	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  08372	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG59842
  08377	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg

; 2793 : 		strcat(errMsg, (char *)command);
; 2794 : 		strcat(errMsg, "\n");
; 2795 : 		MessageBox(NULL, errMsg, "Fatal error", MB_OK);

  0837c	6a 00		 push	 0
  0837e	f3 a5		 rep movsd
  08380	8b f8		 mov	 edi, eax
  08382	83 c9 ff	 or	 ecx, -1
  08385	33 c0		 xor	 eax, eax
  08387	68 00 00 00 00	 push	 OFFSET FLAT:$SG59846
  0838c	f2 ae		 repne scasb
  0838e	f7 d1		 not	 ecx
  08390	2b f9		 sub	 edi, ecx
  08392	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  08397	8b f7		 mov	 esi, edi
  08399	8b d1		 mov	 edx, ecx
  0839b	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  083a0	83 c9 ff	 or	 ecx, -1
  083a3	f2 ae		 repne scasb
  083a5	8b ca		 mov	 ecx, edx
  083a7	4f		 dec	 edi
  083a8	c1 e9 02	 shr	 ecx, 2
  083ab	f3 a5		 rep movsd
  083ad	8b ca		 mov	 ecx, edx
  083af	6a 00		 push	 0
  083b1	83 e1 03	 and	 ecx, 3
  083b4	f3 a4		 rep movsb
  083b6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  083bb	83 c9 ff	 or	 ecx, -1
  083be	f2 ae		 repne scasb
  083c0	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG59844
  083c6	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  083ca	ff d5		 call	 ebp

; 2796 : 		ExitMeme(MEMEDICTBUILDSTATUS);

  083cc	6a 05		 push	 5
  083ce	e8 00 00 00 00	 call	 _ExitMeme
  083d3	83 c4 04	 add	 esp, 4
  083d6	e9 ba fe ff ff	 jmp	 $L59821
$L62028:
  083db	5f		 pop	 edi
  083dc	5e		 pop	 esi
  083dd	5d		 pop	 ebp
  083de	5b		 pop	 ebx

; 2797 : 	}
; 2798 :     }
; 2799 : }

  083df	59		 pop	 ecx
  083e0	c3		 ret	 0
  083e1	8d 49 00	 npad	 3
$L62030:
  083e4	00 00 00 00	 DD	 $L62028
  083e8	00 00 00 00	 DD	 $L59829
  083ec	00 00 00 00	 DD	 $L59830
  083f0	00 00 00 00	 DD	 $L59835
  083f4	00 00 00 00	 DD	 $L59841
$L62029:
  083f8	00		 DB	 0
  083f9	04		 DB	 4
  083fa	04		 DB	 4
  083fb	04		 DB	 4
  083fc	01		 DB	 1
  083fd	04		 DB	 4
  083fe	04		 DB	 4
  083ff	04		 DB	 4
  08400	04		 DB	 4
  08401	04		 DB	 4
  08402	04		 DB	 4
  08403	02		 DB	 2
  08404	04		 DB	 4
  08405	04		 DB	 4
  08406	04		 DB	 4
  08407	04		 DB	 4
  08408	03		 DB	 3
  08409	03		 DB	 3
_init_entries ENDP
_TEXT	ENDS
PUBLIC	_read_dictionary
EXTRN	_fread:NEAR
EXTRN	_fatal:NEAR
_TEXT	SEGMENT
_name$ = 8
_tmpstr$ = -52
_fd$ = 8
_header$ = -84
_read_dictionary PROC NEAR

; 2804 : {

  08410	83 ec 54	 sub	 esp, 84			; 00000054H

; 2805 :     char tmpstr[50];
; 2806 :     size_t actual;
; 2807 :     FILE *fd;
; 2808 :     struct {
; 2809 : 		cell magic, serial, dstart, dsize, ustart, usize, entry, res1;
; 2810 :     } header;
; 2811 : 
; 2812 : #define MAGIC 0x581120
; 2813 :     if ((fd = fopen(name, "rb")) == NULL) {

  08413	8b 44 24 58	 mov	 eax, DWORD PTR _name$[esp+80]
  08417	53		 push	 ebx
  08418	55		 push	 ebp
  08419	56		 push	 esi
  0841a	57		 push	 edi
  0841b	68 00 00 00 00	 push	 OFFSET FLAT:$SG59865
  08420	50		 push	 eax
  08421	e8 00 00 00 00	 call	 _fopen
  08426	8b d8		 mov	 ebx, eax
  08428	83 c4 08	 add	 esp, 8
  0842b	85 db		 test	 ebx, ebx
  0842d	89 5c 24 68	 mov	 DWORD PTR _fd$[esp+96], ebx
  08431	75 0f		 jne	 SHORT $L59864

; 2814 : 		fatal("Can't open dictionary file\n", MEMEDICTALLOCSTATUS);

  08433	6a 0b		 push	 11			; 0000000bH
  08435	68 00 00 00 00	 push	 OFFSET FLAT:$SG59866
  0843a	e8 00 00 00 00	 call	 _fatal
  0843f	83 c4 08	 add	 esp, 8
$L59864:

; 2815 : 	}
; 2816 : 
; 2817 :     actual = fread((char *)&header, 1, sizeof(header), fd);

  08442	53		 push	 ebx
  08443	6a 20		 push	 32			; 00000020H
  08445	8d 4c 24 18	 lea	 ecx, DWORD PTR _header$[esp+108]
  08449	6a 01		 push	 1
  0844b	51		 push	 ecx
  0844c	e8 00 00 00 00	 call	 _fread
  08451	83 c4 10	 add	 esp, 16			; 00000010H

; 2818 :     if (actual != sizeof(header)) {

  08454	83 f8 20	 cmp	 eax, 32			; 00000020H
  08457	74 0f		 je	 SHORT $L59868

; 2819 : 		fatal("Can't read header\n", MEMEDICTALLOCSTATUS);

  08459	6a 0b		 push	 11			; 0000000bH
  0845b	68 00 00 00 00	 push	 OFFSET FLAT:$SG59869
  08460	e8 00 00 00 00	 call	 _fatal
  08465	83 c4 08	 add	 esp, 8
$L59868:

; 2820 : 	}
; 2821 : 
; 2822 :     if (header.magic != MAGIC) {

  08468	81 7c 24 10 20
	11 58 00	 cmp	 DWORD PTR _header$[esp+100], 5771552 ; 00581120H
  08470	74 0f		 je	 SHORT $L59870

; 2823 : 		fatal("Bad magic number in dictionary file\n", MEMEDICTALLOCSTATUS);

  08472	6a 0b		 push	 11			; 0000000bH
  08474	68 00 00 00 00	 push	 OFFSET FLAT:$SG59871
  08479	e8 00 00 00 00	 call	 _fatal
  0847e	83 c4 08	 add	 esp, 8
$L59870:

; 2824 : 	}
; 2825 : 
; 2826 : #ifndef RELOCATE
; 2827 :     if (header.dstart != (cell)origin)
; 2828 : 	fatal("Remake the dictionary file\n", MEMEDICTALLOCSTATUS);
; 2829 : #endif
; 2830 : 
; 2831 :     actual = fread((char *)origin, 1, header.dsize, fd);

  08481	8b 54 24 1c	 mov	 edx, DWORD PTR _header$[esp+112]
  08485	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin
  0848a	53		 push	 ebx
  0848b	52		 push	 edx
  0848c	6a 01		 push	 1
  0848e	50		 push	 eax
  0848f	e8 00 00 00 00	 call	 _fread

; 2832 :     if (actual != (u_cell)header.dsize) {

  08494	8b 4c 24 2c	 mov	 ecx, DWORD PTR _header$[esp+128]
  08498	83 c4 10	 add	 esp, 16			; 00000010H
  0849b	3b c1		 cmp	 eax, ecx
  0849d	74 25		 je	 SHORT $L59874

; 2833 : 		sprintf(tmpstr, "Can't read dictionary image.  File position: %lu\n", ftell(fd));

  0849f	53		 push	 ebx
  084a0	e8 00 00 00 00	 call	 _ftell
  084a5	50		 push	 eax
  084a6	8d 4c 24 38	 lea	 ecx, DWORD PTR _tmpstr$[esp+108]
  084aa	68 00 00 00 00	 push	 OFFSET FLAT:$SG59875
  084af	51		 push	 ecx
  084b0	e8 00 00 00 00	 call	 _sprintf

; 2834 : 		fatal(tmpstr, MEMEDICTALLOCSTATUS);

  084b5	8d 54 24 40	 lea	 edx, DWORD PTR _tmpstr$[esp+116]
  084b9	6a 0b		 push	 11			; 0000000bH
  084bb	52		 push	 edx
  084bc	e8 00 00 00 00	 call	 _fatal
  084c1	83 c4 18	 add	 esp, 24			; 00000018H
$L59874:

; 2835 :     }
; 2836 : 
; 2837 :     XV_DP = (cell) ((cell *)((char *)origin + header.dsize)); /* Ptr align */

  084c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _origin
  084c9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _header$[esp+112]
  084cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  084d3	03 c1		 add	 eax, ecx

; 2838 : 
; 2839 :     actual = fread((char *)xup, 1, header.usize, fd);

  084d5	53		 push	 ebx
  084d6	89 42 70	 mov	 DWORD PTR [edx+112], eax
  084d9	8b 44 24 28	 mov	 eax, DWORD PTR _header$[esp+124]
  084dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  084e3	50		 push	 eax
  084e4	6a 01		 push	 1
  084e6	51		 push	 ecx
  084e7	e8 00 00 00 00	 call	 _fread

; 2840 :     if (actual != (u_cell)header.usize) {

  084ec	8b 4c 24 34	 mov	 ecx, DWORD PTR _header$[esp+136]
  084f0	83 c4 10	 add	 esp, 16			; 00000010H
  084f3	3b c1		 cmp	 eax, ecx
  084f5	74 0f		 je	 SHORT $L59881

; 2841 : 		fatal("Can't read user area image\n", MEMEDICTALLOCSTATUS);

  084f7	6a 0b		 push	 11			; 0000000bH
  084f9	68 00 00 00 00	 push	 OFFSET FLAT:$SG59882
  084fe	e8 00 00 00 00	 call	 _fatal
  08503	83 c4 08	 add	 esp, 8
$L59881:

; 2842 :     }
; 2843 : #ifdef RELOCATE
; 2844 :     {
; 2845 : 	   	unsigned int rbytes, rbits;
; 2846 : 		register unsigned int i;
; 2847 : 		cell *tp;
; 2848 : 		cell offset = (cell)origin - header.entry;
; 2849 : 
; 2850 : 		rbits = header.dsize/sizeof(cell);

  08506	8b 7c 24 1c	 mov	 edi, DWORD PTR _header$[esp+112]
  0850a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _origin
  08510	8b 74 24 28	 mov	 esi, DWORD PTR _header$[esp+124]

; 2851 : 		rbytes = (rbits + 7) >> 3;
; 2852 : 		if (fread((char *)relmap, 1, (int)rbytes, fd) != (u_cell)rbytes) {

  08514	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _relmap
  0851a	c1 ef 02	 shr	 edi, 2
  0851d	2b ee		 sub	 ebp, esi
  0851f	53		 push	 ebx
  08520	8d 77 07	 lea	 esi, DWORD PTR [edi+7]
  08523	c1 ee 03	 shr	 esi, 3
  08526	56		 push	 esi
  08527	6a 01		 push	 1
  08529	52		 push	 edx
  0852a	e8 00 00 00 00	 call	 _fread
  0852f	83 c4 10	 add	 esp, 16			; 00000010H
  08532	3b c6		 cmp	 eax, esi
  08534	74 0f		 je	 SHORT $L59893

; 2853 : 		    fatal("Can't read dictionary relocation map\n", MEMEDICTALLOCSTATUS);

  08536	6a 0b		 push	 11			; 0000000bH
  08538	68 00 00 00 00	 push	 OFFSET FLAT:$SG59894
  0853d	e8 00 00 00 00	 call	 _fatal
  08542	83 c4 08	 add	 esp, 8
$L59893:

; 2854 : 		}
; 2855 : 		if (offset != 0) {

  08545	85 ed		 test	 ebp, ebp
  08547	74 2f		 je	 SHORT $L59898

; 2856 : 			for (i = 0; i < rbits; i++) {

  08549	33 c0		 xor	 eax, eax
  0854b	85 ff		 test	 edi, edi
  0854d	76 29		 jbe	 SHORT $L59898
$L59896:

; 2857 : 				if (relmap[i>>3] & bit[i&7]) {

  0854f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _relmap
  08555	8b c8		 mov	 ecx, eax
  08557	c1 e9 03	 shr	 ecx, 3
  0855a	8b d0		 mov	 edx, eax
  0855c	8a 0c 31	 mov	 cl, BYTE PTR [ecx+esi]
  0855f	83 e2 07	 and	 edx, 7
  08562	84 8a 00 00 00
	00		 test	 cl, BYTE PTR _bit[edx]
  08568	74 09		 je	 SHORT $L59897
  0856a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _origin

; 2858 : 					tp = &origin[i];
; 2859 : 					*tp += offset;

  08570	01 2c 81	 add	 DWORD PTR [ecx+eax*4], ebp
$L59897:
  08573	40		 inc	 eax
  08574	3b c7		 cmp	 eax, edi
  08576	72 d7		 jb	 SHORT $L59896
$L59898:

; 2860 : 				}
; 2861 : 			}
; 2862 : 		}
; 2863 : 		rbits = header.usize/sizeof(cell);

  08578	8b 7c 24 24	 mov	 edi, DWORD PTR _header$[esp+120]

; 2864 : 		rbytes = (rbits + 7) >> 3;
; 2865 : 		if (fread((char *)urelmap, 1, (int)rbytes, fd) != (u_cell)rbytes) {

  0857c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _urelmap
  08582	c1 ef 02	 shr	 edi, 2
  08585	53		 push	 ebx
  08586	8d 77 07	 lea	 esi, DWORD PTR [edi+7]
  08589	c1 ee 03	 shr	 esi, 3
  0858c	56		 push	 esi
  0858d	6a 01		 push	 1
  0858f	52		 push	 edx
  08590	e8 00 00 00 00	 call	 _fread
  08595	83 c4 10	 add	 esp, 16			; 00000010H
  08598	3b c6		 cmp	 eax, esi
  0859a	74 0f		 je	 SHORT $L59904

; 2866 : 		    fatal("Can't read data relocation map\n", MEMEDICTALLOCSTATUS);

  0859c	6a 0b		 push	 11			; 0000000bH
  0859e	68 00 00 00 00	 push	 OFFSET FLAT:$SG59905
  085a3	e8 00 00 00 00	 call	 _fatal
  085a8	83 c4 08	 add	 esp, 8
$L59904:

; 2867 : 		}
; 2868 : 		if (offset != 0) {

  085ab	85 ed		 test	 ebp, ebp
  085ad	74 46		 je	 SHORT $L59909

; 2869 : 			for (i = 0; i < rbits; i++) {

  085af	33 c0		 xor	 eax, eax
  085b1	85 ff		 test	 edi, edi
  085b3	76 40		 jbe	 SHORT $L59909
  085b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
$L59907:

; 2870 : 				if ((urelmap[i>>3] & bit[i&7]) && ((token_t)xup[i] >= MAXPRIM)) {

  085bb	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _urelmap
  085c1	8b d0		 mov	 edx, eax
  085c3	8b f0		 mov	 esi, eax
  085c5	c1 ea 03	 shr	 edx, 3
  085c8	83 e6 07	 and	 esi, 7
  085cb	8a 14 1a	 mov	 dl, BYTE PTR [edx+ebx]
  085ce	84 96 00 00 00
	00		 test	 dl, BYTE PTR _bit[esi]
  085d4	74 16		 je	 SHORT $L59908
  085d6	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  085d9	81 fa 90 01 00
	00		 cmp	 edx, 400		; 00000190H
  085df	72 0b		 jb	 SHORT $L59908

; 2871 : 					tp = &xup[i];
; 2872 : 					*tp += offset;

  085e1	03 d5		 add	 edx, ebp
  085e3	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  085e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
$L59908:
  085ec	40		 inc	 eax
  085ed	3b c7		 cmp	 eax, edi
  085ef	72 ca		 jb	 SHORT $L59907

; 2869 : 			for (i = 0; i < rbits; i++) {

  085f1	8b 5c 24 68	 mov	 ebx, DWORD PTR _fd$[esp+96]
$L59909:

; 2873 : 				}
; 2874 : 			}
; 2875 : # ifdef notdef
; 2876 : 		    /* Save the relocated dictionary to a file for debugging */
; 2877 : 		    (void)fclose(fd);
; 2878 : 
; 2879 : 		    if ((fd = fopen("meme.dx", WRITE_MODE)) < (FILE *) 0)
; 2880 : 			fatal("Can't open debugging dictionary image for writing\n", MEMEDICTALLOCSTATUS);
; 2881 : 
; 2882 : 		    fprintf(fd, "offset = 0x%-4.4x\n", offset);
; 2883 : 		    if (fwrite(origin, 1, (unsigned int)header.dsize, fd)
; 2884 : 		    != (unsigned int)header.dsize)
; 2885 : 			fatal("Can't write dictionary image\n", MEMEDICTALLOCSTATUS);
; 2886 : 
; 2887 : 		    if (fwrite((char *)up, 1, (unsigned int)header.usize, fd)
; 2888 : 		    != (unsigned int)header.usize)
; 2889 : 			fatal("Can't write user area image\n", MEMEDICTALLOCSTATUS);
; 2890 : # endif
; 2891 : 		}
; 2892 : 	}
; 2893 : #endif	/* RELOCATE */
; 2894 :     (void)fclose(fd);

  085f5	53		 push	 ebx
  085f6	e8 00 00 00 00	 call	 _fclose
  085fb	83 c4 04	 add	 esp, 4
  085fe	5f		 pop	 edi
  085ff	5e		 pop	 esi
  08600	5d		 pop	 ebp
  08601	5b		 pop	 ebx

; 2895 : }

  08602	83 c4 54	 add	 esp, 84			; 00000054H
  08605	c3		 ret	 0
_read_dictionary ENDP
_TEXT	ENDS
PUBLIC	_udot
_TEXT	SEGMENT
_u$ = 8
_udot	PROC NEAR

; 2906 :     register u_char *p = &num_buf[40];
; 2907 :     register unsigned cell a = u;

  08610	8b 4c 24 04	 mov	 ecx, DWORD PTR _u$[esp-4]
  08614	53		 push	 ebx

; 2908 : 
; 2909 :     *--p = ' ';		/* gratuitous space at the end */
; 2910 : 
; 2911 :     do {
; 2912 : 	*--p = (u_char)digits[ a % XV_BASE ];

  08615	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xup
  0861b	56		 push	 esi
  0861c	57		 push	 edi
  0861d	c6 05 27 00 00
	00 20		 mov	 BYTE PTR _num_buf+39, 32 ; 00000020H
  08624	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  08627	bf 27 00 00 00	 mov	 edi, OFFSET FLAT:_num_buf+39
$L59920:
  0862c	8b c1		 mov	 eax, ecx
  0862e	33 d2		 xor	 edx, edx
  08630	f7 f6		 div	 esi
  08632	4f		 dec	 edi
  08633	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _digits[edx]

; 2913 :     } while ((a /= XV_BASE) != 0);

  08639	33 d2		 xor	 edx, edx
  0863b	88 07		 mov	 BYTE PTR [edi], al
  0863d	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  08640	8b c1		 mov	 eax, ecx
  08642	f7 f6		 div	 esi
  08644	8b c8		 mov	 ecx, eax
  08646	85 c9		 test	 ecx, ecx
  08648	75 e2		 jne	 SHORT $L59920

; 2914 : 
; 2915 :     type(p, (cell)(&num_buf[40] - p));

  0864a	b8 28 00 00 00	 mov	 eax, OFFSET FLAT:_num_buf+40
  0864f	2b c7		 sub	 eax, edi
  08651	8b c8		 mov	 ecx, eax
  08653	48		 dec	 eax
  08654	85 c9		 test	 ecx, ecx
  08656	74 12		 je	 SHORT $L62045
  08658	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L62044:
  0865b	8a 07		 mov	 al, BYTE PTR [edi]
  0865d	47		 inc	 edi
  0865e	50		 push	 eax
  0865f	e8 00 00 00 00	 call	 _emit
  08664	83 c4 04	 add	 esp, 4
  08667	4e		 dec	 esi
  08668	75 f1		 jne	 SHORT $L62044
$L62045:
  0866a	5f		 pop	 edi
  0866b	5e		 pop	 esi
  0866c	5b		 pop	 ebx

; 2916 : }

  0866d	c3		 ret	 0
_udot	ENDP
_TEXT	ENDS
PUBLIC	_dot
_TEXT	SEGMENT
_n$ = 8
_dot	PROC NEAR

; 2921 : {

  08670	56		 push	 esi

; 2922 :     if ( n < 0 ) {

  08671	8b 74 24 08	 mov	 esi, DWORD PTR _n$[esp]
  08675	85 f6		 test	 esi, esi
  08677	57		 push	 edi
  08678	7d 0c		 jge	 SHORT $L59928

; 2923 : 	emit('-');

  0867a	6a 2d		 push	 45			; 0000002dH
  0867c	e8 00 00 00 00	 call	 _emit
  08681	83 c4 04	 add	 esp, 4

; 2924 : 	n = -n;

  08684	f7 de		 neg	 esi
$L59928:
  08686	53		 push	 ebx

; 2925 :     }
; 2926 :     udot((unsigned cell)n);

  08687	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xup
  0868d	8b ce		 mov	 ecx, esi
  0868f	c6 05 27 00 00
	00 20		 mov	 BYTE PTR _num_buf+39, 32 ; 00000020H
  08696	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  08699	bf 27 00 00 00	 mov	 edi, OFFSET FLAT:_num_buf+39
$L62064:
  0869e	8b c1		 mov	 eax, ecx
  086a0	33 d2		 xor	 edx, edx
  086a2	f7 f6		 div	 esi
  086a4	4f		 dec	 edi
  086a5	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _digits[edx]
  086ab	33 d2		 xor	 edx, edx
  086ad	88 07		 mov	 BYTE PTR [edi], al
  086af	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  086b2	8b c1		 mov	 eax, ecx
  086b4	f7 f6		 div	 esi
  086b6	8b c8		 mov	 ecx, eax
  086b8	85 c9		 test	 ecx, ecx
  086ba	75 e2		 jne	 SHORT $L62064
  086bc	b8 28 00 00 00	 mov	 eax, OFFSET FLAT:_num_buf+40
  086c1	5b		 pop	 ebx
  086c2	2b c7		 sub	 eax, edi
  086c4	8b c8		 mov	 ecx, eax
  086c6	48		 dec	 eax
  086c7	85 c9		 test	 ecx, ecx
  086c9	74 12		 je	 SHORT $L62070
  086cb	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L62069:
  086ce	8a 07		 mov	 al, BYTE PTR [edi]
  086d0	47		 inc	 edi
  086d1	50		 push	 eax
  086d2	e8 00 00 00 00	 call	 _emit
  086d7	83 c4 04	 add	 esp, 4
  086da	4e		 dec	 esi
  086db	75 f1		 jne	 SHORT $L62069
$L62070:
  086dd	5f		 pop	 edi
  086de	5e		 pop	 esi

; 2927 : }

  086df	c3		 ret	 0
_dot	ENDP
_TEXT	ENDS
PUBLIC	_type
_TEXT	SEGMENT
_adr$ = 8
_len$ = 12
_type	PROC NEAR

; 2934 :     while (len--)

  086e0	8b 44 24 08	 mov	 eax, DWORD PTR _len$[esp-4]
  086e4	8b c8		 mov	 ecx, eax
  086e6	48		 dec	 eax
  086e7	85 c9		 test	 ecx, ecx
  086e9	74 1a		 je	 SHORT $L59936
  086eb	56		 push	 esi
  086ec	8b 74 24 08	 mov	 esi, DWORD PTR _adr$[esp]
  086f0	57		 push	 edi
  086f1	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$L59935:

; 2935 : 	emit(*adr++);

  086f4	8a 06		 mov	 al, BYTE PTR [esi]
  086f6	46		 inc	 esi
  086f7	50		 push	 eax
  086f8	e8 00 00 00 00	 call	 _emit
  086fd	83 c4 04	 add	 esp, 4
  08700	4f		 dec	 edi
  08701	75 f1		 jne	 SHORT $L59935
  08703	5f		 pop	 edi
  08704	5e		 pop	 esi
$L59936:

; 2936 : }

  08705	c3		 ret	 0
_type	ENDP
_TEXT	ENDS
PUBLIC	_aligned
_TEXT	SEGMENT
_addr$ = 8
_aligned PROC NEAR

; 2964 :     /* This calculation assumes twos-complement representation */
; 2965 :     return( (token_t *)
; 2966 :       ( ((cell)addr + ALIGN_BOUNDARY - 1) & (-((cell)ALIGN_BOUNDARY)) )
; 2967 :     );

  08710	8b 44 24 04	 mov	 eax, DWORD PTR _addr$[esp-4]
  08714	83 c0 03	 add	 eax, 3
  08717	24 fc		 and	 al, -4			; fffffffcH

; 2968 : }

  08719	c3		 ret	 0
_aligned ENDP
_TEXT	ENDS
PUBLIC	_name_from
_TEXT	SEGMENT
_nfa$ = 8
_name_from PROC NEAR

; 2975 :     return ( aligned( &nfa[(*nfa)+1] ) );

  08720	8b 44 24 04	 mov	 eax, DWORD PTR _nfa$[esp-4]
  08724	33 c9		 xor	 ecx, ecx
  08726	8a 08		 mov	 cl, BYTE PTR [eax]
  08728	8d 44 01 04	 lea	 eax, DWORD PTR [ecx+eax+4]
  0872c	24 fc		 and	 al, -4			; fffffffcH

; 2976 : }

  0872e	c3		 ret	 0
_name_from ENDP
_TEXT	ENDS
PUBLIC	_makeimmediate
_TEXT	SEGMENT
_makeimmediate PROC NEAR

; 2981 :     XV_LAST->flags |= IMMEDBIT;

  08730	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08735	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  08738	80 48 04 01	 or	 BYTE PTR [eax+4], 1

; 2982 : }

  0873c	c3		 ret	 0
_makeimmediate ENDP
_TEXT	ENDS
PUBLIC	_vfind
_TEXT	SEGMENT
_sp$ = 8
_voc$ = 12
_vfind	PROC NEAR

; 3008 : {

  08740	51		 push	 ecx

; 3009 :     /* The first character in the string is the Forth count field. */
; 3010 :     register u_char *s,*p;
; 3011 :     register int length;
; 3012 :     register u_char *str = *sp;
; 3013 :     register dict_entry_t *dictp;
; 3014 :     token_t * cfa;
; 3015 : 
; 3016 :     /* Relocatable modules cannot compile origin into the bottom-most
; 3017 :      * word's link field, as other machines will not have the same
; 3018 :      * origin.  Origin in this implementation always contains a zero,
; 3019 :      * so we dereference the dictp pointer and look for zero rather
; 3020 :      * than checking the pointer for equality with the origin.
; 3021 :      */
; 3022 :     dictp = *hash(voc, str); 

  08741	8b 4c 24 0c	 mov	 ecx, DWORD PTR _voc$[esp]
  08745	8b 44 24 08	 mov	 eax, DWORD PTR _sp$[esp]
  08749	53		 push	 ebx
  0874a	55		 push	 ebp
  0874b	8b 00		 mov	 eax, DWORD PTR [eax]
  0874d	56		 push	 esi
  0874e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  08751	57		 push	 edi

; 3023 :     while ( *(cell *)dictp != 0 ) {

  08752	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08754	85 c9		 test	 ecx, ecx
  08756	74 3d		 je	 SHORT $L59963

; 3024 : 	s = &dictp->name;
; 3025 : 	p = str;
; 3026 : 	length = *s++;
; 3027 : 	if ( *p++ != length )

  08758	33 d2		 xor	 edx, edx
  0875a	8a 10		 mov	 dl, BYTE PTR [eax]
  0875c	40		 inc	 eax
  0875d	89 54 24 10	 mov	 DWORD PTR -4+[esp+20], edx
  08761	89 44 24 1c	 mov	 DWORD PTR 12+[esp+16], eax
$L59962:
  08765	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  08768	33 d2		 xor	 edx, edx
  0876a	8b 6c 24 1c	 mov	 ebp, DWORD PTR 12+[esp+16]
  0876e	8a 10		 mov	 dl, BYTE PTR [eax]
  08770	40		 inc	 eax
  08771	8b fa		 mov	 edi, edx
  08773	8b 54 24 10	 mov	 edx, DWORD PTR -4+[esp+20]
  08777	3b d7		 cmp	 edx, edi
  08779	75 12		 jne	 SHORT $nextword$59965
$L59967:

; 3028 : 	    goto nextword;
; 3029 : 	while ( length-- )

  0877b	8b d7		 mov	 edx, edi
  0877d	4f		 dec	 edi
  0877e	85 d2		 test	 edx, edx
  08780	74 1b		 je	 SHORT $L59968

; 3030 : 	    if ( *s++ != *p++ )
; 3031 : 		goto nextword;
; 3032 : 
; 3033 : 	cfa = name_from( &dictp->name );

  08782	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  08785	8a 10		 mov	 dl, BYTE PTR [eax]
  08787	45		 inc	 ebp
  08788	40		 inc	 eax
  08789	3a d3		 cmp	 dl, bl
  0878b	74 ee		 je	 SHORT $L59967
$nextword$59965:

; 3037 : nextword:
; 3038 : 	dictp = dictp->link;

  0878d	8b f1		 mov	 esi, ecx
  0878f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08791	85 c9		 test	 ecx, ecx
  08793	75 d0		 jne	 SHORT $L59962
$L59963:
  08795	5f		 pop	 edi
  08796	5e		 pop	 esi
  08797	5d		 pop	 ebp

; 3039 :     }
; 3040 :     return (0);	       /* Not found */

  08798	33 c0		 xor	 eax, eax
  0879a	5b		 pop	 ebx

; 3041 : }

  0879b	59		 pop	 ecx
  0879c	c3		 ret	 0
$L59968:

; 3034 : 	*(token_t *)sp = (token_t) cfa;

  0879d	8b 54 24 18	 mov	 edx, DWORD PTR _sp$[esp+16]
  087a1	33 c0		 xor	 eax, eax
  087a3	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  087a6	5f		 pop	 edi
  087a7	8d 4c 30 09	 lea	 ecx, DWORD PTR [eax+esi+9]
  087ab	83 e1 fc	 and	 ecx, -4			; fffffffcH
  087ae	89 0a		 mov	 DWORD PTR [edx], ecx

; 3035 : 
; 3036 : 	return ( isimmediate(dictp) ? 1 : -1 );

  087b0	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  087b3	24 01		 and	 al, 1
  087b5	5e		 pop	 esi
  087b6	f6 d8		 neg	 al
  087b8	1b c0		 sbb	 eax, eax
  087ba	5d		 pop	 ebp
  087bb	83 e0 02	 and	 eax, 2
  087be	5b		 pop	 ebx
  087bf	48		 dec	 eax

; 3041 : }

  087c0	59		 pop	 ecx
  087c1	c3		 ret	 0
_vfind	ENDP
_TEXT	ENDS
PUBLIC	_find_local
_TEXT	SEGMENT
_sp$ = 8
_find_local PROC NEAR

; 3054 :     /* The first character in the string is the Forth count field. */
; 3055 :     register u_char *s,*p;
; 3056 :     register int length;
; 3057 :     register u_char *str = *sp;

  087d0	8b 44 24 04	 mov	 eax, DWORD PTR _sp$[esp-4]
  087d4	53		 push	 ebx
  087d5	55		 push	 ebp
  087d6	56		 push	 esi
  087d7	8b 08		 mov	 ecx, DWORD PTR [eax]

; 3058 : 
; 3059 :     for ( locnum = 0; locnum < nlocnames; ) {

  087d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  087de	33 f6		 xor	 esi, esi
  087e0	57		 push	 edi
  087e1	85 c0		 test	 eax, eax
  087e3	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  087e9	7e 46		 jle	 SHORT $L59982
$L59981:

; 3060 : 		s = locnames[locnum].name;

  087eb	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]

; 3061 : 		p = str;
; 3062 : 		length = *s++;
; 3063 : 		if ( *p++ != length)

  087ee	8d 69 01	 lea	 ebp, DWORD PTR [ecx+1]
  087f1	8d 04 56	 lea	 eax, DWORD PTR [esi+edx*2]
  087f4	33 d2		 xor	 edx, edx
  087f6	8a 14 85 00 00
	00 00		 mov	 dl, BYTE PTR _locnames[eax*4]
  087fd	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _locnames[eax*4]
  08804	8b fa		 mov	 edi, edx
  08806	33 d2		 xor	 edx, edx
  08808	40		 inc	 eax
  08809	8a 11		 mov	 dl, BYTE PTR [ecx]
  0880b	3b d7		 cmp	 edx, edi
  0880d	75 12		 jne	 SHORT $nextword$59984
$L59986:

; 3064 : 			goto nextword;
; 3065 : 
; 3066 : 		while ( length-- )

  0880f	8b d7		 mov	 edx, edi
  08811	4f		 dec	 edi
  08812	85 d2		 test	 edx, edx
  08814	74 22		 je	 SHORT $L59987

; 3067 : 			if ( *s++ != *p++ )
; 3068 : 				goto nextword;
; 3069 : 
; 3070 :         *(token_t *)sp = (token_t)lnamebuf;

  08816	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  08819	8a 10		 mov	 dl, BYTE PTR [eax]
  0881b	45		 inc	 ebp
  0881c	40		 inc	 eax
  0881d	3a d3		 cmp	 dl, bl
  0881f	74 ee		 je	 SHORT $L59986
$nextword$59984:

; 3058 : 
; 3059 :     for ( locnum = 0; locnum < nlocnames; ) {

  08821	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames

; 3072 : nextword:
; 3073 : 		locnum++;

  08826	46		 inc	 esi
  08827	3b f0		 cmp	 esi, eax
  08829	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  0882f	7c ba		 jl	 SHORT $L59981
$L59982:
  08831	5f		 pop	 edi
  08832	5e		 pop	 esi
  08833	5d		 pop	 ebp

; 3074 :     }
; 3075 :     return (0);

  08834	33 c0		 xor	 eax, eax
  08836	5b		 pop	 ebx

; 3076 : }

  08837	c3		 ret	 0
$L59987:

; 3067 : 			if ( *s++ != *p++ )
; 3068 : 				goto nextword;
; 3069 : 
; 3070 :         *(token_t *)sp = (token_t)lnamebuf;

  08838	8b 44 24 14	 mov	 eax, DWORD PTR _sp$[esp+12]
  0883c	5f		 pop	 edi
  0883d	5e		 pop	 esi
  0883e	5d		 pop	 ebp
  0883f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_lnamebuf

; 3071 : 		return (1);			/* Immediate */

  08845	b8 01 00 00 00	 mov	 eax, 1
  0884a	5b		 pop	 ebx

; 3076 : }

  0884b	c3		 ret	 0
_find_local ENDP
_TEXT	ENDS
PUBLIC	_find
_TEXT	SEGMENT
_sp$ = 8
_voc$ = -16
_find	PROC NEAR

; 3082 : 	int i, found = 0;
; 3083 : 	vocabulary_t *voc, *last_voc;
; 3084 : 
; 3085 : 	/* If the symbol is found in the local variable names, return */
; 3086 : 	if ((found = find_local((u_char **)sp)) != 0) {

  08850	8b 44 24 04	 mov	 eax, DWORD PTR _sp$[esp-4]
  08854	83 ec 10	 sub	 esp, 16			; 00000010H
  08857	8b 08		 mov	 ecx, DWORD PTR [eax]
  08859	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  0885e	53		 push	 ebx
  0885f	55		 push	 ebp
  08860	56		 push	 esi
  08861	33 f6		 xor	 esi, esi
  08863	85 c0		 test	 eax, eax
  08865	57		 push	 edi
  08866	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  0886c	7e 46		 jle	 SHORT $L62114
$L62113:
  0886e	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  08871	8d 69 01	 lea	 ebp, DWORD PTR [ecx+1]
  08874	8d 04 56	 lea	 eax, DWORD PTR [esi+edx*2]
  08877	33 d2		 xor	 edx, edx
  08879	8a 14 85 00 00
	00 00		 mov	 dl, BYTE PTR _locnames[eax*4]
  08880	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _locnames[eax*4]
  08887	8b fa		 mov	 edi, edx
  08889	33 d2		 xor	 edx, edx
  0888b	40		 inc	 eax
  0888c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0888e	3b d7		 cmp	 edx, edi
  08890	75 12		 jne	 SHORT $nextword$62116
$L62117:
  08892	8b d7		 mov	 edx, edi
  08894	4f		 dec	 edi
  08895	85 d2		 test	 edx, edx
  08897	74 1f		 je	 SHORT $L62118
  08899	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  0889c	8a 10		 mov	 dl, BYTE PTR [eax]
  0889e	45		 inc	 ebp
  0889f	40		 inc	 eax
  088a0	3a d3		 cmp	 dl, bl
  088a2	74 ee		 je	 SHORT $L62117
$nextword$62116:
  088a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  088a9	46		 inc	 esi
  088aa	3b f0		 cmp	 esi, eax
  088ac	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  088b2	7c ba		 jl	 SHORT $L62113
$L62114:
  088b4	33 c0		 xor	 eax, eax
  088b6	eb 17		 jmp	 SHORT $L59999
$L62118:
  088b8	8b 44 24 24	 mov	 eax, DWORD PTR _sp$[esp+28]
  088bc	5f		 pop	 edi
  088bd	5e		 pop	 esi
  088be	5d		 pop	 ebp
  088bf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_lnamebuf

; 3087 : 		return (found);

  088c5	b8 01 00 00 00	 mov	 eax, 1
  088ca	5b		 pop	 ebx

; 3101 :     }
; 3102 :     return (found);
; 3103 : }

  088cb	83 c4 10	 add	 esp, 16			; 00000010H
  088ce	c3		 ret	 0
$L59999:

; 3088 : 	}
; 3089 : 
; 3090 : 	/* Search the vocabularies mentioned in the search order */
; 3091 :     last_voc = (vocabulary_t *)0;

  088cf	be b0 00 00 00	 mov	 esi, 176		; 000000b0H
  088d4	33 c9		 xor	 ecx, ecx
  088d6	89 74 24 14	 mov	 DWORD PTR -12+[esp+32], esi
$L60001:

; 3092 :     for (i = 0; i < NVOCS; i++) {
; 3093 : 		voc = ((vocabulary_t **)&XV_CONTEXT)[i];

  088da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  088e0	8b 14 16	 mov	 edx, DWORD PTR [esi+edx]

; 3094 : 		if ( voc == 0 || voc == (vocabulary_t *)origin) {

  088e3	85 d2		 test	 edx, edx
  088e5	89 54 24 10	 mov	 DWORD PTR _voc$[esp+32], edx
  088e9	0f 84 91 00 00
	00		 je	 $L60002
  088ef	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _origin
  088f5	0f 84 85 00 00
	00		 je	 $L60002

; 3095 : 			continue;
; 3096 : 		}
; 3097 : 		if ((voc != last_voc) && ((found = vfind((u_char **)sp, voc)) != 0)) {

  088fb	3b d1		 cmp	 edx, ecx
  088fd	74 7b		 je	 SHORT $L60009
  088ff	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  08902	8b 44 24 24	 mov	 eax, DWORD PTR _sp$[esp+28]
  08906	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08908	8b 00		 mov	 eax, DWORD PTR [eax]
  0890a	85 c9		 test	 ecx, ecx
  0890c	74 41		 je	 SHORT $L62139
  0890e	33 d2		 xor	 edx, edx
  08910	8a 10		 mov	 dl, BYTE PTR [eax]
  08912	40		 inc	 eax
  08913	89 54 24 1c	 mov	 DWORD PTR -4+[esp+32], edx
  08917	89 44 24 18	 mov	 DWORD PTR -8+[esp+32], eax
$L62138:
  0891b	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  0891e	33 d2		 xor	 edx, edx
  08920	8b 6c 24 18	 mov	 ebp, DWORD PTR -8+[esp+32]
  08924	8a 10		 mov	 dl, BYTE PTR [eax]
  08926	40		 inc	 eax
  08927	8b fa		 mov	 edi, edx
  08929	8b 54 24 1c	 mov	 edx, DWORD PTR -4+[esp+32]
  0892d	3b d7		 cmp	 edx, edi
  0892f	75 12		 jne	 SHORT $nextword$62141
$L62142:
  08931	8b d7		 mov	 edx, edi
  08933	4f		 dec	 edi
  08934	85 d2		 test	 edx, edx
  08936	74 1b		 je	 SHORT $L62143
  08938	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  0893b	8a 10		 mov	 dl, BYTE PTR [eax]
  0893d	45		 inc	 ebp
  0893e	40		 inc	 eax
  0893f	3a d3		 cmp	 dl, bl
  08941	74 ee		 je	 SHORT $L62142
$nextword$62141:
  08943	8b f1		 mov	 esi, ecx
  08945	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08947	85 c9		 test	 ecx, ecx
  08949	75 d0		 jne	 SHORT $L62138
  0894b	8b 54 24 10	 mov	 edx, DWORD PTR _voc$[esp+32]
$L62139:
  0894f	33 c0		 xor	 eax, eax
  08951	eb 27		 jmp	 SHORT $L60009
$L62143:
  08953	8b 54 24 24	 mov	 edx, DWORD PTR _sp$[esp+28]
  08957	33 c0		 xor	 eax, eax
  08959	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  0895c	8d 4c 30 09	 lea	 ecx, DWORD PTR [eax+esi+9]
  08960	83 e1 fc	 and	 ecx, -4			; fffffffcH
  08963	89 0a		 mov	 DWORD PTR [edx], ecx
  08965	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  08968	24 01		 and	 al, 1
  0896a	f6 d8		 neg	 al
  0896c	1b c0		 sbb	 eax, eax
  0896e	83 e0 02	 and	 eax, 2
  08971	48		 dec	 eax
  08972	85 c0		 test	 eax, eax
  08974	75 1d		 jne	 SHORT $L59993
  08976	8b 54 24 10	 mov	 edx, DWORD PTR _voc$[esp+32]
$L60009:

; 3098 : 			break;
; 3099 : 		}
; 3100 : 		last_voc = voc;

  0897a	8b 74 24 14	 mov	 esi, DWORD PTR -12+[esp+32]
  0897e	8b ca		 mov	 ecx, edx
$L60002:
  08980	83 c6 04	 add	 esi, 4
  08983	81 fe f0 00 00
	00		 cmp	 esi, 240		; 000000f0H
  08989	89 74 24 14	 mov	 DWORD PTR -12+[esp+32], esi
  0898d	0f 8c 47 ff ff
	ff		 jl	 $L60001
$L59993:
  08993	5f		 pop	 edi
  08994	5e		 pop	 esi
  08995	5d		 pop	 ebp
  08996	5b		 pop	 ebx

; 3101 :     }
; 3102 :     return (found);
; 3103 : }

  08997	83 c4 10	 add	 esp, 16			; 00000010H
  0899a	c3		 ret	 0
_find	ENDP
_TEXT	ENDS
PUBLIC	_align
_TEXT	SEGMENT
_align	PROC NEAR

; 3107 : {

  089a0	56		 push	 esi

; 3108 :     register length = (int)((char *)aligned((u_char *)XDP) - (char *)XDP);

  089a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xup
  089a7	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]

; 3109 :     register u_char *rdp = (u_char *)XDP;

  089aa	8b d1		 mov	 edx, ecx
  089ac	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  089af	24 fc		 and	 al, -4			; fffffffcH
  089b1	2b c1		 sub	 eax, ecx

; 3110 :     while ( length-- )

  089b3	8b c8		 mov	 ecx, eax
  089b5	48		 dec	 eax
  089b6	85 c9		 test	 ecx, ecx
  089b8	74 27		 je	 SHORT $L62171
  089ba	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  089bd	53		 push	 ebx
  089be	8b ce		 mov	 ecx, esi
  089c0	57		 push	 edi
  089c1	8b d9		 mov	 ebx, ecx
  089c3	33 c0		 xor	 eax, eax
  089c5	8b fa		 mov	 edi, edx
  089c7	c1 e9 02	 shr	 ecx, 2
  089ca	f3 ab		 rep stosd
  089cc	8b cb		 mov	 ecx, ebx
  089ce	83 e1 03	 and	 ecx, 3
  089d1	03 d6		 add	 edx, esi
  089d3	f3 aa		 rep stosb

; 3111 : 	 *rdp++ = '\0';
; 3112 :     XV_DP = (cell) ((cell *)rdp);		/* Pointer alignment */

  089d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  089da	5f		 pop	 edi
  089db	5b		 pop	 ebx
  089dc	5e		 pop	 esi
  089dd	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 3113 : }

  089e0	c3		 ret	 0
$L62171:

; 3111 : 	 *rdp++ = '\0';
; 3112 :     XV_DP = (cell) ((cell *)rdp);		/* Pointer alignment */

  089e1	89 56 70	 mov	 DWORD PTR [esi+112], edx
  089e4	5e		 pop	 esi

; 3113 : }

  089e5	c3		 ret	 0
_align	ENDP
_TEXT	ENDS
PUBLIC	_comma_string
_TEXT	SEGMENT
_str$ = 8
_comma_string PROC NEAR

; 3121 :     register u_char *rdp = (u_char *)XDP;

  089f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  089f5	56		 push	 esi
  089f6	8b 74 24 08	 mov	 esi, DWORD PTR _str$[esp]
  089fa	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]

; 3122 :     register length = (*s) + 1;

  089fd	33 c0		 xor	 eax, eax
  089ff	8a 06		 mov	 al, BYTE PTR [esi]
  08a01	8b d6		 mov	 edx, esi
  08a03	40		 inc	 eax

; 3123 : 
; 3124 :     while ( length-- )

  08a04	8b f0		 mov	 esi, eax
  08a06	48		 dec	 eax
  08a07	85 f6		 test	 esi, esi
  08a09	74 0c		 je	 SHORT $L60036

; 3120 :     register u_char *s = str;

  08a0b	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L60035:

; 3125 : 	 *rdp++ = *s++;

  08a0e	8a 02		 mov	 al, BYTE PTR [edx]
  08a10	88 01		 mov	 BYTE PTR [ecx], al
  08a12	41		 inc	 ecx
  08a13	42		 inc	 edx
  08a14	4e		 dec	 esi
  08a15	75 f7		 jne	 SHORT $L60035
$L60036:

; 3126 :     XV_DP = (cell) ((cell *)rdp);		/* Pointer alignment */

  08a17	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08a1d	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 3127 :     align();

  08a20	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xup
  08a26	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  08a29	8b d1		 mov	 edx, ecx
  08a2b	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  08a2e	24 fc		 and	 al, -4			; fffffffcH
  08a30	2b c1		 sub	 eax, ecx
  08a32	8b c8		 mov	 ecx, eax
  08a34	48		 dec	 eax
  08a35	85 c9		 test	 ecx, ecx
  08a37	74 27		 je	 SHORT $L62189
  08a39	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  08a3c	53		 push	 ebx
  08a3d	8b ce		 mov	 ecx, esi
  08a3f	57		 push	 edi
  08a40	8b d9		 mov	 ebx, ecx
  08a42	33 c0		 xor	 eax, eax
  08a44	8b fa		 mov	 edi, edx
  08a46	c1 e9 02	 shr	 ecx, 2
  08a49	f3 ab		 rep stosd
  08a4b	8b cb		 mov	 ecx, ebx
  08a4d	83 e1 03	 and	 ecx, 3
  08a50	03 d6		 add	 edx, esi
  08a52	f3 aa		 rep stosb
  08a54	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08a59	5f		 pop	 edi
  08a5a	5b		 pop	 ebx
  08a5b	5e		 pop	 esi
  08a5c	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 3128 : }

  08a5f	c3		 ret	 0
$L62189:

; 3127 :     align();

  08a60	89 56 70	 mov	 DWORD PTR [esi+112], edx
  08a63	5e		 pop	 esi

; 3128 : }

  08a64	c3		 ret	 0
_comma_string ENDP
_str$ = 8
_cf$ = 12
_quote_create PROC NEAR

; 3134 : {

  08a70	83 ec 08	 sub	 esp, 8

; 3135 :     dict_entry_t ** threadp = hash ((vocabulary_t *) XV_CURRENT, str);

  08a73	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08a79	53		 push	 ebx

; 3136 :     register	u_char * rdp;
; 3137 :     u_char *tmpstr = str;
; 3138 : 
; 3139 :     if (XV_WARNING && vfind((u_char **)&tmpstr, (vocabulary_t *)XV_CURRENT)) {

  08a7a	8b 5c 24 10	 mov	 ebx, DWORD PTR _str$[esp+8]
  08a7e	55		 push	 ebp
  08a7f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  08a82	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  08a85	83 c0 04	 add	 eax, 4
  08a88	56		 push	 esi
  08a89	85 d2		 test	 edx, edx
  08a8b	57		 push	 edi
  08a8c	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
  08a90	0f 84 9f 00 00
	00		 je	 $L60049
  08a96	8b 38		 mov	 edi, DWORD PTR [eax]
  08a98	8b 0f		 mov	 ecx, DWORD PTR [edi]
  08a9a	85 c9		 test	 ecx, ecx
  08a9c	0f 84 93 00 00
	00		 je	 $L60049
  08aa2	33 c0		 xor	 eax, eax
  08aa4	8a 03		 mov	 al, BYTE PTR [ebx]
  08aa6	89 44 24 10	 mov	 DWORD PTR -8+[esp+24], eax
$L62208:
  08aaa	8d 47 05	 lea	 eax, DWORD PTR [edi+5]
  08aad	33 d2		 xor	 edx, edx
  08aaf	8d 6b 01	 lea	 ebp, DWORD PTR [ebx+1]
  08ab2	8a 10		 mov	 dl, BYTE PTR [eax]
  08ab4	40		 inc	 eax
  08ab5	8b f2		 mov	 esi, edx
  08ab7	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  08abb	3b d6		 cmp	 edx, esi
  08abd	75 16		 jne	 SHORT $nextword$62211
$L62212:
  08abf	8b d6		 mov	 edx, esi
  08ac1	4e		 dec	 esi
  08ac2	85 d2		 test	 edx, edx
  08ac4	74 19		 je	 SHORT $L62213
  08ac6	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  08ac9	8a 10		 mov	 dl, BYTE PTR [eax]
  08acb	45		 inc	 ebp
  08acc	40		 inc	 eax
  08acd	3a d3		 cmp	 dl, bl
  08acf	8b 5c 24 1c	 mov	 ebx, DWORD PTR _str$[esp+20]
  08ad3	74 ea		 je	 SHORT $L62212
$nextword$62211:
  08ad5	8b f9		 mov	 edi, ecx
  08ad7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  08ad9	85 c9		 test	 ecx, ecx
  08adb	75 cd		 jne	 SHORT $L62208
  08add	eb 56		 jmp	 SHORT $L60049
$L62213:
  08adf	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  08ae2	24 01		 and	 al, 1
  08ae4	f6 d8		 neg	 al
  08ae6	1b c0		 sbb	 eax, eax
  08ae8	83 e0 02	 and	 eax, 2
  08aeb	48		 dec	 eax
  08aec	85 c0		 test	 eax, eax
  08aee	74 45		 je	 SHORT $L60049

; 3140 : 		sprintf(errMsg, "%s isn't unique\n", tocstr(str));

  08af0	8b 4c 24 10	 mov	 ecx, DWORD PTR -8+[esp+24]
  08af4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  08af9	8b d1		 mov	 edx, ecx
  08afb	49		 dec	 ecx
  08afc	85 d2		 test	 edx, edx
  08afe	74 11		 je	 SHORT $L62228
  08b00	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  08b03	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  08b06	2b d0		 sub	 edx, eax
$L62227:
  08b08	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  08b0b	88 08		 mov	 BYTE PTR [eax], cl
  08b0d	40		 inc	 eax
  08b0e	4e		 dec	 esi
  08b0f	75 f7		 jne	 SHORT $L62227
$L62228:
  08b11	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  08b16	68 00 00 00 00	 push	 OFFSET FLAT:$SG60050
  08b1b	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  08b20	c6 00 00	 mov	 BYTE PTR [eax], 0
  08b23	e8 00 00 00 00	 call	 _sprintf

; 3141 : 		error(errMsg);

  08b28	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  08b2d	e8 00 00 00 00	 call	 _error
  08b32	83 c4 10	 add	 esp, 16			; 00000010H
$L60049:

; 3142 :     }
; 3143 : 
; 3144 :     align();

  08b35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08b3b	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  08b3e	8b d1		 mov	 edx, ecx
  08b40	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  08b43	24 fc		 and	 al, -4			; fffffffcH
  08b45	2b c1		 sub	 eax, ecx
  08b47	8b c8		 mov	 ecx, eax
  08b49	48		 dec	 eax
  08b4a	85 c9		 test	 ecx, ecx
  08b4c	74 19		 je	 SHORT $L62237
  08b4e	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  08b51	33 c0		 xor	 eax, eax
  08b53	8b ce		 mov	 ecx, esi
  08b55	8b fa		 mov	 edi, edx
  08b57	8b e9		 mov	 ebp, ecx
  08b59	c1 e9 02	 shr	 ecx, 2
  08b5c	f3 ab		 rep stosd
  08b5e	8b cd		 mov	 ecx, ebp
  08b60	83 e1 03	 and	 ecx, 3
  08b63	03 d6		 add	 edx, esi
  08b65	f3 aa		 rep stosb
$L62237:
  08b67	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08b6c	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 3145 :     rdp = (u_char *) XDP;

  08b6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup

; 3146 : 
; 3147 : #ifdef RELOCATE
; 3148 :     set_relocation_bit(XDP);

  08b75	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  08b7b	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  08b7e	85 d2		 test	 edx, edx
  08b80	8b f0		 mov	 esi, eax
  08b82	74 13		 je	 SHORT $L62256
  08b84	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  08b87	2b c1		 sub	 eax, ecx

; 3167 :     xcompile(cf);

  08b89	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  08b8c	c1 f8 02	 sar	 eax, 2
  08b8f	03 c2		 add	 eax, edx
  08b91	c6 04 08 03	 mov	 BYTE PTR [eax+ecx], 3
  08b95	eb 61		 jmp	 SHORT $L62267

; 3146 : 
; 3147 : #ifdef RELOCATE
; 3148 :     set_relocation_bit(XDP);

$L62256:
  08b97	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _origin
  08b9d	8b c8		 mov	 ecx, eax
  08b9f	2b cf		 sub	 ecx, edi
  08ba1	c1 f9 02	 sar	 ecx, 2
  08ba4	78 25		 js	 SHORT $L62266
  08ba6	3b 05 70 00 00
	00		 cmp	 eax, DWORD PTR _main_task+112
  08bac	77 1d		 ja	 SHORT $L62266
  08bae	a1 00 00 00 00	 mov	 eax, DWORD PTR _relmap
  08bb3	8b d1		 mov	 edx, ecx
  08bb5	c1 fa 03	 sar	 edx, 3
  08bb8	03 c2		 add	 eax, edx
  08bba	83 e1 07	 and	 ecx, 7
  08bbd	8a 89 00 00 00
	00		 mov	 cl, BYTE PTR _bit[ecx]
  08bc3	8a 10		 mov	 dl, BYTE PTR [eax]
  08bc5	0a d1		 or	 dl, cl
  08bc7	88 10		 mov	 BYTE PTR [eax], dl
  08bc9	eb 2d		 jmp	 SHORT $L62267
$L62266:
  08bcb	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:_main_task
  08bd0	c1 f8 02	 sar	 eax, 2
  08bd3	78 23		 js	 SHORT $L62267
  08bd5	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  08bda	73 1c		 jae	 SHORT $L62267
  08bdc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _urelmap
  08be2	8b d0		 mov	 edx, eax
  08be4	c1 fa 03	 sar	 edx, 3
  08be7	83 e0 07	 and	 eax, 7
  08bea	03 ca		 add	 ecx, edx
  08bec	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _bit[eax]
  08bf2	8a 01		 mov	 al, BYTE PTR [ecx]
  08bf4	0a c2		 or	 al, dl
  08bf6	88 01		 mov	 BYTE PTR [ecx], al
$L62267:

; 3149 : #endif
; 3150 : 
; 3151 : #ifdef REMOVE	/* Causing a protection violation if writing into a module */
; 3152 :     tokstore((token_t)rdp, &XV_LASTP);
; 3153 : #else
; 3154 : 	XV_LASTP = (cell)rdp;

  08bf8	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup

; 3155 : #endif
; 3156 : 
; 3157 :  /* Link into vocabulary search list and remember lfa for hide/reveal */
; 3158 :     xlinkcomma((*threadp));

  08bfd	8b 7c 24 14	 mov	 edi, DWORD PTR -4+[esp+24]
  08c01	89 70 30	 mov	 DWORD PTR [eax+48], esi
  08c04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08c0a	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  08c0d	50		 push	 eax
  08c0e	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  08c11	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  08c14	8b 07		 mov	 eax, DWORD PTR [edi]
  08c16	50		 push	 eax
  08c17	e8 00 00 00 00	 call	 _tokstore

; 3159 :     tokstore((token_t)rdp, (cell *)threadp);

  08c1c	57		 push	 edi
  08c1d	56		 push	 esi
  08c1e	e8 00 00 00 00	 call	 _tokstore

; 3160 :     rdp = (u_char *) XDP;

  08c23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08c29	83 c4 10	 add	 esp, 16			; 00000010H
  08c2c	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]

; 3161 : 
; 3162 :     *rdp++ = 0;			/* Place flag byte, default not immediate */

  08c2f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3163 : 
; 3164 :     XV_DP = (cell)((cell *) rdp);	/* Pointer alignment */

  08c32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08c38	40		 inc	 eax
  08c39	89 42 70	 mov	 DWORD PTR [edx+112], eax

; 3165 : 
; 3166 :     comma_string(canonical(str));	/* Place name in dictionary */

  08c3c	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08c41	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  08c44	85 c9		 test	 ecx, ecx
  08c46	74 23		 je	 SHORT $L62279
  08c48	33 c0		 xor	 eax, eax
  08c4a	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  08c4d	8a 03		 mov	 al, BYTE PTR [ebx]
  08c4f	8b d0		 mov	 edx, eax
  08c51	48		 dec	 eax
  08c52	85 d2		 test	 edx, edx
  08c54	74 15		 je	 SHORT $L62279
  08c56	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L62277:
  08c59	8a 01		 mov	 al, BYTE PTR [ecx]
  08c5b	3c 41		 cmp	 al, 65			; 00000041H
  08c5d	7c 08		 jl	 SHORT $L62278
  08c5f	3c 5a		 cmp	 al, 90			; 0000005aH
  08c61	7f 04		 jg	 SHORT $L62278
  08c63	04 20		 add	 al, 32			; 00000020H
  08c65	88 01		 mov	 BYTE PTR [ecx], al
$L62278:
  08c67	41		 inc	 ecx
  08c68	4a		 dec	 edx
  08c69	75 ee		 jne	 SHORT $L62277
$L62279:
  08c6b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08c70	8b d3		 mov	 edx, ebx
  08c72	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  08c75	33 c0		 xor	 eax, eax
  08c77	8a 03		 mov	 al, BYTE PTR [ebx]
  08c79	40		 inc	 eax
  08c7a	8b f0		 mov	 esi, eax
  08c7c	48		 dec	 eax
  08c7d	85 f6		 test	 esi, esi
  08c7f	74 0c		 je	 SHORT $L62299
  08c81	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L62298:
  08c84	8a 02		 mov	 al, BYTE PTR [edx]
  08c86	88 01		 mov	 BYTE PTR [ecx], al
  08c88	41		 inc	 ecx
  08c89	42		 inc	 edx
  08c8a	4e		 dec	 esi
  08c8b	75 f7		 jne	 SHORT $L62298
$L62299:
  08c8d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  08c93	89 4a 70	 mov	 DWORD PTR [edx+112], ecx
  08c96	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08c9b	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  08c9e	8b d1		 mov	 edx, ecx
  08ca0	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  08ca3	24 fc		 and	 al, -4			; fffffffcH
  08ca5	2b c1		 sub	 eax, ecx
  08ca7	8b c8		 mov	 ecx, eax
  08ca9	48		 dec	 eax
  08caa	85 c9		 test	 ecx, ecx
  08cac	74 19		 je	 SHORT $L62304
  08cae	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  08cb1	33 c0		 xor	 eax, eax
  08cb3	8b ce		 mov	 ecx, esi
  08cb5	8b fa		 mov	 edi, edx
  08cb7	8b d9		 mov	 ebx, ecx
  08cb9	c1 e9 02	 shr	 ecx, 2
  08cbc	f3 ab		 rep stosd
  08cbe	8b cb		 mov	 ecx, ebx
  08cc0	83 e1 03	 and	 ecx, 3
  08cc3	03 d6		 add	 edx, esi
  08cc5	f3 aa		 rep stosb
$L62304:
  08cc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08ccc	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 3167 :     xcompile(cf);

  08ccf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08cd5	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  08cd8	50		 push	 eax
  08cd9	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  08cdc	8b 44 24 24	 mov	 eax, DWORD PTR _cf$[esp+24]
  08ce0	50		 push	 eax
  08ce1	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  08ce4	e8 00 00 00 00	 call	 _tokstore
  08ce9	83 c4 08	 add	 esp, 8
  08cec	5f		 pop	 edi
  08ced	5e		 pop	 esi
  08cee	5d		 pop	 ebp
  08cef	5b		 pop	 ebx

; 3168 : #ifdef NOISY
; 3169 : 	sprintf("Meme: %s\n", tocstr(str));
; 3170 : 	error(errMsg);
; 3171 : #endif
; 3172 : }

  08cf0	83 c4 08	 add	 esp, 8
  08cf3	c3		 ret	 0
_quote_create ENDP
_TEXT	ENDS
PUBLIC	_hide
_TEXT	SEGMENT
_hide	PROC NEAR

; 3177 :     /* str is not actually used, because of the definition of hash() */
; 3178 :     /* u_char *str = &XV_LAST->name; */
; 3179 :     dict_entry_t **threadp = hash( (vocabulary_t *)XV_CURRENT , str );
; 3180 : 
; 3181 :     *threadp = XV_LAST->link;

  08d00	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08d05	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  08d08	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  08d0b	8b 01		 mov	 eax, DWORD PTR [ecx]
  08d0d	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3182 : }

  08d10	c3		 ret	 0
_hide	ENDP
_TEXT	ENDS
PUBLIC	_reveal
_TEXT	SEGMENT
_reveal	PROC NEAR

; 3187 :     /* str is not actually used, because of the definition of hash() */
; 3188 :     /* u_char *str = &XV_LAST->name; */
; 3189 :     dict_entry_t **threadp = hash( (vocabulary_t *)XV_CURRENT, str );
; 3190 : 
; 3191 :     *threadp = XV_LAST;

  08d20	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08d25	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  08d28	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  08d2b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 3192 : }

  08d2e	c3		 ret	 0
_reveal	ENDP
_TEXT	ENDS
EXTRN	__pctype:DWORD
EXTRN	__isctype:NEAR
EXTRN	___mb_cur_max:DWORD
EXTRN	_verboseMode:DWORD
_TEXT	SEGMENT
_i$ = -4
_blword	PROC NEAR

; 3204 : {

  08d30	51		 push	 ecx
  08d31	53		 push	 ebx
  08d32	55		 push	 ebp

; 3205 : 	register u_char *bufend = &((u_char *)XV_TICK_TIB)[XV_NUM_TIB];

  08d33	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _xup
  08d39	56		 push	 esi
  08d3a	57		 push	 edi

; 3206 : 	register u_char *nextc  = &((u_char *)XV_TICK_TIB)[XV_TO_IN];
; 3207 : 	register int c;
; 3208 : 	register int i = 1;

  08d3b	b9 01 00 00 00	 mov	 ecx, 1
  08d40	8b 85 8c 00 00
	00		 mov	 eax, DWORD PTR [ebp+140]
  08d46	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]
  08d49	8b 75 08	 mov	 esi, DWORD PTR [ebp+8]
  08d4c	03 f8		 add	 edi, eax
  08d4e	03 f0		 add	 esi, eax
  08d50	89 4c 24 10	 mov	 DWORD PTR _i$[esp+20], ecx

; 3209 : 
; 3210 : 	do {
; 3211 : 		if ( nextc >= bufend ) {

  08d54	3b f7		 cmp	 esi, edi
  08d56	73 39		 jae	 SHORT $L62335
$L60080:

; 3214 : 		}
; 3215 : 		c = *nextc++;
; 3216 : 	} while ( isspace(c) );

  08d58	a1 00 00 00 00	 mov	 eax, DWORD PTR ___mb_cur_max
  08d5d	33 db		 xor	 ebx, ebx
  08d5f	8a 1e		 mov	 bl, BYTE PTR [esi]
  08d61	46		 inc	 esi
  08d62	83 f8 01	 cmp	 eax, 1
  08d65	7e 17		 jle	 SHORT $L62328
  08d67	6a 08		 push	 8
  08d69	53		 push	 ebx
  08d6a	e8 00 00 00 00	 call	 __isctype
  08d6f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _xup
  08d75	8b 4c 24 18	 mov	 ecx, DWORD PTR _i$[esp+28]
  08d79	83 c4 08	 add	 esp, 8
  08d7c	eb 0b		 jmp	 SHORT $L62329
$L62328:
  08d7e	a1 00 00 00 00	 mov	 eax, DWORD PTR __pctype
  08d83	8a 04 58	 mov	 al, BYTE PTR [eax+ebx*2]
  08d86	83 e0 08	 and	 eax, 8
$L62329:
  08d89	85 c0		 test	 eax, eax
  08d8b	74 15		 je	 SHORT $L62338

; 3209 : 
; 3210 : 	do {
; 3211 : 		if ( nextc >= bufend ) {

  08d8d	3b f7		 cmp	 esi, edi
  08d8f	72 c7		 jb	 SHORT $L60080
$L62335:

; 3212 : 			XV_DELIMITER = FEOF;

  08d91	c7 45 20 ff ff
	ff ff		 mov	 DWORD PTR [ebp+32], -1

; 3213 : 			goto finish;

  08d98	eb 50		 jmp	 SHORT $finish$60084
$L60085:

; 3217 : 
; 3218 :     /* Now c contains a non-delimiter character. */
; 3219 : 
; 3220 :     do {
; 3221 : 		/*
; 3222 : 		 * If the string collected is longer than the maximum length
; 3223 : 		 * we can store, it is silently truncated.  This is generally
; 3224 : 		 * okay because such a string is probably either an error,
; 3225 : 		 * in which case the interpreter will almost certainly not find a
; 3226 : 		 * match, or a comment, in which case the string will be thrown
; 3227 : 		 * away anyway.
; 3228 : 		 */
; 3229 : 		if ( i < MAXSTRING ) wordbuf[i++] = c;

  08d9a	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  08da0	7d 0b		 jge	 SHORT $L60088
$L62338:
  08da2	88 99 00 00 00
	00		 mov	 BYTE PTR _wordbuf[ecx], bl
  08da8	41		 inc	 ecx
  08da9	89 4c 24 10	 mov	 DWORD PTR _i$[esp+20], ecx
$L60088:

; 3230 : 		if ( nextc >= bufend ) {

  08dad	3b f7		 cmp	 esi, edi
  08daf	73 e0		 jae	 SHORT $L62335

; 3231 : 			XV_DELIMITER = FEOF;
; 3232 : 			goto finish;
; 3233 : 		}
; 3234 : 		c = *nextc++;
; 3235 :     } while ( !isspace(c) );

  08db1	a1 00 00 00 00	 mov	 eax, DWORD PTR ___mb_cur_max
  08db6	33 db		 xor	 ebx, ebx
  08db8	8a 1e		 mov	 bl, BYTE PTR [esi]
  08dba	46		 inc	 esi
  08dbb	83 f8 01	 cmp	 eax, 1
  08dbe	7e 17		 jle	 SHORT $L62330
  08dc0	6a 08		 push	 8
  08dc2	53		 push	 ebx
  08dc3	e8 00 00 00 00	 call	 __isctype
  08dc8	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _xup
  08dce	8b 4c 24 18	 mov	 ecx, DWORD PTR _i$[esp+28]
  08dd2	83 c4 08	 add	 esp, 8
  08dd5	eb 0c		 jmp	 SHORT $L62331
$L62330:
  08dd7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __pctype
  08ddd	8a 04 5a	 mov	 al, BYTE PTR [edx+ebx*2]
  08de0	83 e0 08	 and	 eax, 8
$L62331:
  08de3	85 c0		 test	 eax, eax
  08de5	74 b3		 je	 SHORT $L60085

; 3236 :     XV_DELIMITER = c;

  08de7	89 5d 20	 mov	 DWORD PTR [ebp+32], ebx
$finish$60084:

; 3237 : 
; 3238 : finish:
; 3239 :     wordbuf[0] = i-1;

  08dea	8a c1		 mov	 al, cl
  08dec	5f		 pop	 edi
  08ded	fe c8		 dec	 al
  08def	a2 00 00 00 00	 mov	 BYTE PTR _wordbuf, al

; 3240 :     wordbuf[i] = '\0';
; 3241 :     XV_TO_IN = nextc - (u_char *)XV_TICK_TIB;

  08df4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08df9	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[ecx], 0
  08e00	2b b0 8c 00 00
	00		 sub	 esi, DWORD PTR [eax+140]
  08e06	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 3242 : 
; 3243 :     if (verboseMode) {

  08e09	a1 00 00 00 00	 mov	 eax, DWORD PTR _verboseMode
  08e0e	5e		 pop	 esi
  08e0f	5d		 pop	 ebp
  08e10	85 c0		 test	 eax, eax
  08e12	5b		 pop	 ebx
  08e13	74 17		 je	 SHORT $L62339

; 3244 : 		cprint(&wordbuf[1]);

  08e15	68 01 00 00 00	 push	 OFFSET FLAT:_wordbuf+1
  08e1a	e8 00 00 00 00	 call	 _cprint

; 3245 : 		cprint(" ");

  08e1f	68 00 00 00 00	 push	 OFFSET FLAT:$SG60092
  08e24	e8 00 00 00 00	 call	 _cprint
  08e29	83 c4 08	 add	 esp, 8
$L62339:

; 3246 :     }
; 3247 :     return (wordbuf);

  08e2c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wordbuf

; 3248 : }

  08e31	59		 pop	 ecx
  08e32	c3		 ret	 0
_blword	ENDP
_TEXT	ENDS
PUBLIC	_word
_TEXT	SEGMENT
_delim$ = 8
_word	PROC NEAR

; 3253 : {

  08e40	56		 push	 esi
  08e41	57		 push	 edi

; 3254 :     register u_char *bufend = &((u_char *)XV_TICK_TIB)[XV_NUM_TIB];

  08e42	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup

; 3255 :     register u_char *nextc = &((u_char *)XV_TICK_TIB)[XV_TO_IN];
; 3256 :     register int c;
; 3257 :     register int i = 1;

  08e48	ba 01 00 00 00	 mov	 edx, 1
  08e4d	8b 8f 8c 00 00
	00		 mov	 ecx, DWORD PTR [edi+140]
  08e53	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  08e56	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  08e59	03 f1		 add	 esi, ecx
  08e5b	03 c1		 add	 eax, ecx

; 3258 : 
; 3259 :     if (delim == ' ')  /* Only skip leading delimiters if delim is space */

  08e5d	8b 4c 24 0c	 mov	 ecx, DWORD PTR _delim$[esp+4]
  08e61	80 f9 20	 cmp	 cl, 32			; 00000020H
  08e64	75 08		 jne	 SHORT $L62343

; 3260 : 	 return (blword());

  08e66	e8 00 00 00 00	 call	 _blword
  08e6b	5f		 pop	 edi
  08e6c	5e		 pop	 esi

; 3287 : }

  08e6d	c3		 ret	 0
$L62343:

; 3261 : 
; 3262 :     for (;;) {
; 3263 : 	if ( nextc >= bufend ) {

  08e6e	3b c6		 cmp	 eax, esi
  08e70	53		 push	 ebx
  08e71	73 24		 jae	 SHORT $L62344

; 3266 : 	}
; 3267 : 	if ( (c = *nextc++) == delim )

  08e73	8b d9		 mov	 ebx, ecx
  08e75	81 e3 ff 00 00
	00		 and	 ebx, 255		; 000000ffH
$L60104:
  08e7b	33 c9		 xor	 ecx, ecx
  08e7d	8a 08		 mov	 cl, BYTE PTR [eax]
  08e7f	40		 inc	 eax
  08e80	3b cb		 cmp	 ecx, ebx
  08e82	74 1c		 je	 SHORT $L62345

; 3268 : 	    break;
; 3269 : 	/*
; 3270 : 	 * If the string collected is longer than the maximum length
; 3271 : 	 * we can store, it is silently truncated.  This is generally
; 3272 : 	 * okay because such a string is probably either an error,
; 3273 : 	 * in which case the interpreter will almost certainly not find a
; 3274 : 	 * match, or a comment, in which case the string will be thrown
; 3275 : 	 * away anyway.
; 3276 : 	 */
; 3277 : 	if ( i < MAXSTRING )

  08e84	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  08e8a	7d 07		 jge	 SHORT $L60109

; 3278 : 	    wordbuf[i++] = c;

  08e8c	88 8a 00 00 00
	00		 mov	 BYTE PTR _wordbuf[edx], cl
  08e92	42		 inc	 edx
$L60109:

; 3261 : 
; 3262 :     for (;;) {
; 3263 : 	if ( nextc >= bufend ) {

  08e93	3b c6		 cmp	 eax, esi
  08e95	72 e4		 jb	 SHORT $L60104
$L62344:

; 3264 : 	    XV_DELIMITER = FEOF;

  08e97	c7 47 20 ff ff
	ff ff		 mov	 DWORD PTR [edi+32], -1

; 3265 : 	    goto finish;

  08e9e	eb 03		 jmp	 SHORT $finish$60107
$L62345:

; 3279 :     }
; 3280 :     XV_DELIMITER = c;

  08ea0	89 4f 20	 mov	 DWORD PTR [edi+32], ecx
$finish$60107:

; 3281 : 
; 3282 : finish:
; 3283 :     wordbuf[0] = i-1;

  08ea3	8a ca		 mov	 cl, dl
  08ea5	5b		 pop	 ebx
  08ea6	fe c9		 dec	 cl
  08ea8	5f		 pop	 edi
  08ea9	88 0d 00 00 00
	00		 mov	 BYTE PTR _wordbuf, cl

; 3284 :     wordbuf[i] = '\0';
; 3285 :     XV_TO_IN = nextc - (u_char *)XV_TICK_TIB;

  08eaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  08eb5	c6 82 00 00 00
	00 00		 mov	 BYTE PTR _wordbuf[edx], 0
  08ebc	5e		 pop	 esi
  08ebd	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [ecx+140]
  08ec3	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3286 :     return (wordbuf);

  08ec6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_wordbuf

; 3287 : }

  08ecb	c3		 ret	 0
_word	ENDP
_TEXT	ENDS
PUBLIC	_scompile
_TEXT	SEGMENT
_str$ = 8
_tp$ = -12
_i$62392 = 8
_scompile PROC NEAR

; 3291 : {

  08ed0	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3292 :     cell tp = (cell)str;

  08ed3	8b 4c 24 10	 mov	 ecx, DWORD PTR _str$[esp+8]

; 3293 : 
; 3294 :     if( find(&tp) ) {

  08ed7	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  08edc	53		 push	 ebx
  08edd	55		 push	 ebp
  08ede	56		 push	 esi
  08edf	8b d1		 mov	 edx, ecx
  08ee1	33 f6		 xor	 esi, esi
  08ee3	57		 push	 edi
  08ee4	85 c0		 test	 eax, eax
  08ee6	89 54 24 10	 mov	 DWORD PTR _tp$[esp+28], edx
  08eea	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  08ef0	7e 4e		 jle	 SHORT $L62410
$L62409:
  08ef2	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  08ef5	33 db		 xor	 ebx, ebx
  08ef7	8d 69 01	 lea	 ebp, DWORD PTR [ecx+1]
  08efa	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  08efd	8a 1c 85 00 00
	00 00		 mov	 bl, BYTE PTR _locnames[eax*4]
  08f04	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _locnames[eax*4]
  08f0b	8b fb		 mov	 edi, ebx
  08f0d	33 db		 xor	 ebx, ebx
  08f0f	8a 19		 mov	 bl, BYTE PTR [ecx]
  08f11	40		 inc	 eax
  08f12	3b df		 cmp	 ebx, edi
  08f14	75 1a		 jne	 SHORT $nextword$62412
$L62413:
  08f16	8b cf		 mov	 ecx, edi
  08f18	4f		 dec	 edi
  08f19	85 c9		 test	 ecx, ecx
  08f1b	0f 84 94 00 00
	00		 je	 $L62414
  08f21	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  08f24	8a 08		 mov	 cl, BYTE PTR [eax]
  08f26	45		 inc	 ebp
  08f27	40		 inc	 eax
  08f28	3a cb		 cmp	 cl, bl
  08f2a	74 ea		 je	 SHORT $L62413
  08f2c	8b 4c 24 20	 mov	 ecx, DWORD PTR _str$[esp+24]
$nextword$62412:
  08f30	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  08f35	46		 inc	 esi
  08f36	3b f0		 cmp	 esi, eax
  08f38	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  08f3e	7c b2		 jl	 SHORT $L62409
$L62410:
  08f40	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  08f45	33 c9		 xor	 ecx, ecx
  08f47	33 f6		 xor	 esi, esi
  08f49	8d b8 b0 00 00
	00		 lea	 edi, DWORD PTR [eax+176]
  08f4f	89 74 24 20	 mov	 DWORD PTR _i$62392[esp+24], esi
  08f53	89 7c 24 14	 mov	 DWORD PTR -8+[esp+28], edi
$L62397:
  08f57	8b 07		 mov	 eax, DWORD PTR [edi]
  08f59	85 c0		 test	 eax, eax
  08f5b	0f 84 83 00 00
	00		 je	 $L62398
  08f61	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _origin
  08f67	74 7b		 je	 SHORT $L62398
  08f69	3b c6		 cmp	 eax, esi
  08f6b	74 71		 je	 SHORT $L62402
  08f6d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  08f70	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08f72	85 c9		 test	 ecx, ecx
  08f74	74 3b		 je	 SHORT $L62425
  08f76	33 c0		 xor	 eax, eax
  08f78	8a 02		 mov	 al, BYTE PTR [edx]
  08f7a	89 44 24 18	 mov	 DWORD PTR -4+[esp+28], eax
$L62424:
  08f7e	8d 46 05	 lea	 eax, DWORD PTR [esi+5]
  08f81	33 db		 xor	 ebx, ebx
  08f83	8d 6a 01	 lea	 ebp, DWORD PTR [edx+1]
  08f86	8a 18		 mov	 bl, BYTE PTR [eax]
  08f88	40		 inc	 eax
  08f89	8b fb		 mov	 edi, ebx
  08f8b	8b 5c 24 18	 mov	 ebx, DWORD PTR -4+[esp+28]
  08f8f	3b df		 cmp	 ebx, edi
  08f91	75 16		 jne	 SHORT $nextword$62427
$L62428:
  08f93	8b d7		 mov	 edx, edi
  08f95	4f		 dec	 edi
  08f96	85 d2		 test	 edx, edx
  08f98	74 22		 je	 SHORT $L62429
  08f9a	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  08f9d	8a 10		 mov	 dl, BYTE PTR [eax]
  08f9f	45		 inc	 ebp
  08fa0	40		 inc	 eax
  08fa1	3a d3		 cmp	 dl, bl
  08fa3	74 ee		 je	 SHORT $L62428
  08fa5	8b 54 24 10	 mov	 edx, DWORD PTR _tp$[esp+28]
$nextword$62427:
  08fa9	8b f1		 mov	 esi, ecx
  08fab	8b 0e		 mov	 ecx, DWORD PTR [esi]
  08fad	85 c9		 test	 ecx, ecx
  08faf	75 cd		 jne	 SHORT $L62424
$L62425:
  08fb1	33 c9		 xor	 ecx, ecx
  08fb3	eb 29		 jmp	 SHORT $L62402
$L62414:
  08fb5	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_lnamebuf
  08fba	eb 45		 jmp	 SHORT $L62485
$L62429:
  08fbc	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  08fbf	33 c0		 xor	 eax, eax
  08fc1	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  08fc4	80 e1 01	 and	 cl, 1
  08fc7	8d 54 30 09	 lea	 edx, DWORD PTR [eax+esi+9]
  08fcb	83 e2 fc	 and	 edx, -4			; fffffffcH
  08fce	f6 d9		 neg	 cl
  08fd0	1b c9		 sbb	 ecx, ecx
  08fd2	89 54 24 10	 mov	 DWORD PTR _tp$[esp+28], edx
  08fd6	83 e1 02	 and	 ecx, 2
  08fd9	49		 dec	 ecx
  08fda	85 c9		 test	 ecx, ecx
  08fdc	75 23		 jne	 SHORT $L62485
$L62402:
  08fde	8b 7c 24 14	 mov	 edi, DWORD PTR -8+[esp+28]
  08fe2	8b 37		 mov	 esi, DWORD PTR [edi]
$L62398:
  08fe4	8b 44 24 20	 mov	 eax, DWORD PTR _i$62392[esp+24]
  08fe8	83 c7 04	 add	 edi, 4
  08feb	40		 inc	 eax
  08fec	89 7c 24 14	 mov	 DWORD PTR -8+[esp+28], edi
  08ff0	83 f8 10	 cmp	 eax, 16			; 00000010H
  08ff3	89 44 24 20	 mov	 DWORD PTR _i$62392[esp+24], eax
  08ff7	0f 8c 5a ff ff
	ff		 jl	 $L62397
  08ffd	85 c9		 test	 ecx, ecx
  08fff	74 2c		 je	 SHORT $L60116
$L62485:

; 3295 : /*
; 3296 :  * If the word we found is a primitive, compile its primitive number
; 3297 :  * instead of its cfa
; 3298 :  */
; 3299 : 	if ( *(token_t *)tp < MAXPRIM )

  09001	8b 02		 mov	 eax, DWORD PTR [edx]
  09003	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  09008	73 02		 jae	 SHORT $L60118

; 3300 : 	    tp = *(token_t *)tp;

  0900a	8b d0		 mov	 edx, eax
$L60118:

; 3301 : 	xcompile(tp);

  0900c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09012	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  09015	50		 push	 eax
  09016	52		 push	 edx
  09017	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  0901a	89 71 70	 mov	 DWORD PTR [ecx+112], esi
  0901d	e8 00 00 00 00	 call	 _tokstore
  09022	83 c4 08	 add	 esp, 8
  09025	5f		 pop	 edi
  09026	5e		 pop	 esi
  09027	5d		 pop	 ebp
  09028	5b		 pop	 ebx

; 3305 :     }
; 3306 : }

  09029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0902c	c3		 ret	 0
$L60116:

; 3302 :     } else {
; 3303 : 	xcompile(LOSE);

  0902d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09033	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  09036	50		 push	 eax
  09037	6a 78		 push	 120			; 00000078H
  09039	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0903c	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  0903f	e8 00 00 00 00	 call	 _tokstore

; 3304 : 	where();

  09044	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  09049	83 c9 ff	 or	 ecx, -1
  0904c	33 c0		 xor	 eax, eax
  0904e	83 c4 08	 add	 esp, 8
  09051	f2 ae		 repne scasb
  09053	f7 d1		 not	 ecx
  09055	2b f9		 sub	 edi, ecx
  09057	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR $SG60211+2
  0905d	8b c1		 mov	 eax, ecx
  0905f	8b f7		 mov	 esi, edi
  09061	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09066	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _input_name
  0906c	c1 e9 02	 shr	 ecx, 2
  0906f	f3 a5		 rep movsd
  09071	8b c8		 mov	 ecx, eax
  09073	33 c0		 xor	 eax, eax
  09075	83 e1 03	 and	 ecx, 3
  09078	f3 a4		 rep movsb
  0907a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0907f	83 c9 ff	 or	 ecx, -1
  09082	f2 ae		 repne scasb
  09084	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR $SG60211
  0908b	4f		 dec	 edi
  0908c	66 89 0f	 mov	 WORD PTR [edi], cx
  0908f	88 57 02	 mov	 BYTE PTR [edi+2], dl
  09092	8a 45 00	 mov	 al, BYTE PTR [ebp]
  09095	84 c0		 test	 al, al
  09097	0f 84 f6 00 00
	00		 je	 $L62455
  0909d	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  090a2	83 c9 ff	 or	 ecx, -1
  090a5	33 c0		 xor	 eax, eax
  090a7	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60213+8
  090ae	f2 ae		 repne scasb
  090b0	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60213
  090b5	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60213+4
  090bb	4f		 dec	 edi
  090bc	89 07		 mov	 DWORD PTR [edi], eax
  090be	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  090c3	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  090c6	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  090cb	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  090cf	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  090d2	83 c0 05	 add	 eax, 5
  090d5	33 d2		 xor	 edx, edx
  090d7	8a 10		 mov	 dl, BYTE PTR [eax]
  090d9	40		 inc	 eax
  090da	8b f2		 mov	 esi, edx
  090dc	4a		 dec	 edx
  090dd	85 f6		 test	 esi, esi
  090df	74 0c		 je	 SHORT $L62461
  090e1	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L62460:
  090e4	8a 10		 mov	 dl, BYTE PTR [eax]
  090e6	88 11		 mov	 BYTE PTR [ecx], dl
  090e8	41		 inc	 ecx
  090e9	40		 inc	 eax
  090ea	4e		 dec	 esi
  090eb	75 f7		 jne	 SHORT $L62460
$L62461:
  090ed	c6 01 00	 mov	 BYTE PTR [ecx], 0
  090f0	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  090f5	83 c9 ff	 or	 ecx, -1
  090f8	33 c0		 xor	 eax, eax
  090fa	f2 ae		 repne scasb
  090fc	f7 d1		 not	 ecx
  090fe	2b f9		 sub	 edi, ecx
  09100	8b f7		 mov	 esi, edi
  09102	8b d1		 mov	 edx, ecx
  09104	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09109	83 c9 ff	 or	 ecx, -1
  0910c	f2 ae		 repne scasb
  0910e	8b ca		 mov	 ecx, edx
  09110	4f		 dec	 edi
  09111	c1 e9 02	 shr	 ecx, 2
  09114	f3 a5		 rep movsd
  09116	8b ca		 mov	 ecx, edx
  09118	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  0911f	83 e1 03	 and	 ecx, 3
  09122	f3 a4		 rep movsb
  09124	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09129	83 c9 ff	 or	 ecx, -1
  0912c	f2 ae		 repne scasb
  0912e	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  09133	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  09139	4f		 dec	 edi
  0913a	89 07		 mov	 DWORD PTR [edi], eax
  0913c	8b c5		 mov	 eax, ebp
  0913e	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  09141	33 c9		 xor	 ecx, ecx
  09143	40		 inc	 eax
  09144	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  09148	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  0914b	8b f1		 mov	 esi, ecx
  0914d	49		 dec	 ecx
  0914e	85 f6		 test	 esi, esi
  09150	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  09155	74 0c		 je	 SHORT $L62467
  09157	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L62466:
  0915a	8a 08		 mov	 cl, BYTE PTR [eax]
  0915c	88 0a		 mov	 BYTE PTR [edx], cl
  0915e	42		 inc	 edx
  0915f	40		 inc	 eax
  09160	4e		 dec	 esi
  09161	75 f7		 jne	 SHORT $L62466
$L62467:
  09163	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  09168	83 c9 ff	 or	 ecx, -1
  0916b	33 c0		 xor	 eax, eax
  0916d	c6 02 00	 mov	 BYTE PTR [edx], 0
  09170	f2 ae		 repne scasb
  09172	f7 d1		 not	 ecx
  09174	2b f9		 sub	 edi, ecx
  09176	8b f7		 mov	 esi, edi
  09178	8b d1		 mov	 edx, ecx
  0917a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0917f	83 c9 ff	 or	 ecx, -1
  09182	f2 ae		 repne scasb
  09184	8b ca		 mov	 ecx, edx
  09186	4f		 dec	 edi
  09187	c1 e9 02	 shr	 ecx, 2
  0918a	f3 a5		 rep movsd
  0918c	8b ca		 mov	 ecx, edx
  0918e	83 e1 03	 and	 ecx, 3
  09191	f3 a4		 rep movsb
$L62455:
  09193	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09198	83 c9 ff	 or	 ecx, -1
  0919b	33 c0		 xor	 eax, eax
  0919d	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  091a2	f2 ae		 repne scasb
  091a4	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  091aa	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  091ae	e8 00 00 00 00	 call	 _error
  091b3	83 c4 04	 add	 esp, 4
  091b6	5f		 pop	 edi
  091b7	5e		 pop	 esi
  091b8	5d		 pop	 ebp
  091b9	5b		 pop	 ebx

; 3305 :     }
; 3306 : }

  091ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  091bd	c3		 ret	 0
_scompile ENDP
_TEXT	ENDS
PUBLIC	_execute_one
_TEXT	SEGMENT
_token$ = 8
_CFABuff$ = -8
_execute_one PROC NEAR

; 3311 : {

  091c0	83 ec 08	 sub	 esp, 8

; 3312 : 	token_t CFABuff[2];
; 3313 : 
; 3314 : 	CFABuff[0] = token;

  091c3	8b 44 24 0c	 mov	 eax, DWORD PTR _token$[esp+4]

; 3315 : 	CFABuff[1] = (token_t) FINISHED;
; 3316 : 	inner_interpreter(CFABuff);

  091c7	8d 4c 24 00	 lea	 ecx, DWORD PTR _CFABuff$[esp+8]
  091cb	51		 push	 ecx
  091cc	89 44 24 04	 mov	 DWORD PTR _CFABuff$[esp+12], eax
  091d0	c7 44 24 08 69
	00 00 00	 mov	 DWORD PTR _CFABuff$[esp+16], 105 ; 00000069H
  091d8	e8 00 00 00 00	 call	 _inner_interpreter

; 3317 : }

  091dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  091e0	c3		 ret	 0
_execute_one ENDP
_TEXT	ENDS
PUBLIC	_execute_one_with_one_arg
_TEXT	SEGMENT
_token$ = 8
_arg$ = 12
_CFABuff$ = -8
_execute_one_with_one_arg PROC NEAR

; 3323 : {

  091f0	83 ec 08	 sub	 esp, 8

; 3324 : 	token_t CFABuff[2];
; 3325 : 
; 3326 : 	*--xsp = arg;

  091f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  091f8	8b 4c 24 10	 mov	 ecx, DWORD PTR _arg$[esp+4]

; 3327 : 	CFABuff[0] = token;

  091fc	8b 54 24 0c	 mov	 edx, DWORD PTR _token$[esp+4]
  09200	83 e8 04	 sub	 eax, 4
  09203	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09208	89 08		 mov	 DWORD PTR [eax], ecx

; 3328 : 	CFABuff[1] = (token_t) FINISHED;
; 3329 : 	inner_interpreter(CFABuff);

  0920a	8d 44 24 00	 lea	 eax, DWORD PTR _CFABuff$[esp+8]
  0920e	50		 push	 eax
  0920f	89 54 24 04	 mov	 DWORD PTR _CFABuff$[esp+12], edx
  09213	c7 44 24 08 69
	00 00 00	 mov	 DWORD PTR _CFABuff$[esp+16], 105 ; 00000069H
  0921b	e8 00 00 00 00	 call	 _inner_interpreter

; 3330 : }

  09220	83 c4 0c	 add	 esp, 12			; 0000000cH
  09223	c3		 ret	 0
_execute_one_with_one_arg ENDP
_TEXT	ENDS
PUBLIC	_Xexecute_one_with_one_arg
_TEXT	SEGMENT
_token$ = 8
_arg$ = 12
_oldsp$ = -3596
_intstack$ = -1536
_rstack$ = -1024
_fstack$ = -512
_CFABuff$ = -3592
_userarea$ = -3584
_localtibbuf$ = -1280
_Xexecute_one_with_one_arg PROC NEAR

; 3336 : {

  09230	81 ec 0c 0e 00
	00		 sub	 esp, 3596		; 00000e0cH
  09236	53		 push	 ebx
  09237	55		 push	 ebp
  09238	56		 push	 esi
  09239	57		 push	 edi

; 3337 : 	cell *oldup;
; 3338 : 	cell *oldsp;
; 3339 : 	token_t **oldrp;
; 3340 : 	double *oldfsp;
; 3341 : 	cell *oldfrp;
; 3342 : 	cell intstack[64];
; 3343 : 	token_t *rstack[128];
; 3344 : 	double fstack[64];
; 3345 : 	token_t CFABuff[2];
; 3346 : 	char userarea[MAXUSER];
; 3347 : 	char localtibbuf[256];
; 3348 : 
; 3349 : 	/* Set up a context for the meme to be executed.  Copy the main task's
; 3350 : 	 * user area.  Use the locally allocated integer, return, and float
; 3351 : 	 * stacks.
; 3352 : 	 */
; 3353 : 	memcpy(userarea, main_task, MAXUSER);

  0923a	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0923f	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_main_task
  09244	8d 7c 24 1c	 lea	 edi, DWORD PTR _userarea$[esp+3612]

; 3354 : 	oldfrp = xfrp; xfrp = 0;
; 3355 : 	oldup = xup;  xup = (cell *)userarea; XV_LINK = (cell)xup;
; 3356 : 	oldfsp = xfsp; XV_FPZERO = (cell)(xfsp = &fstack[64]);

  09248	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _xfsp
  0924e	f3 a5		 rep movsd
  09250	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _xup

; 3357 : 	oldrp = xrp; XV_RPZERO = (cell)(xrp = &rstack[128]);

  09256	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _xrp
  0925c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _userarea$[esp+3612]
  09260	8d 54 24 1c	 lea	 edx, DWORD PTR _userarea$[esp+3612]
  09264	89 0d 00 00 00
	00		 mov	 DWORD PTR _xup, ecx
  0926a	8d 8c 24 1c 0e
	00 00		 lea	 ecx, DWORD PTR _fstack$[esp+4124]
  09271	89 54 24 78	 mov	 DWORD PTR _userarea$[esp+3704], edx
  09275	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfsp, ecx
  0927b	8d 94 24 1c 0e
	00 00		 lea	 edx, DWORD PTR _fstack$[esp+4124]
  09282	8d 8c 24 1c 0c
	00 00		 lea	 ecx, DWORD PTR _rstack$[esp+4124]
  09289	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xfrp
  0928f	89 94 24 b4 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3764], edx
  09296	89 0d 00 00 00
	00		 mov	 DWORD PTR _xrp, ecx

; 3358 : 	intstack[63] = arg;

  0929c	8b 8c 24 24 0e
	00 00		 mov	 ecx, DWORD PTR _arg$[esp+3608]
  092a3	8d 94 24 1c 0c
	00 00		 lea	 edx, DWORD PTR _rstack$[esp+4124]
  092aa	89 8c 24 18 09
	00 00		 mov	 DWORD PTR _intstack$[esp+3864], ecx
  092b1	89 54 24 44	 mov	 DWORD PTR _userarea$[esp+3652], edx

; 3359 : 	oldsp = xsp; xsp = &intstack[63];

  092b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xsp
  092bb	8d 8c 24 18 09
	00 00		 lea	 ecx, DWORD PTR _intstack$[esp+3864]
  092c2	33 c0		 xor	 eax, eax
  092c4	89 54 24 10	 mov	 DWORD PTR _oldsp$[esp+3612], edx
  092c8	89 0d 00 00 00
	00		 mov	 DWORD PTR _xsp, ecx

; 3360 : 	XV_SPZERO = (cell)&intstack[64];

  092ce	8d 94 24 1c 09
	00 00		 lea	 edx, DWORD PTR _intstack$[esp+3868]

; 3361 : 
; 3362 : 	
; 3363 : 	/* Make sure these user variables are clean regardless of maintask's
; 3364 : 	 * values for them.
; 3365 : 	 */
; 3366 : 	XV_HANDLER = 0;						/* For throw and catch */
; 3367 : 	XV_SPAN = XV_TO_IN = XV_BLK = XV_NUM_TIB = 0;
; 3368 : 	XV_NUM_OUT = XV_NUM_LINE = 0;
; 3369 :     XV_TICK_TIB = (cell)&localtibbuf[0];

  092d5	8d 8c 24 1c 09
	00 00		 lea	 ecx, DWORD PTR _localtibbuf$[esp+3612]
  092dc	a3 00 00 00 00	 mov	 DWORD PTR _xfrp, eax
  092e1	89 44 24 70	 mov	 DWORD PTR _userarea$[esp+3696], eax
  092e5	89 44 24 30	 mov	 DWORD PTR _userarea$[esp+3632], eax
  092e9	89 44 24 2c	 mov	 DWORD PTR _userarea$[esp+3628], eax
  092ed	89 44 24 24	 mov	 DWORD PTR _userarea$[esp+3620], eax
  092f1	89 44 24 20	 mov	 DWORD PTR _userarea$[esp+3616], eax
  092f5	89 44 24 54	 mov	 DWORD PTR _userarea$[esp+3668], eax
  092f9	89 44 24 50	 mov	 DWORD PTR _userarea$[esp+3664], eax

; 3370 :     XV_BASE = 10;
; 3371 :     XV_TICK_EXPECT = (cell)SYS_EXPECT;
; 3372 :     XV_STATE = INTERPRETING;

  092fd	89 44 24 34	 mov	 DWORD PTR _userarea$[esp+3636], eax

; 3373 :     XV_TASK_ACTIVE = -1;
; 3374 :     XV_WARNING = 1;
; 3375 :     XV_DPL = -1;
; 3376 :     XV_CNT = -1;		/* Signifies debug support not present */
; 3377 :     XV_DEBUGGING = XV_IP_L = XV_IP_H = 0;

  09301	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3740], eax
  09308	89 84 24 98 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3736], eax
  0930f	89 84 24 90 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3728], eax

; 3378 :     XV_MOD_COMP = 0;	/* Not compiling into a module -MdG */

  09316	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3748], eax

; 3379 :     XV_MOD_LINK = 0;	/* No named modules currently exist */

  0931d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3756], eax

; 3380 : 	XV_NAMEDTASK = 0;	/* The main task is unnamed.  Even though .Task

  09324	89 84 24 bc 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3772], eax

; 3381 : 						 * doesn't use this variable for printing the main
; 3382 : 						 * task, this variable is copied from the main task
; 3383 : 						 * when a new task is initialized.  This is a
; 3384 : 						 * way of initializing it.
; 3385 : 						 */
; 3386 : 	XV_PERTASK = 0;

  0932b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3776], eax

; 3387 : 	XV_REGIONVAR = 0;

  09332	89 84 24 c8 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3784], eax
  09339	89 54 24 40	 mov	 DWORD PTR _userarea$[esp+3648], edx

; 3388 : 
; 3389 : 
; 3390 : 	CFABuff[0] = token;

  0933d	8b 94 24 20 0e
	00 00		 mov	 edx, DWORD PTR _token$[esp+3608]
  09344	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3752], ecx

; 3391 : 	CFABuff[1] = (token_t) FINISHED;
; 3392 : 	inner_interpreter(CFABuff);

  0934b	8d 44 24 14	 lea	 eax, DWORD PTR _CFABuff$[esp+3612]
  0934f	83 c9 ff	 or	 ecx, -1
  09352	50		 push	 eax
  09353	c7 44 24 2c 0a
	00 00 00	 mov	 DWORD PTR _userarea$[esp+3628], 10 ; 0000000aH
  0935b	c7 44 24 78 f7
	00 00 00	 mov	 DWORD PTR _userarea$[esp+3704], 247 ; 000000f7H
  09363	89 8c 24 80 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3712], ecx
  0936a	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR _userarea$[esp+3684], 1
  09372	89 4c 24 60	 mov	 DWORD PTR _userarea$[esp+3680], ecx
  09376	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR _userarea$[esp+3748], ecx
  0937d	89 54 24 18	 mov	 DWORD PTR _CFABuff$[esp+3616], edx
  09381	c7 44 24 1c 69
	00 00 00	 mov	 DWORD PTR _CFABuff$[esp+3620], 105 ; 00000069H
  09389	e8 00 00 00 00	 call	 _inner_interpreter

; 3393 : 
; 3394 : 	xsp = oldsp;

  0938e	8b 4c 24 14	 mov	 ecx, DWORD PTR _oldsp$[esp+3616]
  09392	83 c4 04	 add	 esp, 4

; 3395 : 	xrp = oldrp;
; 3396 : 	xfsp = oldfsp;
; 3397 : 	xup = oldup;

  09395	89 3d 00 00 00
	00		 mov	 DWORD PTR _xup, edi

; 3398 : 	xfrp = oldfrp;

  0939b	89 35 00 00 00
	00		 mov	 DWORD PTR _xfrp, esi
  093a1	5f		 pop	 edi
  093a2	89 2d 00 00 00
	00		 mov	 DWORD PTR _xrp, ebp
  093a8	5e		 pop	 esi
  093a9	89 1d 00 00 00
	00		 mov	 DWORD PTR _xfsp, ebx
  093af	5d		 pop	 ebp
  093b0	89 0d 00 00 00
	00		 mov	 DWORD PTR _xsp, ecx
  093b6	5b		 pop	 ebx

; 3399 : }

  093b7	81 c4 0c 0e 00
	00		 add	 esp, 3596		; 00000e0cH
  093bd	c3		 ret	 0
_Xexecute_one_with_one_arg ENDP
_TEXT	ENDS
PUBLIC	_interpret_word
PUBLIC	_isfliteral
_TEXT	SEGMENT
_CFABuff$62550 = -8
_n$62587 = 8
_str$ = 8
_tp$ = -12
_interpret_word PROC NEAR

; 3405 :     cell tp = (cell)canonical(str);

  093c0	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  093c5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  093c8	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  093cb	53		 push	 ebx
  093cc	8b 5c 24 14	 mov	 ebx, DWORD PTR _str$[esp+12]
  093d0	55		 push	 ebp
  093d1	56		 push	 esi
  093d2	57		 push	 edi
  093d3	85 c9		 test	 ecx, ecx
  093d5	74 23		 je	 SHORT $L62504
  093d7	33 c0		 xor	 eax, eax
  093d9	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  093dc	8a 03		 mov	 al, BYTE PTR [ebx]
  093de	8b d0		 mov	 edx, eax
  093e0	48		 dec	 eax
  093e1	85 d2		 test	 edx, edx
  093e3	74 15		 je	 SHORT $L62504
  093e5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L62502:
  093e8	8a 01		 mov	 al, BYTE PTR [ecx]
  093ea	3c 41		 cmp	 al, 65			; 00000041H
  093ec	7c 08		 jl	 SHORT $L62503
  093ee	3c 5a		 cmp	 al, 90			; 0000005aH
  093f0	7f 04		 jg	 SHORT $L62503
  093f2	04 20		 add	 al, 32			; 00000020H
  093f4	88 01		 mov	 BYTE PTR [ecx], al
$L62503:
  093f6	41		 inc	 ecx
  093f7	4a		 dec	 edx
  093f8	75 ee		 jne	 SHORT $L62502
$L62504:

; 3406 :     int immed;
; 3407 : 
; 3408 :     if ((immed = find(&tp)) != 0) {

  093fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  093ff	8b eb		 mov	 ebp, ebx
  09401	33 f6		 xor	 esi, esi
  09403	89 6c 24 10	 mov	 DWORD PTR _tp$[esp+28], ebp
  09407	85 c0		 test	 eax, eax
  09409	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  0940f	7e 4b		 jle	 SHORT $L62529
  09411	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
$L62528:
  09414	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  09417	8b e9		 mov	 ebp, ecx
  09419	8d 14 46	 lea	 edx, DWORD PTR [esi+eax*2]
  0941c	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR _locnames[edx*4]
  09423	33 d2		 xor	 edx, edx
  09425	8a 10		 mov	 dl, BYTE PTR [eax]
  09427	40		 inc	 eax
  09428	8b fa		 mov	 edi, edx
  0942a	33 d2		 xor	 edx, edx
  0942c	8a 13		 mov	 dl, BYTE PTR [ebx]
  0942e	3b d7		 cmp	 edx, edi
  09430	75 16		 jne	 SHORT $nextword$62531
$L62532:
  09432	8b d7		 mov	 edx, edi
  09434	4f		 dec	 edi
  09435	85 d2		 test	 edx, edx
  09437	74 27		 je	 SHORT $L62533
  09439	8a 5d 00	 mov	 bl, BYTE PTR [ebp]
  0943c	8a 10		 mov	 dl, BYTE PTR [eax]
  0943e	45		 inc	 ebp
  0943f	40		 inc	 eax
  09440	3a d3		 cmp	 dl, bl
  09442	74 ee		 je	 SHORT $L62532
  09444	8b 5c 24 20	 mov	 ebx, DWORD PTR _str$[esp+24]
$nextword$62531:
  09448	a1 00 00 00 00	 mov	 eax, DWORD PTR _nlocnames
  0944d	46		 inc	 esi
  0944e	3b f0		 cmp	 esi, eax
  09450	89 35 00 00 00
	00		 mov	 DWORD PTR _locnum, esi
  09456	7c bc		 jl	 SHORT $L62528
  09458	8b 6c 24 10	 mov	 ebp, DWORD PTR _tp$[esp+28]
$L62529:
  0945c	33 c0		 xor	 eax, eax
  0945e	eb 13		 jmp	 SHORT $L62540
$L62533:
  09460	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _tp$[esp+28], OFFSET FLAT:_lnamebuf
  09468	8b 6c 24 10	 mov	 ebp, DWORD PTR _tp$[esp+28]
  0946c	b9 01 00 00 00	 mov	 ecx, 1
  09471	eb 4d		 jmp	 SHORT $L62643
$L62540:
  09473	33 d2		 xor	 edx, edx
  09475	bf b0 00 00 00	 mov	 edi, 176		; 000000b0H
$L62541:
  0947a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09480	8b 34 0f	 mov	 esi, DWORD PTR [edi+ecx]
  09483	85 f6		 test	 esi, esi
  09485	74 24		 je	 SHORT $L62542
  09487	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _origin
  0948d	74 1c		 je	 SHORT $L62542
  0948f	3b f2		 cmp	 esi, edx
  09491	74 16		 je	 SHORT $L62546
  09493	8d 54 24 10	 lea	 edx, DWORD PTR _tp$[esp+28]
  09497	56		 push	 esi
  09498	52		 push	 edx
  09499	e8 00 00 00 00	 call	 _vfind
  0949e	8b 6c 24 18	 mov	 ebp, DWORD PTR _tp$[esp+36]
  094a2	83 c4 08	 add	 esp, 8
  094a5	85 c0		 test	 eax, eax
  094a7	75 0d		 jne	 SHORT $L62634
$L62546:
  094a9	8b d6		 mov	 edx, esi
$L62542:
  094ab	83 c7 04	 add	 edi, 4
  094ae	81 ff f0 00 00
	00		 cmp	 edi, 240		; 000000f0H
  094b4	7c c4		 jl	 SHORT $L62541
$L62634:
  094b6	85 c0		 test	 eax, eax
  094b8	8b c8		 mov	 ecx, eax
  094ba	0f 84 59 02 00
	00		 je	 $L60167
$L62643:

; 3409 : /*
; 3410 :  * If the word we found is a primitive, use its primitive number
; 3411 :  * instead of its cfa
; 3412 :  */
; 3413 : 		if ( *(token_t *)tp < MAXPRIM )

  094c0	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  094c3	3d 90 01 00 00	 cmp	 eax, 400		; 00000190H
  094c8	73 06		 jae	 SHORT $L60169

; 3414 : 			tp = *(token_t *)tp;

  094ca	89 44 24 10	 mov	 DWORD PTR _tp$[esp+28], eax
  094ce	8b e8		 mov	 ebp, eax
$L60169:

; 3415 : /*
; 3416 :  * If the immediate bit is set or we're in interpreting state
; 3417 :  * execute the token, else compile it at the the top of the dictionary.
; 3418 :  */
; 3419 : 		if ( immed > 0 || XV_STATE == (cell)INTERPRETING ) {

  094d0	85 c9		 test	 ecx, ecx
  094d2	0f 8f 1b 02 00
	00		 jg	 $L60173
  094d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  094de	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  094e1	85 c0		 test	 eax, eax
  094e3	0f 84 0a 02 00
	00		 je	 $L60173

; 3421 : 		} else {
; 3422 : 			/* If compiling into a module, check whether we've referred
; 3423 : 			 * to a high-level definition outside the module.  If so,
; 3424 : 			 * print a warning message.
; 3425 : 			 */
; 3426 : 			if ( XV_MOD_COMP && XV_STATE == (cell) COMPILING) {

  094e9	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  094ef	85 d2		 test	 edx, edx
  094f1	0f 84 d8 01 00
	00		 je	 $L60196
  094f7	83 f8 01	 cmp	 eax, 1
  094fa	0f 85 cf 01 00
	00		 jne	 $L60196

; 3427 : 				if (tp >= MAXCF) {

  09500	81 fd 98 01 00
	00		 cmp	 ebp, 408		; 00000198H
  09506	0f 8c c3 01 00
	00		 jl	 $L60196

; 3428 : 					if ( (unsigned long)tp < (unsigned long)ThisModule ||
; 3429 : 								(unsigned long)tp >= (unsigned long)((cell)ThisModule->ModuleDict + 
; 3430 : 												ThisModule->RelTableOffset) ) {

  0950c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0950f	3b e8		 cmp	 ebp, eax
  09511	72 0f		 jb	 SHORT $L60188
  09513	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  09516	8d 54 02 40	 lea	 edx, DWORD PTR [edx+eax+64]
  0951a	3b ea		 cmp	 ebp, edx
  0951c	0f 82 ad 01 00
	00		 jb	 $L60196
$L60188:

; 3431 : 						if ( (u_cell)tp < (u_cell)(ThisModule->CompilationLibOrigin) ||
; 3432 : 							 (u_cell)tp >= (u_cell)(((module *)(ThisModule->CompilationLibOrigin))->ModuleDP) ) {

  09522	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  09525	3b e8		 cmp	 ebp, eax
  09527	72 09		 jb	 SHORT $L60197
  09529	3b 68 10	 cmp	 ebp, DWORD PTR [eax+16]
  0952c	0f 82 9d 01 00
	00		 jb	 $L60196
$L60197:

; 3433 : 							where();

  09532	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  09537	83 c9 ff	 or	 ecx, -1
  0953a	33 c0		 xor	 eax, eax
  0953c	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR $SG60211+2
  09542	f2 ae		 repne scasb
  09544	f7 d1		 not	 ecx
  09546	2b f9		 sub	 edi, ecx
  09548	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _input_name
  0954e	8b c1		 mov	 eax, ecx
  09550	8b f7		 mov	 esi, edi
  09552	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09557	c1 e9 02	 shr	 ecx, 2
  0955a	f3 a5		 rep movsd
  0955c	8b c8		 mov	 ecx, eax
  0955e	33 c0		 xor	 eax, eax
  09560	83 e1 03	 and	 ecx, 3
  09563	f3 a4		 rep movsb
  09565	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0956a	83 c9 ff	 or	 ecx, -1
  0956d	f2 ae		 repne scasb
  0956f	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR $SG60211
  09576	4f		 dec	 edi
  09577	66 89 0f	 mov	 WORD PTR [edi], cx
  0957a	88 57 02	 mov	 BYTE PTR [edi+2], dl
  0957d	8a 45 00	 mov	 al, BYTE PTR [ebp]
  09580	84 c0		 test	 al, al
  09582	0f 84 f6 00 00
	00		 je	 $L62583
  09588	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0958d	83 c9 ff	 or	 ecx, -1
  09590	33 c0		 xor	 eax, eax
  09592	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60213+8
  09599	f2 ae		 repne scasb
  0959b	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60213
  095a0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60213+4
  095a6	4f		 dec	 edi
  095a7	89 07		 mov	 DWORD PTR [edi], eax
  095a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  095ae	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  095b1	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  095b6	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  095ba	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  095bd	83 c0 05	 add	 eax, 5
  095c0	33 d2		 xor	 edx, edx
  095c2	8a 10		 mov	 dl, BYTE PTR [eax]
  095c4	40		 inc	 eax
  095c5	8b f2		 mov	 esi, edx
  095c7	4a		 dec	 edx
  095c8	85 f6		 test	 esi, esi
  095ca	74 0c		 je	 SHORT $L62575
  095cc	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L62574:
  095cf	8a 10		 mov	 dl, BYTE PTR [eax]
  095d1	88 11		 mov	 BYTE PTR [ecx], dl
  095d3	41		 inc	 ecx
  095d4	40		 inc	 eax
  095d5	4e		 dec	 esi
  095d6	75 f7		 jne	 SHORT $L62574
$L62575:
  095d8	c6 01 00	 mov	 BYTE PTR [ecx], 0
  095db	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  095e0	83 c9 ff	 or	 ecx, -1
  095e3	33 c0		 xor	 eax, eax
  095e5	f2 ae		 repne scasb
  095e7	f7 d1		 not	 ecx
  095e9	2b f9		 sub	 edi, ecx
  095eb	8b f7		 mov	 esi, edi
  095ed	8b d1		 mov	 edx, ecx
  095ef	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  095f4	83 c9 ff	 or	 ecx, -1
  095f7	f2 ae		 repne scasb
  095f9	8b ca		 mov	 ecx, edx
  095fb	4f		 dec	 edi
  095fc	c1 e9 02	 shr	 ecx, 2
  095ff	f3 a5		 rep movsd
  09601	8b ca		 mov	 ecx, edx
  09603	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  0960a	83 e1 03	 and	 ecx, 3
  0960d	f3 a4		 rep movsb
  0960f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09614	83 c9 ff	 or	 ecx, -1
  09617	f2 ae		 repne scasb
  09619	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  0961e	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  09624	4f		 dec	 edi
  09625	89 07		 mov	 DWORD PTR [edi], eax
  09627	8b c5		 mov	 eax, ebp
  09629	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0962c	33 c9		 xor	 ecx, ecx
  0962e	40		 inc	 eax
  0962f	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  09633	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  09636	8b f1		 mov	 esi, ecx
  09638	49		 dec	 ecx
  09639	85 f6		 test	 esi, esi
  0963b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  09640	74 0c		 je	 SHORT $L62581
  09642	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L62580:
  09645	8a 08		 mov	 cl, BYTE PTR [eax]
  09647	88 0a		 mov	 BYTE PTR [edx], cl
  09649	42		 inc	 edx
  0964a	40		 inc	 eax
  0964b	4e		 dec	 esi
  0964c	75 f7		 jne	 SHORT $L62580
$L62581:
  0964e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  09653	83 c9 ff	 or	 ecx, -1
  09656	33 c0		 xor	 eax, eax
  09658	c6 02 00	 mov	 BYTE PTR [edx], 0
  0965b	f2 ae		 repne scasb
  0965d	f7 d1		 not	 ecx
  0965f	2b f9		 sub	 edi, ecx
  09661	8b f7		 mov	 esi, edi
  09663	8b d1		 mov	 edx, ecx
  09665	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0966a	83 c9 ff	 or	 ecx, -1
  0966d	f2 ae		 repne scasb
  0966f	8b ca		 mov	 ecx, edx
  09671	4f		 dec	 edi
  09672	c1 e9 02	 shr	 ecx, 2
  09675	f3 a5		 rep movsd
  09677	8b ca		 mov	 ecx, edx
  09679	83 e1 03	 and	 ecx, 3
  0967c	f3 a4		 rep movsb
$L62583:
  0967e	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09683	83 c9 ff	 or	 ecx, -1
  09686	33 c0		 xor	 eax, eax
  09688	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  0968d	f2 ae		 repne scasb
  0968f	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  09695	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  09699	e8 00 00 00 00	 call	 _error

; 3434 : 							error("Warning: reference outside the module and std library\n");

  0969e	68 00 00 00 00	 push	 OFFSET FLAT:$SG60198
  096a3	e8 00 00 00 00	 call	 _error

; 3435 : 							xcompile(LOSE);

  096a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  096ae	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  096b1	50		 push	 eax
  096b2	6a 78		 push	 120			; 00000078H
  096b4	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  096b7	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  096ba	e8 00 00 00 00	 call	 _tokstore
  096bf	83 c4 10	 add	 esp, 16			; 00000010H

; 3436 : 							return(1);

  096c2	b8 01 00 00 00	 mov	 eax, 1
  096c7	5f		 pop	 edi
  096c8	5e		 pop	 esi
  096c9	5d		 pop	 ebp
  096ca	5b		 pop	 ebx

; 3459 : }

  096cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  096ce	c3		 ret	 0
$L60196:

; 3437 : 						}	/* if tp is outside the std library */
; 3438 : 					}	/* if tp is outside the module */
; 3439 : 				} /* if (tp > MAXPRIM) */
; 3440 : 			}	/* if (XV_MOD_COMP) */
; 3441 : 			xcompile(tp);

  096cf	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  096d2	50		 push	 eax
  096d3	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  096d6	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  096d9	8b 44 24 14	 mov	 eax, DWORD PTR _tp$[esp+32]
  096dd	50		 push	 eax
  096de	e8 00 00 00 00	 call	 _tokstore
  096e3	83 c4 08	 add	 esp, 8

; 3442 : 		}
; 3443 : 		return(1);

  096e6	b8 01 00 00 00	 mov	 eax, 1
  096eb	5f		 pop	 edi
  096ec	5e		 pop	 esi
  096ed	5d		 pop	 ebp
  096ee	5b		 pop	 ebx

; 3459 : }

  096ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  096f2	c3		 ret	 0
$L60173:

; 3420 : 			execute_one((token_t)tp);

  096f3	8d 4c 24 14	 lea	 ecx, DWORD PTR _CFABuff$62550[esp+28]
  096f7	89 6c 24 14	 mov	 DWORD PTR _CFABuff$62550[esp+28], ebp
  096fb	51		 push	 ecx
  096fc	c7 44 24 1c 69
	00 00 00	 mov	 DWORD PTR _CFABuff$62550[esp+36], 105 ; 00000069H
  09704	e8 00 00 00 00	 call	 _inner_interpreter
  09709	83 c4 04	 add	 esp, 4

; 3442 : 		}
; 3443 : 		return(1);

  0970c	b8 01 00 00 00	 mov	 eax, 1
  09711	5f		 pop	 edi
  09712	5e		 pop	 esi
  09713	5d		 pop	 ebp
  09714	5b		 pop	 ebx

; 3459 : }

  09715	83 c4 0c	 add	 esp, 12			; 0000000cH
  09718	c3		 ret	 0
$L60167:

; 3444 :     }
; 3445 :     if ( isfliteral(str) )

  09719	53		 push	 ebx
  0971a	e8 00 00 00 00	 call	 _isfliteral
  0971f	83 c4 04	 add	 esp, 4
  09722	85 c0		 test	 eax, eax
  09724	74 0d		 je	 SHORT $L60203
  09726	5f		 pop	 edi
  09727	5e		 pop	 esi
  09728	5d		 pop	 ebp

; 3446 :         return(1);

  09729	b8 01 00 00 00	 mov	 eax, 1
  0972e	5b		 pop	 ebx

; 3459 : }

  0972f	83 c4 0c	 add	 esp, 12			; 0000000cH
  09732	c3		 ret	 0
$L60203:

; 3447 : 
; 3448 :     if ( handle_literal(str) )

  09733	8d 54 24 20	 lea	 edx, DWORD PTR _n$62587[esp+24]
  09737	52		 push	 edx
  09738	53		 push	 ebx
  09739	e8 00 00 00 00	 call	 _number
  0973e	bb 01 00 00 00	 mov	 ebx, 1
  09743	83 c4 08	 add	 esp, 8
  09746	3b c3		 cmp	 eax, ebx
  09748	75 62		 jne	 SHORT $L60204
  0974a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09750	39 59 18	 cmp	 DWORD PTR [ecx+24], ebx
  09753	75 3a		 jne	 SHORT $L62590
  09755	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  09758	50		 push	 eax
  09759	6a 71		 push	 113			; 00000071H
  0975b	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0975e	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  09761	e8 00 00 00 00	 call	 _tokstore
  09766	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0976b	8b 54 24 28	 mov	 edx, DWORD PTR _n$62587[esp+32]
  0976f	83 c4 08	 add	 esp, 8
  09772	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  09775	5f		 pop	 edi
  09776	5e		 pop	 esi
  09777	89 11		 mov	 DWORD PTR [ecx], edx
  09779	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0977e	5d		 pop	 ebp
  0977f	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  09782	83 c1 04	 add	 ecx, 4
  09785	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 3449 :         return(1);

  09788	8b c3		 mov	 eax, ebx
  0978a	5b		 pop	 ebx

; 3459 : }

  0978b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0978e	c3		 ret	 0

; 3447 : 
; 3448 :     if ( handle_literal(str) )

$L62590:
  0978f	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  09794	8b 4c 24 20	 mov	 ecx, DWORD PTR _n$62587[esp+24]
  09798	83 e8 04	 sub	 eax, 4
  0979b	5f		 pop	 edi
  0979c	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  097a1	5e		 pop	 esi
  097a2	89 08		 mov	 DWORD PTR [eax], ecx

; 3449 :         return(1);

  097a4	8b c3		 mov	 eax, ebx
  097a6	5d		 pop	 ebp
  097a7	5b		 pop	 ebx

; 3459 : }

  097a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  097ab	c3		 ret	 0
$L60204:

; 3450 : 
; 3451 :     /* Undefined */
; 3452 :     where();

  097ac	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  097b1	83 c9 ff	 or	 ecx, -1
  097b4	33 c0		 xor	 eax, eax
  097b6	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _input_name
  097bc	f2 ae		 repne scasb
  097be	f7 d1		 not	 ecx
  097c0	2b f9		 sub	 edi, ecx
  097c2	8b d1		 mov	 edx, ecx
  097c4	8b f7		 mov	 esi, edi
  097c6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  097cb	c1 e9 02	 shr	 ecx, 2
  097ce	f3 a5		 rep movsd
  097d0	8b ca		 mov	 ecx, edx
  097d2	83 e1 03	 and	 ecx, 3
  097d5	f3 a4		 rep movsb
  097d7	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  097dc	83 c9 ff	 or	 ecx, -1
  097df	f2 ae		 repne scasb
  097e1	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60211
  097e7	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR $SG60211+2
  097ed	4f		 dec	 edi
  097ee	66 89 07	 mov	 WORD PTR [edi], ax
  097f1	88 4f 02	 mov	 BYTE PTR [edi+2], cl
  097f4	8a 45 00	 mov	 al, BYTE PTR [ebp]
  097f7	84 c0		 test	 al, al
  097f9	0f 84 f7 00 00
	00		 je	 $L62624
  097ff	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09804	83 c9 ff	 or	 ecx, -1
  09807	33 c0		 xor	 eax, eax
  09809	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR $SG60213
  0980f	f2 ae		 repne scasb
  09811	a1 04 00 00 00	 mov	 eax, DWORD PTR $SG60213+4
  09816	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR $SG60213+8
  0981d	4f		 dec	 edi
  0981e	89 17		 mov	 DWORD PTR [edi], edx
  09820	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  09826	89 47 04	 mov	 DWORD PTR [edi+4], eax
  09829	66 89 4f 08	 mov	 WORD PTR [edi+8], cx
  0982d	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  09830	83 c0 05	 add	 eax, 5
  09833	33 d2		 xor	 edx, edx
  09835	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0983a	8a 10		 mov	 dl, BYTE PTR [eax]
  0983c	40		 inc	 eax
  0983d	8b f2		 mov	 esi, edx
  0983f	4a		 dec	 edx
  09840	85 f6		 test	 esi, esi
  09842	74 0c		 je	 SHORT $L62616
  09844	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L62615:
  09847	8a 10		 mov	 dl, BYTE PTR [eax]
  09849	88 11		 mov	 BYTE PTR [ecx], dl
  0984b	41		 inc	 ecx
  0984c	40		 inc	 eax
  0984d	4e		 dec	 esi
  0984e	75 f7		 jne	 SHORT $L62615
$L62616:
  09850	c6 01 00	 mov	 BYTE PTR [ecx], 0
  09853	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  09858	83 c9 ff	 or	 ecx, -1
  0985b	33 c0		 xor	 eax, eax
  0985d	f2 ae		 repne scasb
  0985f	f7 d1		 not	 ecx
  09861	2b f9		 sub	 edi, ecx
  09863	8b f7		 mov	 esi, edi
  09865	8b d1		 mov	 edx, ecx
  09867	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0986c	83 c9 ff	 or	 ecx, -1
  0986f	f2 ae		 repne scasb
  09871	8b ca		 mov	 ecx, edx
  09873	4f		 dec	 edi
  09874	c1 e9 02	 shr	 ecx, 2
  09877	f3 a5		 rep movsd
  09879	8b ca		 mov	 ecx, edx
  0987b	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  09882	83 e1 03	 and	 ecx, 3
  09885	f3 a4		 rep movsb
  09887	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0988c	83 c9 ff	 or	 ecx, -1
  0988f	f2 ae		 repne scasb
  09891	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  09896	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  0989c	4f		 dec	 edi
  0989d	89 07		 mov	 DWORD PTR [edi], eax
  0989f	8b c5		 mov	 eax, ebp
  098a1	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  098a4	33 c9		 xor	 ecx, ecx
  098a6	40		 inc	 eax
  098a7	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  098ab	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  098ae	8b f1		 mov	 esi, ecx
  098b0	49		 dec	 ecx
  098b1	85 f6		 test	 esi, esi
  098b3	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  098b8	74 0c		 je	 SHORT $L62622
  098ba	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L62621:
  098bd	8a 08		 mov	 cl, BYTE PTR [eax]
  098bf	88 0a		 mov	 BYTE PTR [edx], cl
  098c1	42		 inc	 edx
  098c2	40		 inc	 eax
  098c3	4e		 dec	 esi
  098c4	75 f7		 jne	 SHORT $L62621
$L62622:
  098c6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  098cb	83 c9 ff	 or	 ecx, -1
  098ce	33 c0		 xor	 eax, eax
  098d0	c6 02 00	 mov	 BYTE PTR [edx], 0
  098d3	f2 ae		 repne scasb
  098d5	f7 d1		 not	 ecx
  098d7	2b f9		 sub	 edi, ecx
  098d9	8b f7		 mov	 esi, edi
  098db	8b d1		 mov	 edx, ecx
  098dd	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  098e2	83 c9 ff	 or	 ecx, -1
  098e5	f2 ae		 repne scasb
  098e7	8b ca		 mov	 ecx, edx
  098e9	4f		 dec	 edi
  098ea	c1 e9 02	 shr	 ecx, 2
  098ed	f3 a5		 rep movsd
  098ef	8b ca		 mov	 ecx, edx
  098f1	83 e1 03	 and	 ecx, 3
  098f4	f3 a4		 rep movsb
$L62624:
  098f6	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  098fb	83 c9 ff	 or	 ecx, -1
  098fe	33 c0		 xor	 eax, eax
  09900	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  09905	f2 ae		 repne scasb
  09907	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  0990d	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  09911	e8 00 00 00 00	 call	 _error

; 3453 :     if ( XV_STATE == (cell)COMPILING ) {

  09916	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0991b	83 c4 04	 add	 esp, 4
  0991e	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  09921	75 1e		 jne	 SHORT $L60206

; 3454 : 		xcompile(LOSE);

  09923	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  09926	51		 push	 ecx
  09927	6a 78		 push	 120			; 00000078H
  09929	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0992c	89 50 70	 mov	 DWORD PTR [eax+112], edx
  0992f	e8 00 00 00 00	 call	 _tokstore
  09934	83 c4 08	 add	 esp, 8

; 3455 : 		return(1);

  09937	8b c3		 mov	 eax, ebx
  09939	5f		 pop	 edi
  0993a	5e		 pop	 esi
  0993b	5d		 pop	 ebp
  0993c	5b		 pop	 ebx

; 3459 : }

  0993d	83 c4 0c	 add	 esp, 12			; 0000000cH
  09940	c3		 ret	 0
$L60206:

; 3456 :     }
; 3457 :     pop_all();

  09941	e8 00 00 00 00	 call	 _pop_all
  09946	5f		 pop	 edi
  09947	5e		 pop	 esi
  09948	5d		 pop	 ebp

; 3458 :     return(0);

  09949	33 c0		 xor	 eax, eax
  0994b	5b		 pop	 ebx

; 3459 : }

  0994c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0994f	c3		 ret	 0
_interpret_word ENDP
_TEXT	ENDS
PUBLIC	_where
_TEXT	SEGMENT
_where	PROC NEAR

; 3463 : {

  09950	55		 push	 ebp
  09951	56		 push	 esi
  09952	57		 push	 edi

; 3464 :     strcpy(errMsg, (char *)&wordbuf[1]); strcat(errMsg, " ?");

  09953	bf 01 00 00 00	 mov	 edi, OFFSET FLAT:_wordbuf+1
  09958	83 c9 ff	 or	 ecx, -1
  0995b	33 c0		 xor	 eax, eax
  0995d	f2 ae		 repne scasb
  0995f	f7 d1		 not	 ecx
  09961	2b f9		 sub	 edi, ecx
  09963	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR $SG60211+2
  09969	8b c1		 mov	 eax, ecx
  0996b	8b f7		 mov	 esi, edi
  0996d	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg

; 3465 :     if( input_name[0] != '\0' ) {

  09972	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _input_name
  09978	c1 e9 02	 shr	 ecx, 2
  0997b	f3 a5		 rep movsd
  0997d	8b c8		 mov	 ecx, eax
  0997f	33 c0		 xor	 eax, eax
  09981	83 e1 03	 and	 ecx, 3
  09984	f3 a4		 rep movsb
  09986	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0998b	83 c9 ff	 or	 ecx, -1
  0998e	f2 ae		 repne scasb
  09990	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR $SG60211
  09997	4f		 dec	 edi
  09998	66 89 0f	 mov	 WORD PTR [edi], cx
  0999b	88 57 02	 mov	 BYTE PTR [edi+2], dl
  0999e	8a 45 00	 mov	 al, BYTE PTR [ebp]
  099a1	84 c0		 test	 al, al
  099a3	0f 84 f6 00 00
	00		 je	 $L60212

; 3466 :         strcat(errMsg, "   Last: ");

  099a9	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  099ae	83 c9 ff	 or	 ecx, -1
  099b1	33 c0		 xor	 eax, eax
  099b3	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60213+8
  099ba	f2 ae		 repne scasb
  099bc	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60213
  099c1	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60213+4
  099c7	4f		 dec	 edi
  099c8	89 07		 mov	 DWORD PTR [edi], eax

; 3467 : 	strcat(errMsg, tocstr(&((XV_LAST) -> name)));

  099ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  099cf	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  099d2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  099d7	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  099db	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  099de	83 c0 05	 add	 eax, 5
  099e1	33 d2		 xor	 edx, edx
  099e3	8a 10		 mov	 dl, BYTE PTR [eax]
  099e5	40		 inc	 eax
  099e6	8b f2		 mov	 esi, edx
  099e8	4a		 dec	 edx
  099e9	85 f6		 test	 esi, esi
  099eb	74 0c		 je	 SHORT $L62656

; 3466 :         strcat(errMsg, "   Last: ");

  099ed	8d 72 01	 lea	 esi, DWORD PTR [edx+1]

; 3467 : 	strcat(errMsg, tocstr(&((XV_LAST) -> name)));

$L62655:
  099f0	8a 10		 mov	 dl, BYTE PTR [eax]
  099f2	88 11		 mov	 BYTE PTR [ecx], dl
  099f4	41		 inc	 ecx
  099f5	40		 inc	 eax
  099f6	4e		 dec	 esi
  099f7	75 f7		 jne	 SHORT $L62655
$L62656:
  099f9	c6 01 00	 mov	 BYTE PTR [ecx], 0
  099fc	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  09a01	83 c9 ff	 or	 ecx, -1
  09a04	33 c0		 xor	 eax, eax
  09a06	f2 ae		 repne scasb
  09a08	f7 d1		 not	 ecx
  09a0a	2b f9		 sub	 edi, ecx
  09a0c	8b f7		 mov	 esi, edi
  09a0e	8b d1		 mov	 edx, ecx
  09a10	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09a15	83 c9 ff	 or	 ecx, -1
  09a18	f2 ae		 repne scasb
  09a1a	8b ca		 mov	 ecx, edx
  09a1c	4f		 dec	 edi
  09a1d	c1 e9 02	 shr	 ecx, 2
  09a20	f3 a5		 rep movsd
  09a22	8b ca		 mov	 ecx, edx

; 3468 : 	strcat(errMsg, "   File: ");

  09a24	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60215+8
  09a2b	83 e1 03	 and	 ecx, 3
  09a2e	f3 a4		 rep movsb
  09a30	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09a35	83 c9 ff	 or	 ecx, -1
  09a38	f2 ae		 repne scasb
  09a3a	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60215
  09a3f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60215+4
  09a45	4f		 dec	 edi
  09a46	89 07		 mov	 DWORD PTR [edi], eax

; 3469 : 	strcat(errMsg, tocstr(input_name) );

  09a48	8b c5		 mov	 eax, ebp
  09a4a	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  09a4d	33 c9		 xor	 ecx, ecx
  09a4f	40		 inc	 eax
  09a50	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  09a54	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  09a57	8b f1		 mov	 esi, ecx
  09a59	49		 dec	 ecx
  09a5a	85 f6		 test	 esi, esi
  09a5c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  09a61	74 0c		 je	 SHORT $L62664

; 3467 : 	strcat(errMsg, tocstr(&((XV_LAST) -> name)));

  09a63	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]

; 3469 : 	strcat(errMsg, tocstr(input_name) );

$L62663:
  09a66	8a 08		 mov	 cl, BYTE PTR [eax]
  09a68	88 0a		 mov	 BYTE PTR [edx], cl
  09a6a	42		 inc	 edx
  09a6b	40		 inc	 eax
  09a6c	4e		 dec	 esi
  09a6d	75 f7		 jne	 SHORT $L62663
$L62664:
  09a6f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  09a74	83 c9 ff	 or	 ecx, -1
  09a77	33 c0		 xor	 eax, eax
  09a79	c6 02 00	 mov	 BYTE PTR [edx], 0
  09a7c	f2 ae		 repne scasb
  09a7e	f7 d1		 not	 ecx
  09a80	2b f9		 sub	 edi, ecx
  09a82	8b f7		 mov	 esi, edi
  09a84	8b d1		 mov	 edx, ecx
  09a86	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09a8b	83 c9 ff	 or	 ecx, -1
  09a8e	f2 ae		 repne scasb
  09a90	8b ca		 mov	 ecx, edx
  09a92	4f		 dec	 edi
  09a93	c1 e9 02	 shr	 ecx, 2
  09a96	f3 a5		 rep movsd
  09a98	8b ca		 mov	 ecx, edx
  09a9a	83 e1 03	 and	 ecx, 3
  09a9d	f3 a4		 rep movsb
$L60212:

; 3470 :     }
; 3471 :     strcat(errMsg, "\n");

  09a9f	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  09aa4	83 c9 ff	 or	 ecx, -1
  09aa7	33 c0		 xor	 eax, eax

; 3472 : 	error(errMsg);

  09aa9	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  09aae	f2 ae		 repne scasb
  09ab0	66 a1 00 00 00
	00		 mov	 ax, WORD PTR $SG60216
  09ab6	66 89 47 ff	 mov	 WORD PTR [edi-1], ax
  09aba	e8 00 00 00 00	 call	 _error
  09abf	83 c4 04	 add	 esp, 4
  09ac2	5f		 pop	 edi
  09ac3	5e		 pop	 esi
  09ac4	5d		 pop	 ebp

; 3473 : }

  09ac5	c3		 ret	 0
_where	ENDP
_TEXT	ENDS
PUBLIC	_handle_literal
_TEXT	SEGMENT
_str$ = 8
_n$ = 8
_handle_literal PROC NEAR

; 3479 :     long n;
; 3480 :     int ok;
; 3481 : 
; 3482 :     ok = number( str, &n );

  09ad0	8b 4c 24 04	 mov	 ecx, DWORD PTR _str$[esp-4]
  09ad4	8d 44 24 04	 lea	 eax, DWORD PTR _n$[esp-4]
  09ad8	50		 push	 eax
  09ad9	51		 push	 ecx
  09ada	e8 00 00 00 00	 call	 _number
  09adf	83 c4 08	 add	 esp, 8

; 3483 :     if ( ok == 1 ) {

  09ae2	83 f8 01	 cmp	 eax, 1
  09ae5	75 5b		 jne	 SHORT $L60222

; 3484 : 	if ( XV_STATE == (cell)COMPILING ) {

  09ae7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09aed	83 79 18 01	 cmp	 DWORD PTR [ecx+24], 1
  09af1	75 36		 jne	 SHORT $L60224

; 3485 : 	    xcompile(PAREN_LIT);  *XDP++ = (cell)n;

  09af3	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  09af6	50		 push	 eax
  09af7	6a 71		 push	 113			; 00000071H
  09af9	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  09afc	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  09aff	e8 00 00 00 00	 call	 _tokstore
  09b04	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09b09	8b 54 24 0c	 mov	 edx, DWORD PTR _n$[esp+4]
  09b0d	83 c4 08	 add	 esp, 8
  09b10	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  09b13	89 11		 mov	 DWORD PTR [ecx], edx
  09b15	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09b1a	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  09b1d	83 c1 04	 add	 ecx, 4
  09b20	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 3488 : 	}
; 3489 : 	return (1);

  09b23	b8 01 00 00 00	 mov	 eax, 1

; 3492 : }

  09b28	c3		 ret	 0
$L60224:

; 3486 : 	} else {
; 3487 : 	    *--xsp = (cell)n;

  09b29	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  09b2e	8b 4c 24 04	 mov	 ecx, DWORD PTR _n$[esp-4]
  09b32	83 e8 04	 sub	 eax, 4
  09b35	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09b3a	89 08		 mov	 DWORD PTR [eax], ecx

; 3488 : 	}
; 3489 : 	return (1);

  09b3c	b8 01 00 00 00	 mov	 eax, 1

; 3492 : }

  09b41	c3		 ret	 0
$L60222:

; 3490 :     }
; 3491 :     return (0);

  09b42	33 c0		 xor	 eax, eax

; 3492 : }

  09b44	c3		 ret	 0
_handle_literal ENDP
_TEXT	ENDS
PUBLIC	_query
_TEXT	SEGMENT
_CFABuff$62675 = -8
_query	PROC NEAR

; 3496 : {

  09b50	83 ec 08	 sub	 esp, 8

; 3497 : 	*--xsp = (cell)tibbuf;

  09b53	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp

; 3498 : 	*--xsp = (cell)TIBSIZE;
; 3499 : 	(void)execute_one((token_t)EXPECT);

  09b58	c7 44 24 00 3c
	00 00 00	 mov	 DWORD PTR _CFABuff$62675[esp+8], 60 ; 0000003cH
  09b60	83 e8 04	 sub	 eax, 4
  09b63	c7 44 24 04 69
	00 00 00	 mov	 DWORD PTR _CFABuff$62675[esp+12], 105 ; 00000069H
  09b6b	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09b70	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_tibbuf
  09b76	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  09b7b	83 e8 04	 sub	 eax, 4
  09b7e	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09b83	c7 00 00 01 00
	00		 mov	 DWORD PTR [eax], 256	; 00000100H
  09b89	8d 44 24 00	 lea	 eax, DWORD PTR _CFABuff$62675[esp+8]
  09b8d	50		 push	 eax
  09b8e	e8 00 00 00 00	 call	 _inner_interpreter

; 3500 : 	XV_NUM_TIB = XV_SPAN;

  09b93	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09b98	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  09b9b	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3501 : 	XV_TO_IN = 0;

  09b9e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  09ba4	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 3502 : }

  09bab	83 c4 0c	 add	 esp, 12			; 0000000cH
  09bae	c3		 ret	 0
_query	ENDP
_TEXT	ENDS
PUBLIC	_interpret
EXTRN	_insane:DWORD
_TEXT	SEGMENT
_interpret PROC NEAR

; 3507 :     u_char *thisword;
; 3508 : 
; 3509 :     while ( (((thisword = blword())[0]) != 0) && interpret_word(thisword) ) {

  09bb0	e8 00 00 00 00	 call	 _blword
  09bb5	80 38 00	 cmp	 BYTE PTR [eax], 0
  09bb8	74 6f		 je	 SHORT $L60240
$L60239:
  09bba	50		 push	 eax
  09bbb	e8 00 00 00 00	 call	 _interpret_word
  09bc0	83 c4 04	 add	 esp, 4
  09bc3	85 c0		 test	 eax, eax
  09bc5	74 62		 je	 SHORT $L60240

; 3510 : 		if ( xsp > (cell *)XV_SPZERO ) {

  09bc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09bcc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xsp
  09bd2	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  09bd5	77 25		 ja	 SHORT $L62678

; 3513 : 			break;
; 3514 : 		}
; 3515 : 		if ( xfsp > (double *)XV_FPZERO ) {

  09bd7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xfsp
  09bdd	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]
  09be3	3b d1		 cmp	 edx, ecx
  09be5	77 2b		 ja	 SHORT $L62679

; 3518 : 			break;
; 3519 : 		}
; 3520 : #ifdef SIGNALS
; 3521 : 		insane = 0;

  09be7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _insane, 0
  09bf1	e8 00 00 00 00	 call	 _blword
  09bf6	80 38 00	 cmp	 BYTE PTR [eax], 0
  09bf9	75 bf		 jne	 SHORT $L60239

; 3522 : #endif
; 3523 :     }
; 3524 : }

  09bfb	c3		 ret	 0
$L62678:

; 3511 : 			xsp = (cell *)XV_SPZERO;

  09bfc	8b 40 24	 mov	 eax, DWORD PTR [eax+36]

; 3512 : 			error("Integer stack underflow\n");

  09bff	68 00 00 00 00	 push	 OFFSET FLAT:$SG60244
  09c04	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09c09	e8 00 00 00 00	 call	 _error
  09c0e	83 c4 04	 add	 esp, 4

; 3522 : #endif
; 3523 :     }
; 3524 : }

  09c11	c3		 ret	 0
$L62679:

; 3516 : 			xfsp = (double *)XV_FPZERO;

  09c12	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [eax+152]

; 3517 : 			error("Floating-point stack underflow\n");

  09c18	68 00 00 00 00	 push	 OFFSET FLAT:$SG60248
  09c1d	89 0d 00 00 00
	00		 mov	 DWORD PTR _xfsp, ecx
  09c23	e8 00 00 00 00	 call	 _error
  09c28	59		 pop	 ecx
$L60240:

; 3522 : #endif
; 3523 :     }
; 3524 : }

  09c29	c3		 ret	 0
_interpret ENDP
_TEXT	ENDS
PUBLIC	_interpret_line
_TEXT	SEGMENT
_CFABuff$62690 = -8
_interpret_line PROC NEAR

; 3528 : {

  09c30	83 ec 08	 sub	 esp, 8

; 3529 :     prompt();

  09c33	e8 00 00 00 00	 call	 _prompt

; 3530 :     query();		/* TIB now contains the line */

  09c38	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  09c3d	c7 44 24 00 3c
	00 00 00	 mov	 DWORD PTR _CFABuff$62690[esp+8], 60 ; 0000003cH
  09c45	83 e8 04	 sub	 eax, 4
  09c48	c7 44 24 04 69
	00 00 00	 mov	 DWORD PTR _CFABuff$62690[esp+12], 105 ; 00000069H
  09c50	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09c55	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_tibbuf
  09c5b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xsp
  09c60	83 e8 04	 sub	 eax, 4
  09c63	a3 00 00 00 00	 mov	 DWORD PTR _xsp, eax
  09c68	c7 00 00 01 00
	00		 mov	 DWORD PTR [eax], 256	; 00000100H
  09c6e	8d 44 24 00	 lea	 eax, DWORD PTR _CFABuff$62690[esp+8]
  09c72	50		 push	 eax
  09c73	e8 00 00 00 00	 call	 _inner_interpreter
  09c78	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09c7d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  09c80	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  09c83	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  09c89	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 3531 : #ifndef MEMEVIEW
; 3532 :     interpret();
; 3533 : #endif
; 3534 : }

  09c90	83 c4 0c	 add	 esp, 12			; 0000000cH
  09c93	c3		 ret	 0
_interpret_line ENDP
_TEXT	ENDS
PUBLIC	_outer_interpreter
_TEXT	SEGMENT
_outer_interpreter PROC NEAR

; 3539 : #ifdef MEMEVIEW
; 3540 :     ExitMeme(MEMEVIEWOUTERINTERPRETERSTATUS);

  09ca0	6a 06		 push	 6
  09ca2	e8 00 00 00 00	 call	 _ExitMeme
  09ca7	59		 pop	 ecx

; 3541 : #else
; 3542 :     XV_STATE = (cell)INTERPRETING;
; 3543 :     xsp = (cell *)XV_SPZERO;
; 3544 :     xfsp = (double *)XV_FPZERO;
; 3545 : 
; 3546 :     for (;;) {
; 3547 : 		/* Clear the return stack */
; 3548 : 		xrp = (token_t **)XV_RPZERO;
; 3549 : 
; 3550 : 		/* Print a prompt, get one line of text, and interpret it. */
; 3551 : 		interpret_line();
; 3552 :     }
; 3553 : #endif
; 3554 : }

  09ca8	c3		 ret	 0
_outer_interpreter ENDP
_str$ = 8
_n$ = 12
_c$ = 8
_number	PROC NEAR

; 3566 :     int base = XV_BASE;
; 3567 :     int len = *str++;

  09cb0	8b 54 24 04	 mov	 edx, DWORD PTR _str$[esp-4]
  09cb4	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09cb9	53		 push	 ebx
  09cba	33 db		 xor	 ebx, ebx
  09cbc	8a 1a		 mov	 bl, BYTE PTR [edx]
  09cbe	55		 push	 ebp
  09cbf	56		 push	 esi
  09cc0	57		 push	 edi
  09cc1	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  09cc4	42		 inc	 edx

; 3568 :     u_char c;
; 3569 :     int d;
; 3570 :     int isminus = 0;
; 3571 :     long accum = 0;
; 3572 : 
; 3573 :     XV_DPL = -100;

  09cc5	c7 40 40 9c ff
	ff ff		 mov	 DWORD PTR [eax+64], -100 ; ffffff9cH
  09ccc	33 ed		 xor	 ebp, ebp

; 3574 :     if( *str == '-' ) {

  09cce	8a 02		 mov	 al, BYTE PTR [edx]
  09cd0	33 f6		 xor	 esi, esi
  09cd2	3c 2d		 cmp	 al, 45			; 0000002dH
  09cd4	75 07		 jne	 SHORT $L60261

; 3575 : 	isminus = 1;
; 3576 : 	len--;

  09cd6	4b		 dec	 ebx
  09cd7	bd 01 00 00 00	 mov	 ebp, 1

; 3577 : 	++str;

  09cdc	42		 inc	 edx
$L60261:

; 3578 :     }
; 3579 :     for( ; len > 0; len-- ) {

  09cdd	85 db		 test	 ebx, ebx
  09cdf	7e 7a		 jle	 SHORT $L62700
$L60262:

; 3580 : 	c = *str++;

  09ce1	8a 02		 mov	 al, BYTE PTR [edx]
  09ce3	42		 inc	 edx

; 3581 : 	if( c == '.' )

  09ce4	3c 2e		 cmp	 al, 46			; 0000002eH
  09ce6	88 44 24 14	 mov	 BYTE PTR _c$[esp+12], al
  09cea	75 0e		 jne	 SHORT $L60265

; 3582 : 	    XV_DPL = 0;

  09cec	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09cf1	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 3583 : 	else {

  09cf8	eb 5c		 jmp	 SHORT $L60263
$L60265:

; 3584 : 	    if( -1 == (d = digit( (cell)base, c )) )

  09cfa	3c 30		 cmp	 al, 48			; 00000030H
  09cfc	72 12		 jb	 SHORT $L62704
  09cfe	3c 39		 cmp	 al, 57			; 00000039H
  09d00	77 0e		 ja	 SHORT $L62704
  09d02	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+12]
  09d06	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09d0b	83 e8 30	 sub	 eax, 48			; 00000030H
  09d0e	eb 2f		 jmp	 SHORT $L62709
$L62704:
  09d10	3c 61		 cmp	 al, 97			; 00000061H
  09d12	72 12		 jb	 SHORT $L62706
  09d14	3c 7a		 cmp	 al, 122			; 0000007aH
  09d16	77 0e		 ja	 SHORT $L62706
  09d18	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+12]
  09d1c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09d21	83 e8 57	 sub	 eax, 87			; 00000057H
  09d24	eb 19		 jmp	 SHORT $L62709
$L62706:
  09d26	3c 41		 cmp	 al, 65			; 00000041H
  09d28	72 12		 jb	 SHORT $L62708
  09d2a	3c 5a		 cmp	 al, 90			; 0000005aH
  09d2c	77 0e		 ja	 SHORT $L62708
  09d2e	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+12]
  09d32	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09d37	83 e8 37	 sub	 eax, 55			; 00000037H
  09d3a	eb 03		 jmp	 SHORT $L62709
$L62708:
  09d3c	83 c8 ff	 or	 eax, -1
$L62709:
  09d3f	3b c7		 cmp	 eax, edi
  09d41	7d 18		 jge	 SHORT $L62700
  09d43	83 f8 ff	 cmp	 eax, -1
  09d46	74 13		 je	 SHORT $L62700

; 3585 : 		break;
; 3586 : 	    ++XV_DPL;

  09d48	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup

; 3587 : 	    accum = accum * base + d;

  09d4e	0f af f7	 imul	 esi, edi
  09d51	ff 41 40	 inc	 DWORD PTR [ecx+64]
  09d54	03 f0		 add	 esi, eax
$L60263:
  09d56	4b		 dec	 ebx
  09d57	85 db		 test	 ebx, ebx
  09d59	7f 86		 jg	 SHORT $L60262

; 3584 : 	    if( -1 == (d = digit( (cell)base, c )) )

$L62700:

; 3588 : 	}
; 3589 :     }
; 3590 :     if (XV_DPL < 0)

  09d5b	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09d60	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  09d63	85 c9		 test	 ecx, ecx
  09d65	7d 07		 jge	 SHORT $L60269

; 3591 : 	XV_DPL = -1;

  09d67	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [eax+64], -1
$L60269:

; 3592 :     *n = isminus ? -accum : accum;

  09d6e	85 ed		 test	 ebp, ebp
  09d70	74 02		 je	 SHORT $L62694
  09d72	f7 de		 neg	 esi
$L62694:
  09d74	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+12]
  09d78	8b c6		 mov	 eax, esi
  09d7a	5f		 pop	 edi
  09d7b	5e		 pop	 esi
  09d7c	89 01		 mov	 DWORD PTR [ecx], eax

; 3593 :     return( len == 0 );

  09d7e	33 c0		 xor	 eax, eax
  09d80	85 db		 test	 ebx, ebx
  09d82	5d		 pop	 ebp
  09d83	5b		 pop	 ebx
  09d84	0f 94 c0	 sete	 al

; 3594 : }

  09d87	c3		 ret	 0
_number	ENDP
_TEXT	ENDS
PUBLIC	_digit
_TEXT	SEGMENT
_base$ = 8
_c$ = 12
_digit	PROC NEAR

; 3606 :     register int ival = c;
; 3607 : 
; 3608 :     if ('0' <= c && c <= '9')

  09d90	8b 44 24 08	 mov	 eax, DWORD PTR _c$[esp-4]
  09d94	3c 30		 cmp	 al, 48			; 00000030H
  09d96	72 0e		 jb	 SHORT $L60275
  09d98	3c 39		 cmp	 al, 57			; 00000039H
  09d9a	77 0a		 ja	 SHORT $L60275

; 3609 :         ival = c - '0';

  09d9c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09da1	83 e8 30	 sub	 eax, 48			; 00000030H

; 3610 :     else if ('a' <= c && c <= 'z')

  09da4	eb 27		 jmp	 SHORT $L60280
$L60275:
  09da6	3c 61		 cmp	 al, 97			; 00000061H
  09da8	72 0e		 jb	 SHORT $L60277
  09daa	3c 7a		 cmp	 al, 122			; 0000007aH
  09dac	77 0a		 ja	 SHORT $L60277

; 3611 :         ival = 10 + c - 'a';

  09dae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09db3	83 e8 57	 sub	 eax, 87			; 00000057H

; 3612 :     else if ('A' <= c && c <= 'Z')

  09db6	eb 15		 jmp	 SHORT $L60280
$L60277:
  09db8	3c 41		 cmp	 al, 65			; 00000041H
  09dba	72 0e		 jb	 SHORT $L60279
  09dbc	3c 5a		 cmp	 al, 90			; 0000005aH
  09dbe	77 0a		 ja	 SHORT $L60279

; 3613 :         ival = 10 + c - 'A';

  09dc0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  09dc5	83 e8 37	 sub	 eax, 55			; 00000037H

; 3614 :     else

  09dc8	eb 03		 jmp	 SHORT $L60280
$L60279:

; 3615 :         ival = -1;

  09dca	83 c8 ff	 or	 eax, -1
$L60280:

; 3616 :     return (ival < base ? ival : -1);

  09dcd	3b 44 24 04	 cmp	 eax, DWORD PTR _base$[esp-4]
  09dd1	7c 03		 jl	 SHORT $L62716
  09dd3	83 c8 ff	 or	 eax, -1
$L62716:

; 3617 : }

  09dd6	c3		 ret	 0
_digit	ENDP
_TEXT	ENDS
PUBLIC	_cmove
_TEXT	SEGMENT
_from$ = 8
_to$ = 12
_length$ = 16
_cmove	PROC NEAR

; 3624 :     while ((length--) != 0)

  09de0	8b 44 24 0c	 mov	 eax, DWORD PTR _length$[esp-4]
  09de4	8b c8		 mov	 ecx, eax
  09de6	48		 dec	 eax
  09de7	85 c9		 test	 ecx, ecx
  09de9	74 16		 je	 SHORT $L60288
  09deb	8b 4c 24 04	 mov	 ecx, DWORD PTR _from$[esp-4]
  09def	56		 push	 esi
  09df0	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  09df3	8b 44 24 0c	 mov	 eax, DWORD PTR _to$[esp]
$L60287:

; 3625 :         *to++ = *from++;

  09df7	8a 11		 mov	 dl, BYTE PTR [ecx]
  09df9	88 10		 mov	 BYTE PTR [eax], dl
  09dfb	40		 inc	 eax
  09dfc	41		 inc	 ecx
  09dfd	4e		 dec	 esi
  09dfe	75 f7		 jne	 SHORT $L60287
  09e00	5e		 pop	 esi
$L60288:

; 3626 : }

  09e01	c3		 ret	 0
_cmove	ENDP
_TEXT	ENDS
PUBLIC	_cmove_up
_TEXT	SEGMENT
_from$ = 8
_to$ = 12
_length$ = 16
_cmove_up PROC NEAR

; 3633 :     from += length;

  09e10	8b 44 24 04	 mov	 eax, DWORD PTR _from$[esp-4]
  09e14	8b 54 24 0c	 mov	 edx, DWORD PTR _length$[esp-4]

; 3634 :     to += length;

  09e18	8b 4c 24 08	 mov	 ecx, DWORD PTR _to$[esp-4]
  09e1c	56		 push	 esi
  09e1d	03 c2		 add	 eax, edx
  09e1f	03 ca		 add	 ecx, edx

; 3635 : 
; 3636 :     while ((length--) != 0)

  09e21	8b f2		 mov	 esi, edx
  09e23	4a		 dec	 edx
  09e24	85 f6		 test	 esi, esi
  09e26	74 0d		 je	 SHORT $L60296

; 3633 :     from += length;

  09e28	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L60295:

; 3637 :         *--to = *--from;

  09e2b	8a 50 ff	 mov	 dl, BYTE PTR [eax-1]
  09e2e	48		 dec	 eax
  09e2f	49		 dec	 ecx
  09e30	4e		 dec	 esi
  09e31	88 11		 mov	 BYTE PTR [ecx], dl
  09e33	75 f6		 jne	 SHORT $L60295
$L60296:
  09e35	5e		 pop	 esi

; 3638 : }

  09e36	c3		 ret	 0
_cmove_up ENDP
_TEXT	ENDS
PUBLIC	_fill
_TEXT	SEGMENT
_to$ = 8
_length$ = 12
_with$ = 16
_fill	PROC NEAR

; 3646 :     while ((length--) != 0)

  09e40	8b 44 24 08	 mov	 eax, DWORD PTR _length$[esp-4]
  09e44	8b c8		 mov	 ecx, eax
  09e46	48		 dec	 eax
  09e47	85 c9		 test	 ecx, ecx
  09e49	74 29		 je	 SHORT $L60303
  09e4b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  09e4e	8a 44 24 0c	 mov	 al, BYTE PTR _with$[esp-4]
  09e52	53		 push	 ebx
  09e53	8a d8		 mov	 bl, al
  09e55	8a fb		 mov	 bh, bl
  09e57	8b d1		 mov	 edx, ecx
  09e59	8b c3		 mov	 eax, ebx
  09e5b	57		 push	 edi
  09e5c	8b 7c 24 0c	 mov	 edi, DWORD PTR _to$[esp+4]
  09e60	c1 e0 10	 shl	 eax, 16			; 00000010H
  09e63	66 8b c3	 mov	 ax, bx
  09e66	c1 e9 02	 shr	 ecx, 2
  09e69	f3 ab		 rep stosd
  09e6b	8b ca		 mov	 ecx, edx
  09e6d	83 e1 03	 and	 ecx, 3
  09e70	f3 aa		 rep stosb
  09e72	5f		 pop	 edi
  09e73	5b		 pop	 ebx
$L60303:

; 3647 :         *to++ = with;
; 3648 : }

  09e74	c3		 ret	 0
_fill	ENDP
_TEXT	ENDS
PUBLIC	_tocstr
_TEXT	SEGMENT
_from$ = 8
_tocstr	PROC NEAR

; 3656 :     register int length = *from++;

  09e80	8b 4c 24 04	 mov	 ecx, DWORD PTR _from$[esp-4]
  09e84	33 d2		 xor	 edx, edx
  09e86	56		 push	 esi
  09e87	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  09e8c	8a 11		 mov	 dl, BYTE PTR [ecx]
  09e8e	41		 inc	 ecx

; 3657 : 
; 3658 :     while ((length--) != 0)

  09e8f	8b f2		 mov	 esi, edx
  09e91	4a		 dec	 edx
  09e92	85 f6		 test	 esi, esi
  09e94	74 0c		 je	 SHORT $L62729

; 3655 :     register char *to = astrbuf;

  09e96	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L60312:

; 3659 : 	*to++ = *from++;

  09e99	8a 11		 mov	 dl, BYTE PTR [ecx]
  09e9b	88 10		 mov	 BYTE PTR [eax], dl
  09e9d	40		 inc	 eax
  09e9e	41		 inc	 ecx
  09e9f	4e		 dec	 esi
  09ea0	75 f7		 jne	 SHORT $L60312
$L62729:

; 3660 : 
; 3661 :     *to++ = '\0';

  09ea2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3662 :     return (astrbuf);

  09ea5	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  09eaa	5e		 pop	 esi

; 3663 : }

  09eab	c3		 ret	 0
_tocstr	ENDP
_TEXT	ENDS
PUBLIC	_tofstr
_TEXT	SEGMENT
_from$ = 8
_tofstr	PROC NEAR

; 3668 : {

  09eb0	56		 push	 esi

; 3669 :     register u_char *to = (u_char *)&astrbuf[1];
; 3670 :     register u_char c;
; 3671 :     register int length = 0;
; 3672 : 
; 3673 :     while ( (c = *from++) != '\0' ) {

  09eb1	8b 74 24 08	 mov	 esi, DWORD PTR _from$[esp]
  09eb5	33 d2		 xor	 edx, edx
  09eb7	b9 01 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf+1
  09ebc	8a 06		 mov	 al, BYTE PTR [esi]
  09ebe	46		 inc	 esi
  09ebf	84 c0		 test	 al, al
  09ec1	74 13		 je	 SHORT $L62732
$L60322:

; 3674 : 	*to++ = c;

  09ec3	88 01		 mov	 BYTE PTR [ecx], al
  09ec5	41		 inc	 ecx

; 3675 : 	if (++length >= 255)

  09ec6	42		 inc	 edx
  09ec7	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  09ecd	7d 07		 jge	 SHORT $L62732
  09ecf	8a 06		 mov	 al, BYTE PTR [esi]
  09ed1	46		 inc	 esi
  09ed2	84 c0		 test	 al, al
  09ed4	75 ed		 jne	 SHORT $L60322
$L62732:

; 3676 : 	    break;
; 3677 :     }
; 3678 : 
; 3679 :     *to++ = '\0';

  09ed6	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 3680 :     *(u_char *)astrbuf = length;

  09ed9	88 15 00 00 00
	00		 mov	 BYTE PTR _astrbuf, dl

; 3681 :     return((u_char *)astrbuf);

  09edf	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  09ee4	5e		 pop	 esi

; 3682 : }

  09ee5	c3		 ret	 0
_tofstr	ENDP
_TEXT	ENDS
PUBLIC	_canonical
_TEXT	SEGMENT
_fstr$ = 8
_canonical PROC NEAR

; 3688 :     register u_char *str = fstr;
; 3689 :     register int length;
; 3690 :     register char c;
; 3691 : 
; 3692 :     if ( XV_CAPS ) {

  09ef0	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09ef5	56		 push	 esi
  09ef6	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  09ef9	85 c9		 test	 ecx, ecx
  09efb	74 2c		 je	 SHORT $L62737

; 3693 : 	for ( length = *str++; length--; str++) {

  09efd	8b 44 24 08	 mov	 eax, DWORD PTR _fstr$[esp]
  09f01	33 c9		 xor	 ecx, ecx
  09f03	8a 08		 mov	 cl, BYTE PTR [eax]
  09f05	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  09f08	8b f1		 mov	 esi, ecx
  09f0a	49		 dec	 ecx
  09f0b	85 f6		 test	 esi, esi
  09f0d	74 1e		 je	 SHORT $L60336
  09f0f	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$L60334:

; 3694 : 	    c = *str;

  09f12	8a 0a		 mov	 cl, BYTE PTR [edx]

; 3695 : 	    /* ASCII-dependent */
; 3696 : 	    if ( c >= 'A' && c <= 'Z' )

  09f14	80 f9 41	 cmp	 cl, 65			; 00000041H
  09f17	7c 0a		 jl	 SHORT $L60335
  09f19	80 f9 5a	 cmp	 cl, 90			; 0000005aH
  09f1c	7f 05		 jg	 SHORT $L60335

; 3697 : 		*str = c - 'A' + 'a';

  09f1e	80 c1 20	 add	 cl, 32			; 00000020H
  09f21	88 0a		 mov	 BYTE PTR [edx], cl
$L60335:
  09f23	42		 inc	 edx
  09f24	4e		 dec	 esi
  09f25	75 eb		 jne	 SHORT $L60334
  09f27	5e		 pop	 esi

; 3701 : }

  09f28	c3		 ret	 0
$L62737:

; 3698 : 	}
; 3699 :     }
; 3700 :     return( fstr );

  09f29	8b 44 24 08	 mov	 eax, DWORD PTR _fstr$[esp]
$L60336:
  09f2d	5e		 pop	 esi

; 3701 : }

  09f2e	c3		 ret	 0
_canonical ENDP
_TEXT	ENDS
PUBLIC	_strindex
_TEXT	SEGMENT
_adr1$ = 8
_len1$ = 12
_adr2$ = 16
_len2$ = 20
_n$ = -4
_strindex PROC NEAR

; 3714 : {

  09f30	51		 push	 ecx

; 3715 :     register int n;
; 3716 :     register u_char *p, *q;
; 3717 :     register int i;
; 3718 : 
; 3719 :     for (n = 0; len2 >= len1; adr2++, len2--, n++) {

  09f31	8b 44 24 14	 mov	 eax, DWORD PTR _len2$[esp]
  09f35	53		 push	 ebx
  09f36	55		 push	 ebp
  09f37	8b 6c 24 14	 mov	 ebp, DWORD PTR _len1$[esp+8]
  09f3b	56		 push	 esi
  09f3c	3b c5		 cmp	 eax, ebp
  09f3e	57		 push	 edi
  09f3f	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _n$[esp+20], 0
  09f47	7c 3c		 jl	 SHORT $L60350
  09f49	8b 4c 24 18	 mov	 ecx, DWORD PTR _adr1$[esp+16]
  09f4d	8b 54 24 20	 mov	 edx, DWORD PTR _adr2$[esp+16]
  09f51	eb 04		 jmp	 SHORT $L60348
$L62743:
  09f53	8b 4c 24 18	 mov	 ecx, DWORD PTR _adr1$[esp+16]
$L60348:

; 3720 : 	p = adr1;
; 3721 : 	q = adr2;
; 3722 : 	i = len1;
; 3723 : 	while(i-- > 0)
; 3724 : 	    if (*p++ != *q++)
; 3725 : 	        goto tryagain;
; 3726 : 	/* Found match */
; 3727 : 	return(n);

  09f57	8b f2		 mov	 esi, edx
  09f59	8b fd		 mov	 edi, ebp
  09f5b	2b f1		 sub	 esi, ecx
$L60352:
  09f5d	8b c7		 mov	 eax, edi
  09f5f	4f		 dec	 edi
  09f60	85 c0		 test	 eax, eax
  09f62	7e 2a		 jle	 SHORT $L60353
  09f64	8a 01		 mov	 al, BYTE PTR [ecx]
  09f66	8a 1c 0e	 mov	 bl, BYTE PTR [esi+ecx]
  09f69	41		 inc	 ecx
  09f6a	3a c3		 cmp	 al, bl
  09f6c	74 ef		 je	 SHORT $L60352
  09f6e	8b 44 24 24	 mov	 eax, DWORD PTR _len2$[esp+16]
  09f72	8b 74 24 10	 mov	 esi, DWORD PTR _n$[esp+20]
  09f76	42		 inc	 edx
  09f77	48		 dec	 eax
  09f78	46		 inc	 esi
  09f79	3b c5		 cmp	 eax, ebp
$tryagain$60355:
  09f7b	89 44 24 24	 mov	 DWORD PTR _len2$[esp+16], eax
  09f7f	89 74 24 10	 mov	 DWORD PTR _n$[esp+20], esi
  09f83	7d ce		 jge	 SHORT $L62743
$L60350:
  09f85	5f		 pop	 edi
  09f86	5e		 pop	 esi
  09f87	5d		 pop	 ebp

; 3728 : tryagain: ;
; 3729 :     }
; 3730 :     return(-1);

  09f88	83 c8 ff	 or	 eax, -1
  09f8b	5b		 pop	 ebx

; 3731 : }

  09f8c	59		 pop	 ecx
  09f8d	c3		 ret	 0
$L60353:

; 3720 : 	p = adr1;
; 3721 : 	q = adr2;
; 3722 : 	i = len1;
; 3723 : 	while(i-- > 0)
; 3724 : 	    if (*p++ != *q++)
; 3725 : 	        goto tryagain;
; 3726 : 	/* Found match */
; 3727 : 	return(n);

  09f8e	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+20]
  09f92	5f		 pop	 edi
  09f93	5e		 pop	 esi
  09f94	5d		 pop	 ebp
  09f95	5b		 pop	 ebx

; 3731 : }

  09f96	59		 pop	 ecx
  09f97	c3		 ret	 0
_strindex ENDP
_TEXT	ENDS
PUBLIC	_pluslevel
_TEXT	SEGMENT
_pluslevel PROC NEAR

; 3736 :     if (comp_level)

  09fa0	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  09fa5	85 c0		 test	 eax, eax
  09fa7	74 07		 je	 SHORT $L60357

; 3737 : 	++comp_level;

  09fa9	40		 inc	 eax
  09faa	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax

; 3743 :     }
; 3744 : }

  09faf	c3		 ret	 0
$L60357:

; 3738 :     else if (XV_STATE == 0) {

  09fb0	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09fb5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  09fb8	85 c9		 test	 ecx, ecx
  09fba	75 23		 jne	 SHORT $L60359

; 3739 : 	comp_level = 1;

  09fbc	b9 01 00 00 00	 mov	 ecx, 1
  09fc1	89 0d 00 00 00
	00		 mov	 DWORD PTR _comp_level, ecx

; 3740 : 	saved_dp = XDP;

  09fc7	8b 50 70	 mov	 edx, DWORD PTR [eax+112]
  09fca	89 15 00 00 00
	00		 mov	 DWORD PTR _saved_dp, edx

; 3741 :     	XV_DP = (cell) ((cell *)(comp_buffer));

  09fd0	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [eax+112], OFFSET FLAT:_comp_buffer

; 3742 : 	XV_STATE = (cell)COMPILING;

  09fd7	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  09fdc	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L60359:

; 3743 :     }
; 3744 : }

  09fdf	c3		 ret	 0
_pluslevel ENDP
_TEXT	ENDS
PUBLIC	_declevel
_TEXT	SEGMENT
_declevel PROC NEAR

; 3749 :     if (XV_STATE == 0)

  09fe0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09fe6	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  09fe9	85 c0		 test	 eax, eax
  09feb	75 13		 jne	 SHORT $L60365

; 3750 :         error("Conditionals not paired\n");

  09fed	68 00 00 00 00	 push	 OFFSET FLAT:$SG60366
  09ff2	e8 00 00 00 00	 call	 _error
  09ff7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  09ffd	83 c4 04	 add	 esp, 4
$L60365:

; 3751 :     if (comp_level) {

  0a000	a1 00 00 00 00	 mov	 eax, DWORD PTR _comp_level
  0a005	85 c0		 test	 eax, eax
  0a007	74 3d		 je	 SHORT $L60368

; 3752 :     	--comp_level;

  0a009	48		 dec	 eax
  0a00a	a3 00 00 00 00	 mov	 DWORD PTR _comp_level, eax

; 3753 : 	if (comp_level == 0) {	/* Dropped back to level 0 */

  0a00f	75 35		 jne	 SHORT $L60368

; 3754 : 	    xcompile(FINISHED);	/* compile(EXIT); */

  0a011	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0a014	50		 push	 eax
  0a015	6a 69		 push	 105			; 00000069H
  0a017	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0a01a	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  0a01d	e8 00 00 00 00	 call	 _tokstore

; 3755 : 	    XV_DP = (cell)saved_dp;

  0a022	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0a027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _saved_dp
  0a02d	83 c4 08	 add	 esp, 8
  0a030	89 48 70	 mov	 DWORD PTR [eax+112], ecx

; 3756 : 	    XV_STATE = (cell)INTERPRETING;

  0a033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup

; 3757 : 	    /* Return nonzero to cause execution of the temporary def'n? */
; 3758 : 	    return(1);

  0a039	b8 01 00 00 00	 mov	 eax, 1
  0a03e	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 3762 : }

  0a045	c3		 ret	 0
$L60368:

; 3759 : 	}
; 3760 :     }
; 3761 :     return(0);

  0a046	33 c0		 xor	 eax, eax

; 3762 : }

  0a048	c3		 ret	 0
_declevel ENDP
_TEXT	ENDS
PUBLIC	_substr
EXTRN	_strncpy:NEAR
_BSS	SEGMENT
_?outstr@?1??substr@@9@9 DB 080H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_str$ = 8
_pos$ = 12
_n$ = 16
_substr	PROC NEAR

; 3769 : 	register int len = strlen(str);

  0a050	8b 54 24 04	 mov	 edx, DWORD PTR _str$[esp-4]
  0a054	56		 push	 esi
  0a055	57		 push	 edi
  0a056	8b fa		 mov	 edi, edx
  0a058	83 c9 ff	 or	 ecx, -1
  0a05b	33 c0		 xor	 eax, eax
  0a05d	f2 ae		 repne scasb

; 3770 : 	static char outstr[128];
; 3771 : 
; 3772 : 	if( pos < 0 )

  0a05f	8b 44 24 10	 mov	 eax, DWORD PTR _pos$[esp+4]
  0a063	f7 d1		 not	 ecx
  0a065	49		 dec	 ecx
  0a066	85 c0		 test	 eax, eax
  0a068	7d 06		 jge	 SHORT $L62748

; 3773 : 		pos += len+1;

  0a06a	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 3774 : 	if( pos <= 0 )

  0a06e	85 c0		 test	 eax, eax
$L62748:
  0a070	7f 05		 jg	 SHORT $L60382

; 3775 : 		pos = 1;

  0a072	b8 01 00 00 00	 mov	 eax, 1
$L60382:

; 3776 : 	if (n < 0)

  0a077	8b 74 24 14	 mov	 esi, DWORD PTR _n$[esp+4]
  0a07b	85 f6		 test	 esi, esi
  0a07d	7d 02		 jge	 SHORT $L60383

; 3777 : 		n += len;

  0a07f	03 f1		 add	 esi, ecx
$L60383:

; 3778 : 	if (pos + n - 1 > len) {

  0a081	8d 7c 30 ff	 lea	 edi, DWORD PTR [eax+esi-1]
  0a085	3b f9		 cmp	 edi, ecx
  0a087	7e 09		 jle	 SHORT $L60385

; 3779 : 		n = len + 1  - pos;

  0a089	2b c8		 sub	 ecx, eax
  0a08b	41		 inc	 ecx
  0a08c	8b f1		 mov	 esi, ecx

; 3780 : 		if (n < 0)

  0a08e	79 02		 jns	 SHORT $L60385

; 3781 : 		    n = 0;

  0a090	33 f6		 xor	 esi, esi
$L60385:

; 3782 : 	}
; 3783 : 	(void)strncpy(outstr, str + pos - 1, n);

  0a092	8d 44 02 ff	 lea	 eax, DWORD PTR [edx+eax-1]
  0a096	56		 push	 esi
  0a097	50		 push	 eax
  0a098	68 00 00 00 00	 push	 OFFSET FLAT:_?outstr@?1??substr@@9@9
  0a09d	e8 00 00 00 00	 call	 _strncpy
  0a0a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3784 : 	outstr[n] = '\0';

  0a0a5	c6 86 00 00 00
	00 00		 mov	 BYTE PTR _?outstr@?1??substr@@9@9[esi], 0

; 3785 : 
; 3786 : 	return(outstr);

  0a0ac	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_?outstr@?1??substr@@9@9
  0a0b1	5f		 pop	 edi
  0a0b2	5e		 pop	 esi

; 3787 : }

  0a0b3	c3		 ret	 0
_substr	ENDP
_token$ = 8
_adr$ = 12
_tokstore PROC NEAR

; 3793 : {

  0a0c0	53		 push	 ebx

; 3794 : 	u_char *p;
; 3795 : 
; 3796 : 	if ( XV_MOD_COMP ) {

  0a0c1	8b 4c 24 08	 mov	 ecx, DWORD PTR _token$[esp]
  0a0c5	56		 push	 esi
  0a0c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _xup
  0a0cc	57		 push	 edi
  0a0cd	8b 7c 24 14	 mov	 edi, DWORD PTR _adr$[esp+8]
  0a0d1	8b 96 88 00 00
	00		 mov	 edx, DWORD PTR [esi+136]
  0a0d7	85 d2		 test	 edx, edx
  0a0d9	0f 84 b4 01 00
	00		 je	 $L60411

; 3797 : 		if (token >= MAXCF) {

  0a0df	81 f9 98 01 00
	00		 cmp	 ecx, 408		; 00000198H
  0a0e5	0f 82 21 02 00
	00		 jb	 $L62799

; 3798 : 			if ( (unsigned long)token < (unsigned long)ThisModule || (void *)token >= 
; 3799 : 										(void *)((cell)ThisModule->ModuleDict + 
; 3800 : 												ThisModule->RelTableOffset) ) {

  0a0eb	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0a0ee	3b c8		 cmp	 ecx, eax
  0a0f0	72 0f		 jb	 SHORT $L60403
  0a0f2	8b 58 1c	 mov	 ebx, DWORD PTR [eax+28]
  0a0f5	8d 5c 03 40	 lea	 ebx, DWORD PTR [ebx+eax+64]
  0a0f9	3b cb		 cmp	 ecx, ebx
  0a0fb	0f 82 92 01 00
	00		 jb	 $L60411
$L60403:

; 3801 : 				if ( (u_cell)token < (u_cell)(ThisModule->CompilationLibOrigin) ||
; 3802 : 						(u_cell)token >= 
; 3803 : 							(u_cell)((module *)ThisModule->CompilationLibOrigin)->ModuleDP ) {

  0a101	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0a104	3b c8		 cmp	 ecx, eax
  0a106	72 09		 jb	 SHORT $L60414
  0a108	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0a10b	0f 82 82 01 00
	00		 jb	 $L60411
$L60414:

; 3804 : 					p = (u_char *)token;
; 3805 : 					do {
; 3806 : 						p--;
; 3807 : 					} while (*p == '\0' || *p > ' ') ;

  0a111	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  0a114	49		 dec	 ecx
  0a115	84 c0		 test	 al, al
  0a117	74 f8		 je	 SHORT $L60414
  0a119	3c 20		 cmp	 al, 32			; 00000020H
  0a11b	77 f4		 ja	 SHORT $L60414

; 3808 : 					sprintf(errMsg, "%s ?", tocstr(p));

  0a11d	33 d2		 xor	 edx, edx
  0a11f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  0a124	8a 11		 mov	 dl, BYTE PTR [ecx]
  0a126	41		 inc	 ecx
  0a127	8b f2		 mov	 esi, edx
  0a129	4a		 dec	 edx
  0a12a	85 f6		 test	 esi, esi
  0a12c	74 0e		 je	 SHORT $L62756
  0a12e	2b c8		 sub	 ecx, eax
  0a130	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
$L62755:
  0a133	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0a136	88 10		 mov	 BYTE PTR [eax], dl
  0a138	40		 inc	 eax
  0a139	4e		 dec	 esi
  0a13a	75 f7		 jne	 SHORT $L62755
$L62756:
  0a13c	55		 push	 ebp
  0a13d	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  0a142	68 00 00 00 00	 push	 OFFSET FLAT:$SG60417
  0a147	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  0a14c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0a14f	e8 00 00 00 00	 call	 _sprintf

; 3809 : 					if( input_name[0] != '\0' ) {

  0a154	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _input_name
  0a15a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0a15d	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  0a161	0f 84 f6 00 00
	00		 je	 $L60418

; 3810 : 						strcat(errMsg, "   Last: ");

  0a167	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0a16c	83 c9 ff	 or	 ecx, -1
  0a16f	33 c0		 xor	 eax, eax
  0a171	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60419+8
  0a178	f2 ae		 repne scasb
  0a17a	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60419
  0a17f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60419+4
  0a185	4f		 dec	 edi
  0a186	89 07		 mov	 DWORD PTR [edi], eax

; 3811 : 						strcat(errMsg, tocstr(&((XV_LAST) -> name)));

  0a188	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0a18d	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0a190	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a195	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  0a199	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0a19c	83 c0 05	 add	 eax, 5
  0a19f	33 d2		 xor	 edx, edx
  0a1a1	8a 10		 mov	 dl, BYTE PTR [eax]
  0a1a3	40		 inc	 eax
  0a1a4	8b f2		 mov	 esi, edx
  0a1a6	4a		 dec	 edx
  0a1a7	85 f6		 test	 esi, esi
  0a1a9	74 0c		 je	 SHORT $L62764

; 3810 : 						strcat(errMsg, "   Last: ");

  0a1ab	8d 72 01	 lea	 esi, DWORD PTR [edx+1]

; 3811 : 						strcat(errMsg, tocstr(&((XV_LAST) -> name)));

$L62763:
  0a1ae	8a 10		 mov	 dl, BYTE PTR [eax]
  0a1b0	88 11		 mov	 BYTE PTR [ecx], dl
  0a1b2	41		 inc	 ecx
  0a1b3	40		 inc	 eax
  0a1b4	4e		 dec	 esi
  0a1b5	75 f7		 jne	 SHORT $L62763
$L62764:
  0a1b7	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a1ba	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  0a1bf	83 c9 ff	 or	 ecx, -1
  0a1c2	33 c0		 xor	 eax, eax
  0a1c4	f2 ae		 repne scasb
  0a1c6	f7 d1		 not	 ecx
  0a1c8	2b f9		 sub	 edi, ecx
  0a1ca	8b f7		 mov	 esi, edi
  0a1cc	8b d1		 mov	 edx, ecx
  0a1ce	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0a1d3	83 c9 ff	 or	 ecx, -1
  0a1d6	f2 ae		 repne scasb
  0a1d8	8b ca		 mov	 ecx, edx
  0a1da	4f		 dec	 edi
  0a1db	c1 e9 02	 shr	 ecx, 2
  0a1de	f3 a5		 rep movsd
  0a1e0	8b ca		 mov	 ecx, edx

; 3812 : 						strcat(errMsg, "   File: ");

  0a1e2	66 8b 15 08 00
	00 00		 mov	 dx, WORD PTR $SG60421+8
  0a1e9	83 e1 03	 and	 ecx, 3
  0a1ec	f3 a4		 rep movsb
  0a1ee	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0a1f3	83 c9 ff	 or	 ecx, -1
  0a1f6	f2 ae		 repne scasb
  0a1f8	a1 00 00 00 00	 mov	 eax, DWORD PTR $SG60421
  0a1fd	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR $SG60421+4
  0a203	4f		 dec	 edi
  0a204	89 07		 mov	 DWORD PTR [edi], eax

; 3813 : 						strcat(errMsg, tocstr(input_name) );

  0a206	8b c5		 mov	 eax, ebp
  0a208	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0a20b	33 c9		 xor	 ecx, ecx
  0a20d	40		 inc	 eax
  0a20e	66 89 57 08	 mov	 WORD PTR [edi+8], dx
  0a212	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]
  0a215	8b f1		 mov	 esi, ecx
  0a217	49		 dec	 ecx
  0a218	85 f6		 test	 esi, esi
  0a21a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf
  0a21f	74 0c		 je	 SHORT $L62772

; 3811 : 						strcat(errMsg, tocstr(&((XV_LAST) -> name)));

  0a221	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]

; 3813 : 						strcat(errMsg, tocstr(input_name) );

$L62771:
  0a224	8a 08		 mov	 cl, BYTE PTR [eax]
  0a226	88 0a		 mov	 BYTE PTR [edx], cl
  0a228	42		 inc	 edx
  0a229	40		 inc	 eax
  0a22a	4e		 dec	 esi
  0a22b	75 f7		 jne	 SHORT $L62771
$L62772:
  0a22d	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_astrbuf
  0a232	83 c9 ff	 or	 ecx, -1
  0a235	33 c0		 xor	 eax, eax
  0a237	c6 02 00	 mov	 BYTE PTR [edx], 0
  0a23a	f2 ae		 repne scasb
  0a23c	f7 d1		 not	 ecx
  0a23e	2b f9		 sub	 edi, ecx
  0a240	8b f7		 mov	 esi, edi
  0a242	8b d1		 mov	 edx, ecx
  0a244	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0a249	83 c9 ff	 or	 ecx, -1
  0a24c	f2 ae		 repne scasb
  0a24e	8b ca		 mov	 ecx, edx
  0a250	4f		 dec	 edi
  0a251	c1 e9 02	 shr	 ecx, 2
  0a254	f3 a5		 rep movsd
  0a256	8b ca		 mov	 ecx, edx
  0a258	83 e1 03	 and	 ecx, 3
  0a25b	f3 a4		 rep movsb
$L60418:

; 3814 : 					}
; 3815 : 					strcat(errMsg, "\nWarning: reference outside the module and std library.\n");

  0a25d	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:_errMsg
  0a262	83 c9 ff	 or	 ecx, -1
  0a265	33 c0		 xor	 eax, eax
  0a267	be 00 00 00 00	 mov	 esi, OFFSET FLAT:$SG60422
  0a26c	f2 ae		 repne scasb
  0a26e	4f		 dec	 edi
  0a26f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0a274	f3 a5		 rep movsd

; 3816 : 					error(errMsg);

  0a276	68 00 00 00 00	 push	 OFFSET FLAT:_errMsg
  0a27b	a4		 movsb
  0a27c	e8 00 00 00 00	 call	 _error

; 3817 : 					*adr = (cell) LOSE;

  0a281	8b 44 24 1c	 mov	 eax, DWORD PTR _adr$[esp+16]
  0a285	83 c4 04	 add	 esp, 4
  0a288	5d		 pop	 ebp
  0a289	5f		 pop	 edi
  0a28a	5e		 pop	 esi
  0a28b	c7 00 78 00 00
	00		 mov	 DWORD PTR [eax], 120	; 00000078H
  0a291	5b		 pop	 ebx

; 3828 : }

  0a292	c3		 ret	 0
$L60411:

; 3818 : 					return;
; 3819 : 
; 3820 : 				}
; 3821 : 			}
; 3822 : 		}
; 3823 : 	}
; 3824 : 	if ( (token >= MAXCF) ) {

  0a293	81 f9 98 01 00
	00		 cmp	 ecx, 408		; 00000198H
  0a299	72 71		 jb	 SHORT $L62799

; 3825 : 		set_relocation_bit(adr);

  0a29b	85 d2		 test	 edx, edx
  0a29d	74 19		 je	 SHORT $L62788
  0a29f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0a2a2	8b d7		 mov	 edx, edi
  0a2a4	2b d0		 sub	 edx, eax

; 3826 : 	}
; 3827 : 	*adr = (cell)token;			/* Store it! (finally)	*/

  0a2a6	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  0a2a9	c1 fa 02	 sar	 edx, 2
  0a2ac	03 d6		 add	 edx, esi
  0a2ae	c6 04 02 03	 mov	 BYTE PTR [edx+eax], 3
  0a2b2	89 0f		 mov	 DWORD PTR [edi], ecx
  0a2b4	5f		 pop	 edi
  0a2b5	5e		 pop	 esi
  0a2b6	5b		 pop	 ebx

; 3828 : }

  0a2b7	c3		 ret	 0

; 3825 : 		set_relocation_bit(adr);

$L62788:
  0a2b8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _origin
  0a2be	8b c7		 mov	 eax, edi
  0a2c0	2b c6		 sub	 eax, esi
  0a2c2	c1 f8 02	 sar	 eax, 2
  0a2c5	78 15		 js	 SHORT $L62798
  0a2c7	3b 3d 70 00 00
	00		 cmp	 edi, DWORD PTR _main_task+112
  0a2cd	77 0d		 ja	 SHORT $L62798
  0a2cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _relmap
  0a2d5	8b d0		 mov	 edx, eax
  0a2d7	c1 fa 03	 sar	 edx, 3
  0a2da	eb 1e		 jmp	 SHORT $L62808
$L62798:
  0a2dc	8b c7		 mov	 eax, edi
  0a2de	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:_main_task
  0a2e3	c1 f8 02	 sar	 eax, 2
  0a2e6	78 24		 js	 SHORT $L62799
  0a2e8	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0a2ed	73 1d		 jae	 SHORT $L62799
  0a2ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _urelmap
  0a2f5	8b d0		 mov	 edx, eax
  0a2f7	c1 fa 03	 sar	 edx, 3
$L62808:
  0a2fa	8a 1c 32	 mov	 bl, BYTE PTR [edx+esi]
  0a2fd	03 d6		 add	 edx, esi
  0a2ff	83 e0 07	 and	 eax, 7
  0a302	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _bit[eax]
  0a308	0a d8		 or	 bl, al
  0a30a	88 1a		 mov	 BYTE PTR [edx], bl
$L62799:

; 3826 : 	}
; 3827 : 	*adr = (cell)token;			/* Store it! (finally)	*/

  0a30c	89 0f		 mov	 DWORD PTR [edi], ecx
  0a30e	5f		 pop	 edi
  0a30f	5e		 pop	 esi
  0a310	5b		 pop	 ebx

; 3828 : }

  0a311	c3		 ret	 0
_tokstore ENDP
_TEXT	ENDS
PUBLIC	_set_relocation_bit
_TEXT	SEGMENT
_adr$ = 8
_set_relocation_bit PROC NEAR

; 3834 : 	if (XV_MOD_COMP) {

  0a320	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0a325	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0a32b	85 c9		 test	 ecx, ecx
  0a32d	74 16		 je	 SHORT $L60429

; 3835 : 		module_set_relocation_bit(adr);

  0a32f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0a332	8b 4c 24 04	 mov	 ecx, DWORD PTR _adr$[esp-4]
  0a336	2b c8		 sub	 ecx, eax

; 3836 : #ifdef RELOCATE
; 3837 : 	} else {
; 3838 : 		main_set_relocation_bit(adr);

  0a338	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0a33b	c1 f9 02	 sar	 ecx, 2
  0a33e	03 ca		 add	 ecx, edx
  0a340	c6 04 01 03	 mov	 BYTE PTR [ecx+eax], 3

; 3839 : #endif
; 3840 : 	}
; 3841 : }

  0a344	c3		 ret	 0
$L60429:

; 3836 : #ifdef RELOCATE
; 3837 : 	} else {
; 3838 : 		main_set_relocation_bit(adr);

  0a345	8b 4c 24 04	 mov	 ecx, DWORD PTR _adr$[esp-4]
  0a349	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _origin
  0a34f	8b c1		 mov	 eax, ecx
  0a351	2b c2		 sub	 eax, edx
  0a353	c1 f8 02	 sar	 eax, 2
  0a356	78 25		 js	 SHORT $L62819
  0a358	3b 0d 70 00 00
	00		 cmp	 ecx, DWORD PTR _main_task+112
  0a35e	77 1d		 ja	 SHORT $L62819
  0a360	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _relmap
  0a366	8b d0		 mov	 edx, eax
  0a368	c1 fa 03	 sar	 edx, 3
  0a36b	83 e0 07	 and	 eax, 7
  0a36e	03 ca		 add	 ecx, edx
  0a370	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR _bit[eax]
  0a376	8a 01		 mov	 al, BYTE PTR [ecx]
  0a378	0a c2		 or	 al, dl
  0a37a	88 01		 mov	 BYTE PTR [ecx], al

; 3839 : #endif
; 3840 : 	}
; 3841 : }

  0a37c	c3		 ret	 0

; 3836 : #ifdef RELOCATE
; 3837 : 	} else {
; 3838 : 		main_set_relocation_bit(adr);

$L62819:
  0a37d	81 e9 00 00 00
	00		 sub	 ecx, OFFSET FLAT:_main_task
  0a383	c1 f9 02	 sar	 ecx, 2
  0a386	8b c1		 mov	 eax, ecx
  0a388	78 1d		 js	 SHORT $L62820
  0a38a	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0a38f	73 16		 jae	 SHORT $L62820
  0a391	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _urelmap
  0a397	83 e0 07	 and	 eax, 7
  0a39a	c1 f9 03	 sar	 ecx, 3
  0a39d	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _bit[eax]
  0a3a3	03 ca		 add	 ecx, edx
  0a3a5	08 01		 or	 BYTE PTR [ecx], al
$L62820:

; 3839 : #endif
; 3840 : 	}
; 3841 : }

  0a3a7	c3		 ret	 0
_set_relocation_bit ENDP
_TEXT	ENDS
PUBLIC	_main_set_relocation_bit
_TEXT	SEGMENT
_adr$ = 8
_main_set_relocation_bit PROC NEAR

; 3853 : 	cell offset;
; 3854 : 
; 3855 : 	offset = (cell)(adr - origin);

  0a3b0	8b 4c 24 04	 mov	 ecx, DWORD PTR _adr$[esp-4]
  0a3b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _origin
  0a3ba	8b c1		 mov	 eax, ecx
  0a3bc	2b c2		 sub	 eax, edx
  0a3be	c1 f8 02	 sar	 eax, 2

; 3856 : #ifdef REMOVE
; 3857 : 	if ((offset >= 0)  &&  (adr <= XDP)) {
; 3858 : #else
; 3859 : 	if ((offset >= 0) && (adr <= MAIN_DP)) {

  0a3c1	78 25		 js	 SHORT $L60437
  0a3c3	3b 0d 70 00 00
	00		 cmp	 ecx, DWORD PTR _main_task+112
  0a3c9	77 1d		 ja	 SHORT $L60437

; 3860 : #endif
; 3861 : 		relmap[offset>>3] |= bit[offset&7];

  0a3cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _relmap
  0a3d1	8b c8		 mov	 ecx, eax
  0a3d3	c1 f9 03	 sar	 ecx, 3

; 3871 : 		urelmap[offset>>3] |= bit[offset&7];

  0a3d6	03 ca		 add	 ecx, edx
  0a3d8	83 e0 07	 and	 eax, 7
  0a3db	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _bit[eax]
  0a3e1	8a 11		 mov	 dl, BYTE PTR [ecx]
  0a3e3	0a d0		 or	 dl, al
  0a3e5	88 11		 mov	 BYTE PTR [ecx], dl

; 3872 : 		return;
; 3873 : 	}
; 3874 : }

  0a3e7	c3		 ret	 0
$L60437:

; 3862 : 		return;
; 3863 : 	}
; 3864 : #ifdef REMOVE
; 3865 : 	offset = (cell)(adr - xup);
; 3866 : #else
; 3867 : 	offset = (cell)(adr - (cell *)main_task);

  0a3e8	81 e9 00 00 00
	00		 sub	 ecx, OFFSET FLAT:_main_task
  0a3ee	c1 f9 02	 sar	 ecx, 2
  0a3f1	8b c1		 mov	 eax, ecx

; 3868 : #endif
; 3869 : 
; 3870 : 	if ((offset >= 0)  &&  (offset < MAXUSER)) {

  0a3f3	78 1d		 js	 SHORT $L60441
  0a3f5	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0a3fa	73 16		 jae	 SHORT $L60441

; 3871 : 		urelmap[offset>>3] |= bit[offset&7];

  0a3fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _urelmap
  0a402	83 e0 07	 and	 eax, 7
  0a405	c1 f9 03	 sar	 ecx, 3
  0a408	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _bit[eax]
  0a40e	03 ca		 add	 ecx, edx
  0a410	08 01		 or	 BYTE PTR [ecx], al
$L60441:

; 3872 : 		return;
; 3873 : 	}
; 3874 : }

  0a412	c3		 ret	 0
_main_set_relocation_bit ENDP
_TEXT	ENDS
PUBLIC	_module_set_relocation_bit
_TEXT	SEGMENT
_adr$ = 8
_module_set_relocation_bit PROC NEAR

; 3916 : 	module *mp;			/* Pointer to the module		    */
; 3917 : 	char *reltable;		/* Pointer to the module's relocation table */
; 3918 : 	cell offset;		/* Cell offset of adr from start of module  */
; 3919 : 
; 3920 : 	mp = ThisModule;

  0a420	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup

; 3921 : 	reltable = (char *)mp + mp->RelTableOffset;
; 3922 : 	offset = (cell)(adr - (cell *)mp);

  0a425	8b 4c 24 04	 mov	 ecx, DWORD PTR _adr$[esp-4]
  0a429	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0a42c	2b c8		 sub	 ecx, eax

; 3923 : 	// reltable[offset] |= 1;
; 3924 : 	reltable[offset] = 3;

  0a42e	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0a431	c1 f9 02	 sar	 ecx, 2
  0a434	03 ca		 add	 ecx, edx
  0a436	c6 04 01 03	 mov	 BYTE PTR [ecx+eax], 3

; 3925 : }

  0a43a	c3		 ret	 0
_module_set_relocation_bit ENDP
_TEXT	ENDS
EXTRN	_ccalls:BYTE
_TEXT	SEGMENT
_callno$ = 8
_format$ = 12
_spp$ = 16
_arg0$ = -4
_arg1$ = -8
_arg2$ = 16
_arg3$ = -12
_arg4$ = -16
_arg5$ = -20
_arg6$ = -24
_arg7$ = -28
_arg8$ = -32
_arg9$ = -36
_arg10$ = -40
_arg11$ = 12
_doccall PROC NEAR

; 3935 :     register cell *sp = *spp;

  0a440	8b 44 24 0c	 mov	 eax, DWORD PTR _spp$[esp-4]
  0a444	83 ec 28	 sub	 esp, 40			; 00000028H
  0a447	53		 push	 ebx
  0a448	55		 push	 ebp

; 3936 :     cell arg0, arg1, arg2, arg3, arg4,  arg5,
; 3937 :            arg6, arg7, arg8, arg9, arg10, arg11;
; 3938 :     cell ret;
; 3939 : 
; 3940 :     extern char *tocstr();
; 3941 :     extern u_char *tofstr();
; 3942 :     extern cell (*ccalls[])();
; 3943 : 
; 3944 : /* The following cases are ordered by expected frequency of occurrence */
; 3945 : #define CONVERT(var) switch(*format++) { case 'i': var = *sp++; break; case '-': goto doccall; case 's': var = (cell) tocstr((u_char *)*sp++); break; case 'a': var = *sp++; break; case 'l': var = *sp++; break; }
; 3946 : 
; 3947 :     CONVERT(arg0);

  0a449	8b 6c 24 38	 mov	 ebp, DWORD PTR _format$[esp+44]
  0a44d	56		 push	 esi
  0a44e	8b 30		 mov	 esi, DWORD PTR [eax]
  0a450	33 c0		 xor	 eax, eax
  0a452	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a455	45		 inc	 ebp
  0a456	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a459	57		 push	 edi
  0a45a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a45d	77 57		 ja	 SHORT $L60475
  0a45f	33 c9		 xor	 ecx, ecx
  0a461	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L62994[eax]
  0a467	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L62995[ecx*4]
$L60478:
  0a46e	8b 16		 mov	 edx, DWORD PTR [esi]
  0a470	89 54 24 34	 mov	 DWORD PTR _arg0$[esp+56], edx
  0a474	eb 3d		 jmp	 SHORT $L62983
$L60481:
  0a476	8b 06		 mov	 eax, DWORD PTR [esi]
  0a478	33 d2		 xor	 edx, edx
  0a47a	83 c6 04	 add	 esi, 4
  0a47d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a482	8a 10		 mov	 dl, BYTE PTR [eax]
  0a484	40		 inc	 eax
  0a485	8b fa		 mov	 edi, edx
  0a487	4a		 dec	 edx
  0a488	85 ff		 test	 edi, edi
  0a48a	74 0c		 je	 SHORT $L62832
  0a48c	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62831:
  0a48f	8a 10		 mov	 dl, BYTE PTR [eax]
  0a491	88 11		 mov	 BYTE PTR [ecx], dl
  0a493	41		 inc	 ecx
  0a494	40		 inc	 eax
  0a495	4f		 dec	 edi
  0a496	75 f7		 jne	 SHORT $L62831
$L62832:
  0a498	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a49b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _arg0$[esp+56], OFFSET FLAT:_astrbuf
  0a4a3	eb 11		 jmp	 SHORT $L60475
$L60484:
  0a4a5	8b 06		 mov	 eax, DWORD PTR [esi]
  0a4a7	89 44 24 34	 mov	 DWORD PTR _arg0$[esp+56], eax
  0a4ab	eb 06		 jmp	 SHORT $L62983
$L60485:
  0a4ad	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a4af	89 4c 24 34	 mov	 DWORD PTR _arg0$[esp+56], ecx
$L62983:
  0a4b3	83 c6 04	 add	 esi, 4
$L60475:

; 3948 :     CONVERT(arg1);

  0a4b6	33 c0		 xor	 eax, eax
  0a4b8	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a4bb	45		 inc	 ebp
  0a4bc	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a4bf	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a4c2	77 4f		 ja	 SHORT $L60487
  0a4c4	33 d2		 xor	 edx, edx
  0a4c6	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L62996[eax]
  0a4cc	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L62997[edx*4]
$L60495:
  0a4d3	8b 06		 mov	 eax, DWORD PTR [esi]
  0a4d5	89 44 24 30	 mov	 DWORD PTR _arg1$[esp+56], eax
  0a4d9	eb 35		 jmp	 SHORT $L62984
$L60492:
  0a4db	8b 06		 mov	 eax, DWORD PTR [esi]
  0a4dd	33 d2		 xor	 edx, edx
  0a4df	83 c6 04	 add	 esi, 4
  0a4e2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a4e7	8a 10		 mov	 dl, BYTE PTR [eax]
  0a4e9	40		 inc	 eax
  0a4ea	8b fa		 mov	 edi, edx
  0a4ec	4a		 dec	 edx
  0a4ed	85 ff		 test	 edi, edi
  0a4ef	74 0c		 je	 SHORT $L62840
  0a4f1	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62839:
  0a4f4	8a 10		 mov	 dl, BYTE PTR [eax]
  0a4f6	88 11		 mov	 BYTE PTR [ecx], dl
  0a4f8	41		 inc	 ecx
  0a4f9	40		 inc	 eax
  0a4fa	4f		 dec	 edi
  0a4fb	75 f7		 jne	 SHORT $L62839
$L62840:
  0a4fd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a500	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _arg1$[esp+56], OFFSET FLAT:_astrbuf
  0a508	eb 09		 jmp	 SHORT $L60487
$L60496:
  0a50a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a50c	89 4c 24 30	 mov	 DWORD PTR _arg1$[esp+56], ecx
$L62984:
  0a510	83 c6 04	 add	 esi, 4
$L60487:

; 3949 :     CONVERT(arg2);

  0a513	33 c0		 xor	 eax, eax
  0a515	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a518	45		 inc	 ebp
  0a519	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a51c	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a51f	77 42		 ja	 SHORT $L62961
  0a521	33 d2		 xor	 edx, edx
  0a523	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L62998[eax]
  0a529	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L62999[edx*4]
$L60507:
  0a530	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0a532	83 c6 04	 add	 esi, 4
  0a535	eb 30		 jmp	 SHORT $L60498
$L60503:
  0a537	8b 06		 mov	 eax, DWORD PTR [esi]
  0a539	33 d2		 xor	 edx, edx
  0a53b	83 c6 04	 add	 esi, 4
  0a53e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a543	8a 10		 mov	 dl, BYTE PTR [eax]
  0a545	40		 inc	 eax
  0a546	8b fa		 mov	 edi, edx
  0a548	4a		 dec	 edx
  0a549	85 ff		 test	 edi, edi
  0a54b	74 0c		 je	 SHORT $L62848
  0a54d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62847:
  0a550	8a 10		 mov	 dl, BYTE PTR [eax]
  0a552	88 11		 mov	 BYTE PTR [ecx], dl
  0a554	41		 inc	 ecx
  0a555	40		 inc	 eax
  0a556	4f		 dec	 edi
  0a557	75 f7		 jne	 SHORT $L62847
$L62848:
  0a559	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a55c	bb 00 00 00 00	 mov	 ebx, OFFSET FLAT:_astrbuf
  0a561	eb 04		 jmp	 SHORT $L60498
$L62961:
  0a563	8b 5c 24 44	 mov	 ebx, DWORD PTR _arg2$[esp+52]
$L60498:

; 3950 :     CONVERT(arg3);

  0a567	33 c0		 xor	 eax, eax
  0a569	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a56c	45		 inc	 ebp
  0a56d	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a570	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a573	77 57		 ja	 SHORT $L60509
  0a575	33 c9		 xor	 ecx, ecx
  0a577	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR $L63000[eax]
  0a57d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L63001[ecx*4]
$L60512:
  0a584	8b 16		 mov	 edx, DWORD PTR [esi]
  0a586	89 54 24 2c	 mov	 DWORD PTR _arg3$[esp+56], edx
  0a58a	eb 3d		 jmp	 SHORT $L62985
$L60514:
  0a58c	8b 06		 mov	 eax, DWORD PTR [esi]
  0a58e	33 d2		 xor	 edx, edx
  0a590	83 c6 04	 add	 esi, 4
  0a593	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a598	8a 10		 mov	 dl, BYTE PTR [eax]
  0a59a	40		 inc	 eax
  0a59b	8b fa		 mov	 edi, edx
  0a59d	4a		 dec	 edx
  0a59e	85 ff		 test	 edi, edi
  0a5a0	74 0c		 je	 SHORT $L62856
  0a5a2	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62855:
  0a5a5	8a 10		 mov	 dl, BYTE PTR [eax]
  0a5a7	88 11		 mov	 BYTE PTR [ecx], dl
  0a5a9	41		 inc	 ecx
  0a5aa	40		 inc	 eax
  0a5ab	4f		 dec	 edi
  0a5ac	75 f7		 jne	 SHORT $L62855
$L62856:
  0a5ae	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a5b1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _arg3$[esp+56], OFFSET FLAT:_astrbuf
  0a5b9	eb 11		 jmp	 SHORT $L60509
$L60517:
  0a5bb	8b 06		 mov	 eax, DWORD PTR [esi]
  0a5bd	89 44 24 2c	 mov	 DWORD PTR _arg3$[esp+56], eax
  0a5c1	eb 06		 jmp	 SHORT $L62985
$L60518:
  0a5c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a5c5	89 4c 24 2c	 mov	 DWORD PTR _arg3$[esp+56], ecx
$L62985:
  0a5c9	83 c6 04	 add	 esi, 4
$L60509:

; 3951 :     CONVERT(arg4);

  0a5cc	33 c0		 xor	 eax, eax
  0a5ce	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a5d1	45		 inc	 ebp
  0a5d2	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a5d5	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a5d8	77 4f		 ja	 SHORT $L60520
  0a5da	33 d2		 xor	 edx, edx
  0a5dc	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63002[eax]
  0a5e2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63003[edx*4]
$L60528:
  0a5e9	8b 06		 mov	 eax, DWORD PTR [esi]
  0a5eb	89 44 24 28	 mov	 DWORD PTR _arg4$[esp+56], eax
  0a5ef	eb 35		 jmp	 SHORT $L62986
$L60525:
  0a5f1	8b 06		 mov	 eax, DWORD PTR [esi]
  0a5f3	33 d2		 xor	 edx, edx
  0a5f5	83 c6 04	 add	 esi, 4
  0a5f8	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a5fd	8a 10		 mov	 dl, BYTE PTR [eax]
  0a5ff	40		 inc	 eax
  0a600	8b fa		 mov	 edi, edx
  0a602	4a		 dec	 edx
  0a603	85 ff		 test	 edi, edi
  0a605	74 0c		 je	 SHORT $L62864
  0a607	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62863:
  0a60a	8a 10		 mov	 dl, BYTE PTR [eax]
  0a60c	88 11		 mov	 BYTE PTR [ecx], dl
  0a60e	41		 inc	 ecx
  0a60f	40		 inc	 eax
  0a610	4f		 dec	 edi
  0a611	75 f7		 jne	 SHORT $L62863
$L62864:
  0a613	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a616	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _arg4$[esp+56], OFFSET FLAT:_astrbuf
  0a61e	eb 09		 jmp	 SHORT $L60520
$L60529:
  0a620	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a622	89 4c 24 28	 mov	 DWORD PTR _arg4$[esp+56], ecx
$L62986:
  0a626	83 c6 04	 add	 esi, 4
$L60520:

; 3952 :     CONVERT(arg5);

  0a629	33 c0		 xor	 eax, eax
  0a62b	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a62e	45		 inc	 ebp
  0a62f	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a632	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a635	77 4f		 ja	 SHORT $L60531
  0a637	33 d2		 xor	 edx, edx
  0a639	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63004[eax]
  0a63f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63005[edx*4]
$L60539:
  0a646	8b 06		 mov	 eax, DWORD PTR [esi]
  0a648	89 44 24 24	 mov	 DWORD PTR _arg5$[esp+56], eax
  0a64c	eb 35		 jmp	 SHORT $L62987
$L60536:
  0a64e	8b 06		 mov	 eax, DWORD PTR [esi]
  0a650	33 d2		 xor	 edx, edx
  0a652	83 c6 04	 add	 esi, 4
  0a655	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a65a	8a 10		 mov	 dl, BYTE PTR [eax]
  0a65c	40		 inc	 eax
  0a65d	8b fa		 mov	 edi, edx
  0a65f	4a		 dec	 edx
  0a660	85 ff		 test	 edi, edi
  0a662	74 0c		 je	 SHORT $L62872
  0a664	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62871:
  0a667	8a 10		 mov	 dl, BYTE PTR [eax]
  0a669	88 11		 mov	 BYTE PTR [ecx], dl
  0a66b	41		 inc	 ecx
  0a66c	40		 inc	 eax
  0a66d	4f		 dec	 edi
  0a66e	75 f7		 jne	 SHORT $L62871
$L62872:
  0a670	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a673	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _arg5$[esp+56], OFFSET FLAT:_astrbuf
  0a67b	eb 09		 jmp	 SHORT $L60531
$L60540:
  0a67d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a67f	89 4c 24 24	 mov	 DWORD PTR _arg5$[esp+56], ecx
$L62987:
  0a683	83 c6 04	 add	 esi, 4
$L60531:

; 3953 :     CONVERT(arg6);

  0a686	33 c0		 xor	 eax, eax
  0a688	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a68b	45		 inc	 ebp
  0a68c	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a68f	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a692	77 4f		 ja	 SHORT $L60542
  0a694	33 d2		 xor	 edx, edx
  0a696	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63006[eax]
  0a69c	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63007[edx*4]
$L60550:
  0a6a3	8b 06		 mov	 eax, DWORD PTR [esi]
  0a6a5	89 44 24 20	 mov	 DWORD PTR _arg6$[esp+56], eax
  0a6a9	eb 35		 jmp	 SHORT $L62988
$L60547:
  0a6ab	8b 06		 mov	 eax, DWORD PTR [esi]
  0a6ad	33 d2		 xor	 edx, edx
  0a6af	83 c6 04	 add	 esi, 4
  0a6b2	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a6b7	8a 10		 mov	 dl, BYTE PTR [eax]
  0a6b9	40		 inc	 eax
  0a6ba	8b fa		 mov	 edi, edx
  0a6bc	4a		 dec	 edx
  0a6bd	85 ff		 test	 edi, edi
  0a6bf	74 0c		 je	 SHORT $L62880
  0a6c1	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62879:
  0a6c4	8a 10		 mov	 dl, BYTE PTR [eax]
  0a6c6	88 11		 mov	 BYTE PTR [ecx], dl
  0a6c8	41		 inc	 ecx
  0a6c9	40		 inc	 eax
  0a6ca	4f		 dec	 edi
  0a6cb	75 f7		 jne	 SHORT $L62879
$L62880:
  0a6cd	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a6d0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _arg6$[esp+56], OFFSET FLAT:_astrbuf
  0a6d8	eb 09		 jmp	 SHORT $L60542
$L60551:
  0a6da	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a6dc	89 4c 24 20	 mov	 DWORD PTR _arg6$[esp+56], ecx
$L62988:
  0a6e0	83 c6 04	 add	 esi, 4
$L60542:

; 3954 :     CONVERT(arg7);

  0a6e3	33 c0		 xor	 eax, eax
  0a6e5	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a6e8	45		 inc	 ebp
  0a6e9	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a6ec	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a6ef	77 4f		 ja	 SHORT $L60553
  0a6f1	33 d2		 xor	 edx, edx
  0a6f3	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63008[eax]
  0a6f9	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63009[edx*4]
$L60561:
  0a700	8b 06		 mov	 eax, DWORD PTR [esi]
  0a702	89 44 24 1c	 mov	 DWORD PTR _arg7$[esp+56], eax
  0a706	eb 35		 jmp	 SHORT $L62989
$L60558:
  0a708	8b 06		 mov	 eax, DWORD PTR [esi]
  0a70a	33 d2		 xor	 edx, edx
  0a70c	83 c6 04	 add	 esi, 4
  0a70f	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a714	8a 10		 mov	 dl, BYTE PTR [eax]
  0a716	40		 inc	 eax
  0a717	8b fa		 mov	 edi, edx
  0a719	4a		 dec	 edx
  0a71a	85 ff		 test	 edi, edi
  0a71c	74 0c		 je	 SHORT $L62888
  0a71e	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62887:
  0a721	8a 10		 mov	 dl, BYTE PTR [eax]
  0a723	88 11		 mov	 BYTE PTR [ecx], dl
  0a725	41		 inc	 ecx
  0a726	40		 inc	 eax
  0a727	4f		 dec	 edi
  0a728	75 f7		 jne	 SHORT $L62887
$L62888:
  0a72a	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a72d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _arg7$[esp+56], OFFSET FLAT:_astrbuf
  0a735	eb 09		 jmp	 SHORT $L60553
$L60562:
  0a737	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a739	89 4c 24 1c	 mov	 DWORD PTR _arg7$[esp+56], ecx
$L62989:
  0a73d	83 c6 04	 add	 esi, 4
$L60553:

; 3955 :     CONVERT(arg8);

  0a740	33 c0		 xor	 eax, eax
  0a742	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a745	45		 inc	 ebp
  0a746	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a749	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a74c	77 4f		 ja	 SHORT $L60564
  0a74e	33 d2		 xor	 edx, edx
  0a750	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63010[eax]
  0a756	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63011[edx*4]
$L60572:
  0a75d	8b 06		 mov	 eax, DWORD PTR [esi]
  0a75f	89 44 24 18	 mov	 DWORD PTR _arg8$[esp+56], eax
  0a763	eb 35		 jmp	 SHORT $L62990
$L60569:
  0a765	8b 06		 mov	 eax, DWORD PTR [esi]
  0a767	33 d2		 xor	 edx, edx
  0a769	83 c6 04	 add	 esi, 4
  0a76c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a771	8a 10		 mov	 dl, BYTE PTR [eax]
  0a773	40		 inc	 eax
  0a774	8b fa		 mov	 edi, edx
  0a776	4a		 dec	 edx
  0a777	85 ff		 test	 edi, edi
  0a779	74 0c		 je	 SHORT $L62896
  0a77b	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62895:
  0a77e	8a 10		 mov	 dl, BYTE PTR [eax]
  0a780	88 11		 mov	 BYTE PTR [ecx], dl
  0a782	41		 inc	 ecx
  0a783	40		 inc	 eax
  0a784	4f		 dec	 edi
  0a785	75 f7		 jne	 SHORT $L62895
$L62896:
  0a787	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a78a	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _arg8$[esp+56], OFFSET FLAT:_astrbuf
  0a792	eb 09		 jmp	 SHORT $L60564
$L60573:
  0a794	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a796	89 4c 24 18	 mov	 DWORD PTR _arg8$[esp+56], ecx
$L62990:
  0a79a	83 c6 04	 add	 esi, 4
$L60564:

; 3956 :     CONVERT(arg9);

  0a79d	33 c0		 xor	 eax, eax
  0a79f	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a7a2	45		 inc	 ebp
  0a7a3	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a7a6	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a7a9	77 4f		 ja	 SHORT $L60575
  0a7ab	33 d2		 xor	 edx, edx
  0a7ad	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63012[eax]
  0a7b3	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63013[edx*4]
$L60583:
  0a7ba	8b 06		 mov	 eax, DWORD PTR [esi]
  0a7bc	89 44 24 14	 mov	 DWORD PTR _arg9$[esp+56], eax
  0a7c0	eb 35		 jmp	 SHORT $L62991
$L60580:
  0a7c2	8b 06		 mov	 eax, DWORD PTR [esi]
  0a7c4	33 d2		 xor	 edx, edx
  0a7c6	83 c6 04	 add	 esi, 4
  0a7c9	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a7ce	8a 10		 mov	 dl, BYTE PTR [eax]
  0a7d0	40		 inc	 eax
  0a7d1	8b fa		 mov	 edi, edx
  0a7d3	4a		 dec	 edx
  0a7d4	85 ff		 test	 edi, edi
  0a7d6	74 0c		 je	 SHORT $L62904
  0a7d8	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62903:
  0a7db	8a 10		 mov	 dl, BYTE PTR [eax]
  0a7dd	88 11		 mov	 BYTE PTR [ecx], dl
  0a7df	41		 inc	 ecx
  0a7e0	40		 inc	 eax
  0a7e1	4f		 dec	 edi
  0a7e2	75 f7		 jne	 SHORT $L62903
$L62904:
  0a7e4	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a7e7	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _arg9$[esp+56], OFFSET FLAT:_astrbuf
  0a7ef	eb 09		 jmp	 SHORT $L60575
$L60584:
  0a7f1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a7f3	89 4c 24 14	 mov	 DWORD PTR _arg9$[esp+56], ecx
$L62991:
  0a7f7	83 c6 04	 add	 esi, 4
$L60575:

; 3957 :     CONVERT(arg10);

  0a7fa	33 c0		 xor	 eax, eax
  0a7fc	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a7ff	45		 inc	 ebp
  0a800	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a803	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a806	77 4f		 ja	 SHORT $L60586
  0a808	33 d2		 xor	 edx, edx
  0a80a	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63014[eax]
  0a810	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63015[edx*4]
$L60594:
  0a817	8b 06		 mov	 eax, DWORD PTR [esi]
  0a819	89 44 24 10	 mov	 DWORD PTR _arg10$[esp+56], eax
  0a81d	eb 35		 jmp	 SHORT $L62992
$L60591:
  0a81f	8b 06		 mov	 eax, DWORD PTR [esi]
  0a821	33 d2		 xor	 edx, edx
  0a823	83 c6 04	 add	 esi, 4
  0a826	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a82b	8a 10		 mov	 dl, BYTE PTR [eax]
  0a82d	40		 inc	 eax
  0a82e	8b fa		 mov	 edi, edx
  0a830	4a		 dec	 edx
  0a831	85 ff		 test	 edi, edi
  0a833	74 0c		 je	 SHORT $L62912
  0a835	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62911:
  0a838	8a 10		 mov	 dl, BYTE PTR [eax]
  0a83a	88 11		 mov	 BYTE PTR [ecx], dl
  0a83c	41		 inc	 ecx
  0a83d	40		 inc	 eax
  0a83e	4f		 dec	 edi
  0a83f	75 f7		 jne	 SHORT $L62911
$L62912:
  0a841	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a844	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _arg10$[esp+56], OFFSET FLAT:_astrbuf
  0a84c	eb 09		 jmp	 SHORT $L60586
$L60595:
  0a84e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a850	89 4c 24 10	 mov	 DWORD PTR _arg10$[esp+56], ecx
$L62992:
  0a854	83 c6 04	 add	 esi, 4
$L60586:

; 3958 :     CONVERT(arg11);

  0a857	33 c0		 xor	 eax, eax
  0a859	8a 45 00	 mov	 al, BYTE PTR [ebp]
  0a85c	45		 inc	 ebp
  0a85d	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0a860	83 f8 46	 cmp	 eax, 70			; 00000046H
  0a863	77 58		 ja	 SHORT $doccall$60480
  0a865	33 d2		 xor	 edx, edx
  0a867	8a 90 00 00 00
	00		 mov	 dl, BYTE PTR $L63016[eax]
  0a86d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L63017[edx*4]
$L60605:
  0a874	8b 06		 mov	 eax, DWORD PTR [esi]
  0a876	83 c6 04	 add	 esi, 4
  0a879	89 44 24 40	 mov	 DWORD PTR _arg11$[esp+52], eax
  0a87d	eb 3e		 jmp	 SHORT $doccall$60480
$L60602:
  0a87f	8b 06		 mov	 eax, DWORD PTR [esi]
  0a881	33 d2		 xor	 edx, edx
  0a883	83 c6 04	 add	 esi, 4
  0a886	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_astrbuf
  0a88b	8a 10		 mov	 dl, BYTE PTR [eax]
  0a88d	40		 inc	 eax
  0a88e	8b fa		 mov	 edi, edx
  0a890	4a		 dec	 edx
  0a891	85 ff		 test	 edi, edi
  0a893	74 0c		 je	 SHORT $L62920
  0a895	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$L62919:
  0a898	8a 10		 mov	 dl, BYTE PTR [eax]
  0a89a	88 11		 mov	 BYTE PTR [ecx], dl
  0a89c	41		 inc	 ecx
  0a89d	40		 inc	 eax
  0a89e	4f		 dec	 edi
  0a89f	75 f7		 jne	 SHORT $L62919
$L62920:
  0a8a1	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0a8a4	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR _arg11$[esp+52], OFFSET FLAT:_astrbuf
  0a8ac	eb 0f		 jmp	 SHORT $doccall$60480
$L60606:
  0a8ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0a8b0	83 c6 04	 add	 esi, 4
  0a8b3	89 4c 24 40	 mov	 DWORD PTR _arg11$[esp+52], ecx
  0a8b7	eb 04		 jmp	 SHORT $doccall$60480
$L62971:
  0a8b9	8b 5c 24 44	 mov	 ebx, DWORD PTR _arg2$[esp+52]
$doccall$60480:

; 3959 : #undef CONVERT
; 3960 : doccall:
; 3961 :     /* callno is the address of a C subroutine */
; 3962 :     ret = (ccalls[callno])(arg0, arg1, arg2, arg3,
; 3963 :                                arg4, arg5, arg6, arg7,
; 3964 : 			       arg8, arg9, arg10, arg11);

  0a8bd	8b 54 24 40	 mov	 edx, DWORD PTR _arg11$[esp+52]
  0a8c1	8b 44 24 10	 mov	 eax, DWORD PTR _arg10$[esp+56]
  0a8c5	8b 4c 24 14	 mov	 ecx, DWORD PTR _arg9$[esp+56]
  0a8c9	52		 push	 edx
  0a8ca	8b 54 24 1c	 mov	 edx, DWORD PTR _arg8$[esp+60]
  0a8ce	50		 push	 eax
  0a8cf	8b 44 24 24	 mov	 eax, DWORD PTR _arg7$[esp+64]
  0a8d3	51		 push	 ecx
  0a8d4	8b 4c 24 2c	 mov	 ecx, DWORD PTR _arg6$[esp+68]
  0a8d8	52		 push	 edx
  0a8d9	8b 54 24 34	 mov	 edx, DWORD PTR _arg5$[esp+72]
  0a8dd	50		 push	 eax
  0a8de	8b 44 24 3c	 mov	 eax, DWORD PTR _arg4$[esp+76]
  0a8e2	51		 push	 ecx
  0a8e3	8b 4c 24 44	 mov	 ecx, DWORD PTR _arg3$[esp+80]
  0a8e7	52		 push	 edx
  0a8e8	8b 54 24 4c	 mov	 edx, DWORD PTR _arg1$[esp+84]
  0a8ec	50		 push	 eax
  0a8ed	8b 44 24 54	 mov	 eax, DWORD PTR _arg0$[esp+88]
  0a8f1	51		 push	 ecx
  0a8f2	8b 4c 24 60	 mov	 ecx, DWORD PTR _callno$[esp+88]
  0a8f6	53		 push	 ebx
  0a8f7	52		 push	 edx
  0a8f8	50		 push	 eax
  0a8f9	ff 14 8d 00 00
	00 00		 call	 DWORD PTR _ccalls[ecx*4]

; 3965 :     switch(*format) {

  0a900	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
  0a903	83 c4 30	 add	 esp, 48			; 00000030H
  0a906	84 c9		 test	 cl, cl
  0a908	74 42		 je	 SHORT $L60611
  0a90a	80 f9 73	 cmp	 cl, 115			; 00000073H
  0a90d	75 2f		 jne	 SHORT $L62958

; 3967 :     case 's': ret = (cell)tofstr((u_char *)ret); break;

  0a90f	8a 08		 mov	 cl, BYTE PTR [eax]
  0a911	33 db		 xor	 ebx, ebx
  0a913	40		 inc	 eax
  0a914	ba 01 00 00 00	 mov	 edx, OFFSET FLAT:_astrbuf+1
  0a919	84 c9		 test	 cl, cl
  0a91b	74 13		 je	 SHORT $L62945
$L62928:
  0a91d	88 0a		 mov	 BYTE PTR [edx], cl
  0a91f	42		 inc	 edx
  0a920	43		 inc	 ebx
  0a921	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  0a927	7d 07		 jge	 SHORT $L62945
  0a929	8a 08		 mov	 cl, BYTE PTR [eax]
  0a92b	40		 inc	 eax
  0a92c	84 c9		 test	 cl, cl
  0a92e	75 ed		 jne	 SHORT $L62928
$L62945:
  0a930	c6 02 00	 mov	 BYTE PTR [edx], 0
  0a933	88 1d 00 00 00
	00		 mov	 BYTE PTR _astrbuf, bl
  0a939	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
$L62958:

; 3968 : 	/* Default: ret is correct already */
; 3969 :     }
; 3970 :     *spp = sp;

  0a93e	8b 54 24 44	 mov	 edx, DWORD PTR _spp$[esp+52]
  0a942	5f		 pop	 edi
  0a943	89 32		 mov	 DWORD PTR [edx], esi
  0a945	5e		 pop	 esi
  0a946	5d		 pop	 ebp
  0a947	5b		 pop	 ebx

; 3971 :     return(ret);
; 3972 : }

  0a948	83 c4 28	 add	 esp, 40			; 00000028H
  0a94b	c3		 ret	 0
$L60611:

; 3966 :     case '\0': ret = *sp++; break;

  0a94c	8b 06		 mov	 eax, DWORD PTR [esi]

; 3968 : 	/* Default: ret is correct already */
; 3969 :     }
; 3970 :     *spp = sp;

  0a94e	8b 4c 24 44	 mov	 ecx, DWORD PTR _spp$[esp+52]
  0a952	83 c6 04	 add	 esi, 4
  0a955	5f		 pop	 edi
  0a956	89 31		 mov	 DWORD PTR [ecx], esi
  0a958	5e		 pop	 esi
  0a959	5d		 pop	 ebp
  0a95a	5b		 pop	 ebx

; 3971 :     return(ret);
; 3972 : }

  0a95b	83 c4 28	 add	 esp, 40			; 00000028H
  0a95e	c3		 ret	 0
  0a95f	90		 npad	 1
$L62995:
  0a960	00 00 00 00	 DD	 $L62971
  0a964	00 00 00 00	 DD	 $L60484
  0a968	00 00 00 00	 DD	 $L60478
  0a96c	00 00 00 00	 DD	 $L60485
  0a970	00 00 00 00	 DD	 $L60481
  0a974	00 00 00 00	 DD	 $L60475
$L62994:
  0a978	00		 DB	 0
  0a979	05		 DB	 5
  0a97a	05		 DB	 5
  0a97b	05		 DB	 5
  0a97c	05		 DB	 5
  0a97d	05		 DB	 5
  0a97e	05		 DB	 5
  0a97f	05		 DB	 5
  0a980	05		 DB	 5
  0a981	05		 DB	 5
  0a982	05		 DB	 5
  0a983	05		 DB	 5
  0a984	05		 DB	 5
  0a985	05		 DB	 5
  0a986	05		 DB	 5
  0a987	05		 DB	 5
  0a988	05		 DB	 5
  0a989	05		 DB	 5
  0a98a	05		 DB	 5
  0a98b	05		 DB	 5
  0a98c	05		 DB	 5
  0a98d	05		 DB	 5
  0a98e	05		 DB	 5
  0a98f	05		 DB	 5
  0a990	05		 DB	 5
  0a991	05		 DB	 5
  0a992	05		 DB	 5
  0a993	05		 DB	 5
  0a994	05		 DB	 5
  0a995	05		 DB	 5
  0a996	05		 DB	 5
  0a997	05		 DB	 5
  0a998	05		 DB	 5
  0a999	05		 DB	 5
  0a99a	05		 DB	 5
  0a99b	05		 DB	 5
  0a99c	05		 DB	 5
  0a99d	05		 DB	 5
  0a99e	05		 DB	 5
  0a99f	05		 DB	 5
  0a9a0	05		 DB	 5
  0a9a1	05		 DB	 5
  0a9a2	05		 DB	 5
  0a9a3	05		 DB	 5
  0a9a4	05		 DB	 5
  0a9a5	05		 DB	 5
  0a9a6	05		 DB	 5
  0a9a7	05		 DB	 5
  0a9a8	05		 DB	 5
  0a9a9	05		 DB	 5
  0a9aa	05		 DB	 5
  0a9ab	05		 DB	 5
  0a9ac	01		 DB	 1
  0a9ad	05		 DB	 5
  0a9ae	05		 DB	 5
  0a9af	05		 DB	 5
  0a9b0	05		 DB	 5
  0a9b1	05		 DB	 5
  0a9b2	05		 DB	 5
  0a9b3	05		 DB	 5
  0a9b4	02		 DB	 2
  0a9b5	05		 DB	 5
  0a9b6	05		 DB	 5
  0a9b7	03		 DB	 3
  0a9b8	05		 DB	 5
  0a9b9	05		 DB	 5
  0a9ba	05		 DB	 5
  0a9bb	05		 DB	 5
  0a9bc	05		 DB	 5
  0a9bd	05		 DB	 5
  0a9be	04		 DB	 4
  0a9bf	90		 npad	 1
$L62997:
  0a9c0	00 00 00 00	 DD	 $L62971
  0a9c4	00 00 00 00	 DD	 $L60495
  0a9c8	00 00 00 00	 DD	 $L60496
  0a9cc	00 00 00 00	 DD	 $L60492
  0a9d0	00 00 00 00	 DD	 $L60487
$L62996:
  0a9d4	00		 DB	 0
  0a9d5	04		 DB	 4
  0a9d6	04		 DB	 4
  0a9d7	04		 DB	 4
  0a9d8	04		 DB	 4
  0a9d9	04		 DB	 4
  0a9da	04		 DB	 4
  0a9db	04		 DB	 4
  0a9dc	04		 DB	 4
  0a9dd	04		 DB	 4
  0a9de	04		 DB	 4
  0a9df	04		 DB	 4
  0a9e0	04		 DB	 4
  0a9e1	04		 DB	 4
  0a9e2	04		 DB	 4
  0a9e3	04		 DB	 4
  0a9e4	04		 DB	 4
  0a9e5	04		 DB	 4
  0a9e6	04		 DB	 4
  0a9e7	04		 DB	 4
  0a9e8	04		 DB	 4
  0a9e9	04		 DB	 4
  0a9ea	04		 DB	 4
  0a9eb	04		 DB	 4
  0a9ec	04		 DB	 4
  0a9ed	04		 DB	 4
  0a9ee	04		 DB	 4
  0a9ef	04		 DB	 4
  0a9f0	04		 DB	 4
  0a9f1	04		 DB	 4
  0a9f2	04		 DB	 4
  0a9f3	04		 DB	 4
  0a9f4	04		 DB	 4
  0a9f5	04		 DB	 4
  0a9f6	04		 DB	 4
  0a9f7	04		 DB	 4
  0a9f8	04		 DB	 4
  0a9f9	04		 DB	 4
  0a9fa	04		 DB	 4
  0a9fb	04		 DB	 4
  0a9fc	04		 DB	 4
  0a9fd	04		 DB	 4
  0a9fe	04		 DB	 4
  0a9ff	04		 DB	 4
  0aa00	04		 DB	 4
  0aa01	04		 DB	 4
  0aa02	04		 DB	 4
  0aa03	04		 DB	 4
  0aa04	04		 DB	 4
  0aa05	04		 DB	 4
  0aa06	04		 DB	 4
  0aa07	04		 DB	 4
  0aa08	01		 DB	 1
  0aa09	04		 DB	 4
  0aa0a	04		 DB	 4
  0aa0b	04		 DB	 4
  0aa0c	04		 DB	 4
  0aa0d	04		 DB	 4
  0aa0e	04		 DB	 4
  0aa0f	04		 DB	 4
  0aa10	01		 DB	 1
  0aa11	04		 DB	 4
  0aa12	04		 DB	 4
  0aa13	02		 DB	 2
  0aa14	04		 DB	 4
  0aa15	04		 DB	 4
  0aa16	04		 DB	 4
  0aa17	04		 DB	 4
  0aa18	04		 DB	 4
  0aa19	04		 DB	 4
  0aa1a	03		 DB	 3
  0aa1b	90		 npad	 1
$L62999:
  0aa1c	00 00 00 00	 DD	 $L62971
  0aa20	00 00 00 00	 DD	 $L60507
  0aa24	00 00 00 00	 DD	 $L60503
  0aa28	00 00 00 00	 DD	 $L62961
$L62998:
  0aa2c	00		 DB	 0
  0aa2d	03		 DB	 3
  0aa2e	03		 DB	 3
  0aa2f	03		 DB	 3
  0aa30	03		 DB	 3
  0aa31	03		 DB	 3
  0aa32	03		 DB	 3
  0aa33	03		 DB	 3
  0aa34	03		 DB	 3
  0aa35	03		 DB	 3
  0aa36	03		 DB	 3
  0aa37	03		 DB	 3
  0aa38	03		 DB	 3
  0aa39	03		 DB	 3
  0aa3a	03		 DB	 3
  0aa3b	03		 DB	 3
  0aa3c	03		 DB	 3
  0aa3d	03		 DB	 3
  0aa3e	03		 DB	 3
  0aa3f	03		 DB	 3
  0aa40	03		 DB	 3
  0aa41	03		 DB	 3
  0aa42	03		 DB	 3
  0aa43	03		 DB	 3
  0aa44	03		 DB	 3
  0aa45	03		 DB	 3
  0aa46	03		 DB	 3
  0aa47	03		 DB	 3
  0aa48	03		 DB	 3
  0aa49	03		 DB	 3
  0aa4a	03		 DB	 3
  0aa4b	03		 DB	 3
  0aa4c	03		 DB	 3
  0aa4d	03		 DB	 3
  0aa4e	03		 DB	 3
  0aa4f	03		 DB	 3
  0aa50	03		 DB	 3
  0aa51	03		 DB	 3
  0aa52	03		 DB	 3
  0aa53	03		 DB	 3
  0aa54	03		 DB	 3
  0aa55	03		 DB	 3
  0aa56	03		 DB	 3
  0aa57	03		 DB	 3
  0aa58	03		 DB	 3
  0aa59	03		 DB	 3
  0aa5a	03		 DB	 3
  0aa5b	03		 DB	 3
  0aa5c	03		 DB	 3
  0aa5d	03		 DB	 3
  0aa5e	03		 DB	 3
  0aa5f	03		 DB	 3
  0aa60	01		 DB	 1
  0aa61	03		 DB	 3
  0aa62	03		 DB	 3
  0aa63	03		 DB	 3
  0aa64	03		 DB	 3
  0aa65	03		 DB	 3
  0aa66	03		 DB	 3
  0aa67	03		 DB	 3
  0aa68	01		 DB	 1
  0aa69	03		 DB	 3
  0aa6a	03		 DB	 3
  0aa6b	01		 DB	 1
  0aa6c	03		 DB	 3
  0aa6d	03		 DB	 3
  0aa6e	03		 DB	 3
  0aa6f	03		 DB	 3
  0aa70	03		 DB	 3
  0aa71	03		 DB	 3
  0aa72	02		 DB	 2
  0aa73	90		 npad	 1
$L63001:
  0aa74	00 00 00 00	 DD	 $doccall$60480
  0aa78	00 00 00 00	 DD	 $L60517
  0aa7c	00 00 00 00	 DD	 $L60512
  0aa80	00 00 00 00	 DD	 $L60518
  0aa84	00 00 00 00	 DD	 $L60514
  0aa88	00 00 00 00	 DD	 $L60509
$L63000:
  0aa8c	00		 DB	 0
  0aa8d	05		 DB	 5
  0aa8e	05		 DB	 5
  0aa8f	05		 DB	 5
  0aa90	05		 DB	 5
  0aa91	05		 DB	 5
  0aa92	05		 DB	 5
  0aa93	05		 DB	 5
  0aa94	05		 DB	 5
  0aa95	05		 DB	 5
  0aa96	05		 DB	 5
  0aa97	05		 DB	 5
  0aa98	05		 DB	 5
  0aa99	05		 DB	 5
  0aa9a	05		 DB	 5
  0aa9b	05		 DB	 5
  0aa9c	05		 DB	 5
  0aa9d	05		 DB	 5
  0aa9e	05		 DB	 5
  0aa9f	05		 DB	 5
  0aaa0	05		 DB	 5
  0aaa1	05		 DB	 5
  0aaa2	05		 DB	 5
  0aaa3	05		 DB	 5
  0aaa4	05		 DB	 5
  0aaa5	05		 DB	 5
  0aaa6	05		 DB	 5
  0aaa7	05		 DB	 5
  0aaa8	05		 DB	 5
  0aaa9	05		 DB	 5
  0aaaa	05		 DB	 5
  0aaab	05		 DB	 5
  0aaac	05		 DB	 5
  0aaad	05		 DB	 5
  0aaae	05		 DB	 5
  0aaaf	05		 DB	 5
  0aab0	05		 DB	 5
  0aab1	05		 DB	 5
  0aab2	05		 DB	 5
  0aab3	05		 DB	 5
  0aab4	05		 DB	 5
  0aab5	05		 DB	 5
  0aab6	05		 DB	 5
  0aab7	05		 DB	 5
  0aab8	05		 DB	 5
  0aab9	05		 DB	 5
  0aaba	05		 DB	 5
  0aabb	05		 DB	 5
  0aabc	05		 DB	 5
  0aabd	05		 DB	 5
  0aabe	05		 DB	 5
  0aabf	05		 DB	 5
  0aac0	01		 DB	 1
  0aac1	05		 DB	 5
  0aac2	05		 DB	 5
  0aac3	05		 DB	 5
  0aac4	05		 DB	 5
  0aac5	05		 DB	 5
  0aac6	05		 DB	 5
  0aac7	05		 DB	 5
  0aac8	02		 DB	 2
  0aac9	05		 DB	 5
  0aaca	05		 DB	 5
  0aacb	03		 DB	 3
  0aacc	05		 DB	 5
  0aacd	05		 DB	 5
  0aace	05		 DB	 5
  0aacf	05		 DB	 5
  0aad0	05		 DB	 5
  0aad1	05		 DB	 5
  0aad2	04		 DB	 4
  0aad3	90		 npad	 1
$L63003:
  0aad4	00 00 00 00	 DD	 $doccall$60480
  0aad8	00 00 00 00	 DD	 $L60528
  0aadc	00 00 00 00	 DD	 $L60529
  0aae0	00 00 00 00	 DD	 $L60525
  0aae4	00 00 00 00	 DD	 $L60520
$L63002:
  0aae8	00		 DB	 0
  0aae9	04		 DB	 4
  0aaea	04		 DB	 4
  0aaeb	04		 DB	 4
  0aaec	04		 DB	 4
  0aaed	04		 DB	 4
  0aaee	04		 DB	 4
  0aaef	04		 DB	 4
  0aaf0	04		 DB	 4
  0aaf1	04		 DB	 4
  0aaf2	04		 DB	 4
  0aaf3	04		 DB	 4
  0aaf4	04		 DB	 4
  0aaf5	04		 DB	 4
  0aaf6	04		 DB	 4
  0aaf7	04		 DB	 4
  0aaf8	04		 DB	 4
  0aaf9	04		 DB	 4
  0aafa	04		 DB	 4
  0aafb	04		 DB	 4
  0aafc	04		 DB	 4
  0aafd	04		 DB	 4
  0aafe	04		 DB	 4
  0aaff	04		 DB	 4
  0ab00	04		 DB	 4
  0ab01	04		 DB	 4
  0ab02	04		 DB	 4
  0ab03	04		 DB	 4
  0ab04	04		 DB	 4
  0ab05	04		 DB	 4
  0ab06	04		 DB	 4
  0ab07	04		 DB	 4
  0ab08	04		 DB	 4
  0ab09	04		 DB	 4
  0ab0a	04		 DB	 4
  0ab0b	04		 DB	 4
  0ab0c	04		 DB	 4
  0ab0d	04		 DB	 4
  0ab0e	04		 DB	 4
  0ab0f	04		 DB	 4
  0ab10	04		 DB	 4
  0ab11	04		 DB	 4
  0ab12	04		 DB	 4
  0ab13	04		 DB	 4
  0ab14	04		 DB	 4
  0ab15	04		 DB	 4
  0ab16	04		 DB	 4
  0ab17	04		 DB	 4
  0ab18	04		 DB	 4
  0ab19	04		 DB	 4
  0ab1a	04		 DB	 4
  0ab1b	04		 DB	 4
  0ab1c	01		 DB	 1
  0ab1d	04		 DB	 4
  0ab1e	04		 DB	 4
  0ab1f	04		 DB	 4
  0ab20	04		 DB	 4
  0ab21	04		 DB	 4
  0ab22	04		 DB	 4
  0ab23	04		 DB	 4
  0ab24	01		 DB	 1
  0ab25	04		 DB	 4
  0ab26	04		 DB	 4
  0ab27	02		 DB	 2
  0ab28	04		 DB	 4
  0ab29	04		 DB	 4
  0ab2a	04		 DB	 4
  0ab2b	04		 DB	 4
  0ab2c	04		 DB	 4
  0ab2d	04		 DB	 4
  0ab2e	03		 DB	 3
  0ab2f	90		 npad	 1
$L63005:
  0ab30	00 00 00 00	 DD	 $doccall$60480
  0ab34	00 00 00 00	 DD	 $L60539
  0ab38	00 00 00 00	 DD	 $L60540
  0ab3c	00 00 00 00	 DD	 $L60536
  0ab40	00 00 00 00	 DD	 $L60531
$L63004:
  0ab44	00		 DB	 0
  0ab45	04		 DB	 4
  0ab46	04		 DB	 4
  0ab47	04		 DB	 4
  0ab48	04		 DB	 4
  0ab49	04		 DB	 4
  0ab4a	04		 DB	 4
  0ab4b	04		 DB	 4
  0ab4c	04		 DB	 4
  0ab4d	04		 DB	 4
  0ab4e	04		 DB	 4
  0ab4f	04		 DB	 4
  0ab50	04		 DB	 4
  0ab51	04		 DB	 4
  0ab52	04		 DB	 4
  0ab53	04		 DB	 4
  0ab54	04		 DB	 4
  0ab55	04		 DB	 4
  0ab56	04		 DB	 4
  0ab57	04		 DB	 4
  0ab58	04		 DB	 4
  0ab59	04		 DB	 4
  0ab5a	04		 DB	 4
  0ab5b	04		 DB	 4
  0ab5c	04		 DB	 4
  0ab5d	04		 DB	 4
  0ab5e	04		 DB	 4
  0ab5f	04		 DB	 4
  0ab60	04		 DB	 4
  0ab61	04		 DB	 4
  0ab62	04		 DB	 4
  0ab63	04		 DB	 4
  0ab64	04		 DB	 4
  0ab65	04		 DB	 4
  0ab66	04		 DB	 4
  0ab67	04		 DB	 4
  0ab68	04		 DB	 4
  0ab69	04		 DB	 4
  0ab6a	04		 DB	 4
  0ab6b	04		 DB	 4
  0ab6c	04		 DB	 4
  0ab6d	04		 DB	 4
  0ab6e	04		 DB	 4
  0ab6f	04		 DB	 4
  0ab70	04		 DB	 4
  0ab71	04		 DB	 4
  0ab72	04		 DB	 4
  0ab73	04		 DB	 4
  0ab74	04		 DB	 4
  0ab75	04		 DB	 4
  0ab76	04		 DB	 4
  0ab77	04		 DB	 4
  0ab78	01		 DB	 1
  0ab79	04		 DB	 4
  0ab7a	04		 DB	 4
  0ab7b	04		 DB	 4
  0ab7c	04		 DB	 4
  0ab7d	04		 DB	 4
  0ab7e	04		 DB	 4
  0ab7f	04		 DB	 4
  0ab80	01		 DB	 1
  0ab81	04		 DB	 4
  0ab82	04		 DB	 4
  0ab83	02		 DB	 2
  0ab84	04		 DB	 4
  0ab85	04		 DB	 4
  0ab86	04		 DB	 4
  0ab87	04		 DB	 4
  0ab88	04		 DB	 4
  0ab89	04		 DB	 4
  0ab8a	03		 DB	 3
  0ab8b	90		 npad	 1
$L63007:
  0ab8c	00 00 00 00	 DD	 $doccall$60480
  0ab90	00 00 00 00	 DD	 $L60550
  0ab94	00 00 00 00	 DD	 $L60551
  0ab98	00 00 00 00	 DD	 $L60547
  0ab9c	00 00 00 00	 DD	 $L60542
$L63006:
  0aba0	00		 DB	 0
  0aba1	04		 DB	 4
  0aba2	04		 DB	 4
  0aba3	04		 DB	 4
  0aba4	04		 DB	 4
  0aba5	04		 DB	 4
  0aba6	04		 DB	 4
  0aba7	04		 DB	 4
  0aba8	04		 DB	 4
  0aba9	04		 DB	 4
  0abaa	04		 DB	 4
  0abab	04		 DB	 4
  0abac	04		 DB	 4
  0abad	04		 DB	 4
  0abae	04		 DB	 4
  0abaf	04		 DB	 4
  0abb0	04		 DB	 4
  0abb1	04		 DB	 4
  0abb2	04		 DB	 4
  0abb3	04		 DB	 4
  0abb4	04		 DB	 4
  0abb5	04		 DB	 4
  0abb6	04		 DB	 4
  0abb7	04		 DB	 4
  0abb8	04		 DB	 4
  0abb9	04		 DB	 4
  0abba	04		 DB	 4
  0abbb	04		 DB	 4
  0abbc	04		 DB	 4
  0abbd	04		 DB	 4
  0abbe	04		 DB	 4
  0abbf	04		 DB	 4
  0abc0	04		 DB	 4
  0abc1	04		 DB	 4
  0abc2	04		 DB	 4
  0abc3	04		 DB	 4
  0abc4	04		 DB	 4
  0abc5	04		 DB	 4
  0abc6	04		 DB	 4
  0abc7	04		 DB	 4
  0abc8	04		 DB	 4
  0abc9	04		 DB	 4
  0abca	04		 DB	 4
  0abcb	04		 DB	 4
  0abcc	04		 DB	 4
  0abcd	04		 DB	 4
  0abce	04		 DB	 4
  0abcf	04		 DB	 4
  0abd0	04		 DB	 4
  0abd1	04		 DB	 4
  0abd2	04		 DB	 4
  0abd3	04		 DB	 4
  0abd4	01		 DB	 1
  0abd5	04		 DB	 4
  0abd6	04		 DB	 4
  0abd7	04		 DB	 4
  0abd8	04		 DB	 4
  0abd9	04		 DB	 4
  0abda	04		 DB	 4
  0abdb	04		 DB	 4
  0abdc	01		 DB	 1
  0abdd	04		 DB	 4
  0abde	04		 DB	 4
  0abdf	02		 DB	 2
  0abe0	04		 DB	 4
  0abe1	04		 DB	 4
  0abe2	04		 DB	 4
  0abe3	04		 DB	 4
  0abe4	04		 DB	 4
  0abe5	04		 DB	 4
  0abe6	03		 DB	 3
  0abe7	90		 npad	 1
$L63009:
  0abe8	00 00 00 00	 DD	 $doccall$60480
  0abec	00 00 00 00	 DD	 $L60561
  0abf0	00 00 00 00	 DD	 $L60562
  0abf4	00 00 00 00	 DD	 $L60558
  0abf8	00 00 00 00	 DD	 $L60553
$L63008:
  0abfc	00		 DB	 0
  0abfd	04		 DB	 4
  0abfe	04		 DB	 4
  0abff	04		 DB	 4
  0ac00	04		 DB	 4
  0ac01	04		 DB	 4
  0ac02	04		 DB	 4
  0ac03	04		 DB	 4
  0ac04	04		 DB	 4
  0ac05	04		 DB	 4
  0ac06	04		 DB	 4
  0ac07	04		 DB	 4
  0ac08	04		 DB	 4
  0ac09	04		 DB	 4
  0ac0a	04		 DB	 4
  0ac0b	04		 DB	 4
  0ac0c	04		 DB	 4
  0ac0d	04		 DB	 4
  0ac0e	04		 DB	 4
  0ac0f	04		 DB	 4
  0ac10	04		 DB	 4
  0ac11	04		 DB	 4
  0ac12	04		 DB	 4
  0ac13	04		 DB	 4
  0ac14	04		 DB	 4
  0ac15	04		 DB	 4
  0ac16	04		 DB	 4
  0ac17	04		 DB	 4
  0ac18	04		 DB	 4
  0ac19	04		 DB	 4
  0ac1a	04		 DB	 4
  0ac1b	04		 DB	 4
  0ac1c	04		 DB	 4
  0ac1d	04		 DB	 4
  0ac1e	04		 DB	 4
  0ac1f	04		 DB	 4
  0ac20	04		 DB	 4
  0ac21	04		 DB	 4
  0ac22	04		 DB	 4
  0ac23	04		 DB	 4
  0ac24	04		 DB	 4
  0ac25	04		 DB	 4
  0ac26	04		 DB	 4
  0ac27	04		 DB	 4
  0ac28	04		 DB	 4
  0ac29	04		 DB	 4
  0ac2a	04		 DB	 4
  0ac2b	04		 DB	 4
  0ac2c	04		 DB	 4
  0ac2d	04		 DB	 4
  0ac2e	04		 DB	 4
  0ac2f	04		 DB	 4
  0ac30	01		 DB	 1
  0ac31	04		 DB	 4
  0ac32	04		 DB	 4
  0ac33	04		 DB	 4
  0ac34	04		 DB	 4
  0ac35	04		 DB	 4
  0ac36	04		 DB	 4
  0ac37	04		 DB	 4
  0ac38	01		 DB	 1
  0ac39	04		 DB	 4
  0ac3a	04		 DB	 4
  0ac3b	02		 DB	 2
  0ac3c	04		 DB	 4
  0ac3d	04		 DB	 4
  0ac3e	04		 DB	 4
  0ac3f	04		 DB	 4
  0ac40	04		 DB	 4
  0ac41	04		 DB	 4
  0ac42	03		 DB	 3
  0ac43	90		 npad	 1
$L63011:
  0ac44	00 00 00 00	 DD	 $doccall$60480
  0ac48	00 00 00 00	 DD	 $L60572
  0ac4c	00 00 00 00	 DD	 $L60573
  0ac50	00 00 00 00	 DD	 $L60569
  0ac54	00 00 00 00	 DD	 $L60564
$L63010:
  0ac58	00		 DB	 0
  0ac59	04		 DB	 4
  0ac5a	04		 DB	 4
  0ac5b	04		 DB	 4
  0ac5c	04		 DB	 4
  0ac5d	04		 DB	 4
  0ac5e	04		 DB	 4
  0ac5f	04		 DB	 4
  0ac60	04		 DB	 4
  0ac61	04		 DB	 4
  0ac62	04		 DB	 4
  0ac63	04		 DB	 4
  0ac64	04		 DB	 4
  0ac65	04		 DB	 4
  0ac66	04		 DB	 4
  0ac67	04		 DB	 4
  0ac68	04		 DB	 4
  0ac69	04		 DB	 4
  0ac6a	04		 DB	 4
  0ac6b	04		 DB	 4
  0ac6c	04		 DB	 4
  0ac6d	04		 DB	 4
  0ac6e	04		 DB	 4
  0ac6f	04		 DB	 4
  0ac70	04		 DB	 4
  0ac71	04		 DB	 4
  0ac72	04		 DB	 4
  0ac73	04		 DB	 4
  0ac74	04		 DB	 4
  0ac75	04		 DB	 4
  0ac76	04		 DB	 4
  0ac77	04		 DB	 4
  0ac78	04		 DB	 4
  0ac79	04		 DB	 4
  0ac7a	04		 DB	 4
  0ac7b	04		 DB	 4
  0ac7c	04		 DB	 4
  0ac7d	04		 DB	 4
  0ac7e	04		 DB	 4
  0ac7f	04		 DB	 4
  0ac80	04		 DB	 4
  0ac81	04		 DB	 4
  0ac82	04		 DB	 4
  0ac83	04		 DB	 4
  0ac84	04		 DB	 4
  0ac85	04		 DB	 4
  0ac86	04		 DB	 4
  0ac87	04		 DB	 4
  0ac88	04		 DB	 4
  0ac89	04		 DB	 4
  0ac8a	04		 DB	 4
  0ac8b	04		 DB	 4
  0ac8c	01		 DB	 1
  0ac8d	04		 DB	 4
  0ac8e	04		 DB	 4
  0ac8f	04		 DB	 4
  0ac90	04		 DB	 4
  0ac91	04		 DB	 4
  0ac92	04		 DB	 4
  0ac93	04		 DB	 4
  0ac94	01		 DB	 1
  0ac95	04		 DB	 4
  0ac96	04		 DB	 4
  0ac97	02		 DB	 2
  0ac98	04		 DB	 4
  0ac99	04		 DB	 4
  0ac9a	04		 DB	 4
  0ac9b	04		 DB	 4
  0ac9c	04		 DB	 4
  0ac9d	04		 DB	 4
  0ac9e	03		 DB	 3
  0ac9f	90		 npad	 1
$L63013:
  0aca0	00 00 00 00	 DD	 $doccall$60480
  0aca4	00 00 00 00	 DD	 $L60583
  0aca8	00 00 00 00	 DD	 $L60584
  0acac	00 00 00 00	 DD	 $L60580
  0acb0	00 00 00 00	 DD	 $L60575
$L63012:
  0acb4	00		 DB	 0
  0acb5	04		 DB	 4
  0acb6	04		 DB	 4
  0acb7	04		 DB	 4
  0acb8	04		 DB	 4
  0acb9	04		 DB	 4
  0acba	04		 DB	 4
  0acbb	04		 DB	 4
  0acbc	04		 DB	 4
  0acbd	04		 DB	 4
  0acbe	04		 DB	 4
  0acbf	04		 DB	 4
  0acc0	04		 DB	 4
  0acc1	04		 DB	 4
  0acc2	04		 DB	 4
  0acc3	04		 DB	 4
  0acc4	04		 DB	 4
  0acc5	04		 DB	 4
  0acc6	04		 DB	 4
  0acc7	04		 DB	 4
  0acc8	04		 DB	 4
  0acc9	04		 DB	 4
  0acca	04		 DB	 4
  0accb	04		 DB	 4
  0accc	04		 DB	 4
  0accd	04		 DB	 4
  0acce	04		 DB	 4
  0accf	04		 DB	 4
  0acd0	04		 DB	 4
  0acd1	04		 DB	 4
  0acd2	04		 DB	 4
  0acd3	04		 DB	 4
  0acd4	04		 DB	 4
  0acd5	04		 DB	 4
  0acd6	04		 DB	 4
  0acd7	04		 DB	 4
  0acd8	04		 DB	 4
  0acd9	04		 DB	 4
  0acda	04		 DB	 4
  0acdb	04		 DB	 4
  0acdc	04		 DB	 4
  0acdd	04		 DB	 4
  0acde	04		 DB	 4
  0acdf	04		 DB	 4
  0ace0	04		 DB	 4
  0ace1	04		 DB	 4
  0ace2	04		 DB	 4
  0ace3	04		 DB	 4
  0ace4	04		 DB	 4
  0ace5	04		 DB	 4
  0ace6	04		 DB	 4
  0ace7	04		 DB	 4
  0ace8	01		 DB	 1
  0ace9	04		 DB	 4
  0acea	04		 DB	 4
  0aceb	04		 DB	 4
  0acec	04		 DB	 4
  0aced	04		 DB	 4
  0acee	04		 DB	 4
  0acef	04		 DB	 4
  0acf0	01		 DB	 1
  0acf1	04		 DB	 4
  0acf2	04		 DB	 4
  0acf3	02		 DB	 2
  0acf4	04		 DB	 4
  0acf5	04		 DB	 4
  0acf6	04		 DB	 4
  0acf7	04		 DB	 4
  0acf8	04		 DB	 4
  0acf9	04		 DB	 4
  0acfa	03		 DB	 3
  0acfb	90		 npad	 1
$L63015:
  0acfc	00 00 00 00	 DD	 $doccall$60480
  0ad00	00 00 00 00	 DD	 $L60594
  0ad04	00 00 00 00	 DD	 $L60595
  0ad08	00 00 00 00	 DD	 $L60591
  0ad0c	00 00 00 00	 DD	 $L60586
$L63014:
  0ad10	00		 DB	 0
  0ad11	04		 DB	 4
  0ad12	04		 DB	 4
  0ad13	04		 DB	 4
  0ad14	04		 DB	 4
  0ad15	04		 DB	 4
  0ad16	04		 DB	 4
  0ad17	04		 DB	 4
  0ad18	04		 DB	 4
  0ad19	04		 DB	 4
  0ad1a	04		 DB	 4
  0ad1b	04		 DB	 4
  0ad1c	04		 DB	 4
  0ad1d	04		 DB	 4
  0ad1e	04		 DB	 4
  0ad1f	04		 DB	 4
  0ad20	04		 DB	 4
  0ad21	04		 DB	 4
  0ad22	04		 DB	 4
  0ad23	04		 DB	 4
  0ad24	04		 DB	 4
  0ad25	04		 DB	 4
  0ad26	04		 DB	 4
  0ad27	04		 DB	 4
  0ad28	04		 DB	 4
  0ad29	04		 DB	 4
  0ad2a	04		 DB	 4
  0ad2b	04		 DB	 4
  0ad2c	04		 DB	 4
  0ad2d	04		 DB	 4
  0ad2e	04		 DB	 4
  0ad2f	04		 DB	 4
  0ad30	04		 DB	 4
  0ad31	04		 DB	 4
  0ad32	04		 DB	 4
  0ad33	04		 DB	 4
  0ad34	04		 DB	 4
  0ad35	04		 DB	 4
  0ad36	04		 DB	 4
  0ad37	04		 DB	 4
  0ad38	04		 DB	 4
  0ad39	04		 DB	 4
  0ad3a	04		 DB	 4
  0ad3b	04		 DB	 4
  0ad3c	04		 DB	 4
  0ad3d	04		 DB	 4
  0ad3e	04		 DB	 4
  0ad3f	04		 DB	 4
  0ad40	04		 DB	 4
  0ad41	04		 DB	 4
  0ad42	04		 DB	 4
  0ad43	04		 DB	 4
  0ad44	01		 DB	 1
  0ad45	04		 DB	 4
  0ad46	04		 DB	 4
  0ad47	04		 DB	 4
  0ad48	04		 DB	 4
  0ad49	04		 DB	 4
  0ad4a	04		 DB	 4
  0ad4b	04		 DB	 4
  0ad4c	01		 DB	 1
  0ad4d	04		 DB	 4
  0ad4e	04		 DB	 4
  0ad4f	02		 DB	 2
  0ad50	04		 DB	 4
  0ad51	04		 DB	 4
  0ad52	04		 DB	 4
  0ad53	04		 DB	 4
  0ad54	04		 DB	 4
  0ad55	04		 DB	 4
  0ad56	03		 DB	 3
  0ad57	90		 npad	 1
$L63017:
  0ad58	00 00 00 00	 DD	 $doccall$60480
  0ad5c	00 00 00 00	 DD	 $L60605
  0ad60	00 00 00 00	 DD	 $L60606
  0ad64	00 00 00 00	 DD	 $L60602
  0ad68	00 00 00 00	 DD	 $doccall$60480
$L63016:
  0ad6c	00		 DB	 0
  0ad6d	04		 DB	 4
  0ad6e	04		 DB	 4
  0ad6f	04		 DB	 4
  0ad70	04		 DB	 4
  0ad71	04		 DB	 4
  0ad72	04		 DB	 4
  0ad73	04		 DB	 4
  0ad74	04		 DB	 4
  0ad75	04		 DB	 4
  0ad76	04		 DB	 4
  0ad77	04		 DB	 4
  0ad78	04		 DB	 4
  0ad79	04		 DB	 4
  0ad7a	04		 DB	 4
  0ad7b	04		 DB	 4
  0ad7c	04		 DB	 4
  0ad7d	04		 DB	 4
  0ad7e	04		 DB	 4
  0ad7f	04		 DB	 4
  0ad80	04		 DB	 4
  0ad81	04		 DB	 4
  0ad82	04		 DB	 4
  0ad83	04		 DB	 4
  0ad84	04		 DB	 4
  0ad85	04		 DB	 4
  0ad86	04		 DB	 4
  0ad87	04		 DB	 4
  0ad88	04		 DB	 4
  0ad89	04		 DB	 4
  0ad8a	04		 DB	 4
  0ad8b	04		 DB	 4
  0ad8c	04		 DB	 4
  0ad8d	04		 DB	 4
  0ad8e	04		 DB	 4
  0ad8f	04		 DB	 4
  0ad90	04		 DB	 4
  0ad91	04		 DB	 4
  0ad92	04		 DB	 4
  0ad93	04		 DB	 4
  0ad94	04		 DB	 4
  0ad95	04		 DB	 4
  0ad96	04		 DB	 4
  0ad97	04		 DB	 4
  0ad98	04		 DB	 4
  0ad99	04		 DB	 4
  0ad9a	04		 DB	 4
  0ad9b	04		 DB	 4
  0ad9c	04		 DB	 4
  0ad9d	04		 DB	 4
  0ad9e	04		 DB	 4
  0ad9f	04		 DB	 4
  0ada0	01		 DB	 1
  0ada1	04		 DB	 4
  0ada2	04		 DB	 4
  0ada3	04		 DB	 4
  0ada4	04		 DB	 4
  0ada5	04		 DB	 4
  0ada6	04		 DB	 4
  0ada7	04		 DB	 4
  0ada8	01		 DB	 1
  0ada9	04		 DB	 4
  0adaa	04		 DB	 4
  0adab	02		 DB	 2
  0adac	04		 DB	 4
  0adad	04		 DB	 4
  0adae	04		 DB	 4
  0adaf	04		 DB	 4
  0adb0	04		 DB	 4
  0adb1	04		 DB	 4
  0adb2	03		 DB	 3
_doccall ENDP
_str$ = 8
_exponent$60622 = 8
_mantissa$60623 = -4
_isfliteral PROC NEAR

; 3977 : {

  0adc0	51		 push	 ecx

; 3978 : 	cell *p;
; 3979 : 
; 3980 : 	if(!isfloatnum(str)) return(0);		/* Fail if not a float */

  0adc1	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0adc6	53		 push	 ebx
  0adc7	55		 push	 ebp
  0adc8	33 c9		 xor	 ecx, ecx
  0adca	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0adcd	56		 push	 esi
  0adce	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0add1	57		 push	 edi
  0add2	75 3d		 jne	 SHORT $L63047
  0add4	8b 44 24 18	 mov	 eax, DWORD PTR _str$[esp+16]
  0add8	33 d2		 xor	 edx, edx
  0adda	8a 10		 mov	 dl, BYTE PTR [eax]
  0addc	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
  0addf	8b fa		 mov	 edi, edx
  0ade1	8b d5		 mov	 edx, ebp
  0ade3	8b f7		 mov	 esi, edi
  0ade5	85 f6		 test	 esi, esi
  0ade7	74 28		 je	 SHORT $L63047
$L63024:
  0ade9	33 c0		 xor	 eax, eax
  0adeb	8a 02		 mov	 al, BYTE PTR [edx]
  0aded	42		 inc	 edx
  0adee	83 e8 2b	 sub	 eax, 43			; 0000002bH
  0adf1	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0adf4	77 1b		 ja	 SHORT $L63047
  0adf6	33 db		 xor	 ebx, ebx
  0adf8	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR $L63049[eax]
  0adfe	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $L63050[ebx*4]
$L63030:
  0ae05	b9 01 00 00 00	 mov	 ecx, 1
$L63025:
  0ae0a	4e		 dec	 esi
  0ae0b	75 dc		 jne	 SHORT $L63024
  0ae0d	85 c9		 test	 ecx, ecx
  0ae0f	75 08		 jne	 SHORT $L60619
$L63047:
  0ae11	5f		 pop	 edi
  0ae12	5e		 pop	 esi
  0ae13	5d		 pop	 ebp
  0ae14	33 c0		 xor	 eax, eax
  0ae16	5b		 pop	 ebx

; 4007 : }

  0ae17	59		 pop	 ecx
  0ae18	c3		 ret	 0
$L60619:

; 3981 : 	fbits.fb_float = atof(tocstr(str));	/* Convert str to float */

  0ae19	8b cf		 mov	 ecx, edi
  0ae1b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_astrbuf
  0ae20	8b d1		 mov	 edx, ecx
  0ae22	49		 dec	 ecx
  0ae23	85 d2		 test	 edx, edx
  0ae25	74 10		 je	 SHORT $L63041
  0ae27	8b d5		 mov	 edx, ebp
  0ae29	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0ae2c	2b d0		 sub	 edx, eax
$L63040:
  0ae2e	8a 0c 02	 mov	 cl, BYTE PTR [edx+eax]
  0ae31	88 08		 mov	 BYTE PTR [eax], cl
  0ae33	40		 inc	 eax
  0ae34	4e		 dec	 esi
  0ae35	75 f7		 jne	 SHORT $L63040
$L63041:
  0ae37	68 00 00 00 00	 push	 OFFSET FLAT:_astrbuf
  0ae3c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0ae3f	e8 00 00 00 00	 call	 _atof

; 3982 : 	if (XV_STATE == COMPILING) {		/* If interp state: compile */

  0ae44	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0ae49	83 c4 04	 add	 esp, 4
  0ae4c	dd 1d 00 00 00
	00		 fstp	 QWORD PTR _fbits
  0ae52	83 78 18 01	 cmp	 DWORD PTR [eax+24], 1
  0ae56	0f 85 ab 00 00
	00		 jne	 $L60620

; 3983 : 	    /* Compile an interoperable float if compiling into a module */
; 3984 : 	    if (XV_MOD_COMP) {

  0ae5c	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [eax+136]
  0ae62	85 c9		 test	 ecx, ecx

; 3985 : 		cell exponent, mantissa;
; 3986 : 		xcompile(IFPAREN_LIT);

  0ae64	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0ae67	51		 push	 ecx
  0ae68	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0ae6b	89 50 70	 mov	 DWORD PTR [eax+112], edx
  0ae6e	74 58		 je	 SHORT $L60621
  0ae70	68 03 01 00 00	 push	 259			; 00000103H
  0ae75	e8 00 00 00 00	 call	 _tokstore

; 3987 : 		Float2IFloat(fbits.fb_float, &exponent, &mantissa);

  0ae7a	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _fbits+4
  0ae80	8d 44 24 18	 lea	 eax, DWORD PTR _mantissa$60623[esp+28]
  0ae84	8d 4c 24 20	 lea	 ecx, DWORD PTR _exponent$60622[esp+24]
  0ae88	50		 push	 eax
  0ae89	a1 00 00 00 00	 mov	 eax, DWORD PTR _fbits
  0ae8e	51		 push	 ecx
  0ae8f	52		 push	 edx
  0ae90	50		 push	 eax
  0ae91	e8 00 00 00 00	 call	 _Float2IFloat

; 3988 : 		p = (cell *)XV_DP;

  0ae96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup

; 3989 : 		*p++ = exponent;

  0ae9c	8b 54 24 30	 mov	 edx, DWORD PTR _exponent$60622[esp+40]
  0aea0	83 c4 18	 add	 esp, 24			; 00000018H
  0aea3	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0aea6	5f		 pop	 edi
  0aea7	5e		 pop	 esi
  0aea8	89 10		 mov	 DWORD PTR [eax], edx

; 3990 : 		*p++ = mantissa;

  0aeaa	8b 4c 24 08	 mov	 ecx, DWORD PTR _mantissa$60623[esp+12]
  0aeae	83 c0 04	 add	 eax, 4
  0aeb1	5d		 pop	 ebp
  0aeb2	5b		 pop	 ebx
  0aeb3	89 08		 mov	 DWORD PTR [eax], ecx

; 3991 : 		XV_DP = (cell)p;

  0aeb5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _xup
  0aebb	83 c0 04	 add	 eax, 4
  0aebe	89 42 70	 mov	 DWORD PTR [edx+112], eax

; 4005 : 	}
; 4006 : 	return (1);

  0aec1	b8 01 00 00 00	 mov	 eax, 1

; 4007 : }

  0aec6	59		 pop	 ecx
  0aec7	c3		 ret	 0
$L60621:

; 3992 : 	    } else {
; 3993 : 		xcompile(FPAREN_LIT);

  0aec8	68 e8 00 00 00	 push	 232			; 000000e8H
  0aecd	e8 00 00 00 00	 call	 _tokstore

; 3994 : 		p = (cell *)XDP;

  0aed2	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup

; 3995 : 		/*
; 3996 : 		 * Potential portability problem: what if the alignment
; 3997 : 		 * rules are different for longs and cells?
; 3998 : 		 */
; 3999 : 		*p++ = (cell)fbits.fb_long[0];

  0aed7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fbits
  0aedd	83 c4 08	 add	 esp, 8
  0aee0	8b 40 70	 mov	 eax, DWORD PTR [eax+112]
  0aee3	5f		 pop	 edi
  0aee4	5e		 pop	 esi
  0aee5	89 08		 mov	 DWORD PTR [eax], ecx

; 4000 : 		*p++ = (cell)fbits.fb_long[1];

  0aee7	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _fbits+4
  0aeed	83 c0 04	 add	 eax, 4
  0aef0	5d		 pop	 ebp
  0aef1	5b		 pop	 ebx
  0aef2	89 10		 mov	 DWORD PTR [eax], edx

; 4001 : 		XV_DP = (cell)p;

  0aef4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _xup
  0aefa	83 c0 04	 add	 eax, 4
  0aefd	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 4005 : 	}
; 4006 : 	return (1);

  0af00	b8 01 00 00 00	 mov	 eax, 1

; 4007 : }

  0af05	59		 pop	 ecx
  0af06	c3		 ret	 0
$L60620:

; 4002 : 	    }
; 4003 : 	} else {
; 4004 : 	    *--xfsp = fbits.fb_float;

  0af07	a1 00 00 00 00	 mov	 eax, DWORD PTR _xfsp
  0af0c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _fbits
  0af12	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _fbits+4
  0af18	83 e8 08	 sub	 eax, 8
  0af1b	a3 00 00 00 00	 mov	 DWORD PTR _xfsp, eax
  0af20	5f		 pop	 edi
  0af21	89 10		 mov	 DWORD PTR [eax], edx
  0af23	5e		 pop	 esi
  0af24	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0af27	5d		 pop	 ebp

; 4005 : 	}
; 4006 : 	return (1);

  0af28	b8 01 00 00 00	 mov	 eax, 1
  0af2d	5b		 pop	 ebx

; 4007 : }

  0af2e	59		 pop	 ecx
  0af2f	c3		 ret	 0
$L63050:
  0af30	00 00 00 00	 DD	 $L63025
  0af34	00 00 00 00	 DD	 $L63030
  0af38	00 00 00 00	 DD	 $L63047
$L63049:
  0af3c	00		 DB	 0
  0af3d	02		 DB	 2
  0af3e	00		 DB	 0
  0af3f	00		 DB	 0
  0af40	02		 DB	 2
  0af41	00		 DB	 0
  0af42	00		 DB	 0
  0af43	00		 DB	 0
  0af44	00		 DB	 0
  0af45	00		 DB	 0
  0af46	00		 DB	 0
  0af47	00		 DB	 0
  0af48	00		 DB	 0
  0af49	00		 DB	 0
  0af4a	00		 DB	 0
  0af4b	02		 DB	 2
  0af4c	02		 DB	 2
  0af4d	02		 DB	 2
  0af4e	02		 DB	 2
  0af4f	02		 DB	 2
  0af50	02		 DB	 2
  0af51	02		 DB	 2
  0af52	02		 DB	 2
  0af53	02		 DB	 2
  0af54	02		 DB	 2
  0af55	02		 DB	 2
  0af56	01		 DB	 1
  0af57	02		 DB	 2
  0af58	02		 DB	 2
  0af59	02		 DB	 2
  0af5a	02		 DB	 2
  0af5b	02		 DB	 2
  0af5c	02		 DB	 2
  0af5d	02		 DB	 2
  0af5e	02		 DB	 2
  0af5f	02		 DB	 2
  0af60	02		 DB	 2
  0af61	02		 DB	 2
  0af62	02		 DB	 2
  0af63	02		 DB	 2
  0af64	02		 DB	 2
  0af65	02		 DB	 2
  0af66	02		 DB	 2
  0af67	02		 DB	 2
  0af68	02		 DB	 2
  0af69	02		 DB	 2
  0af6a	02		 DB	 2
  0af6b	02		 DB	 2
  0af6c	02		 DB	 2
  0af6d	02		 DB	 2
  0af6e	02		 DB	 2
  0af6f	02		 DB	 2
  0af70	02		 DB	 2
  0af71	02		 DB	 2
  0af72	02		 DB	 2
  0af73	02		 DB	 2
  0af74	02		 DB	 2
  0af75	02		 DB	 2
  0af76	01		 DB	 1
_isfliteral ENDP
_TEXT	ENDS
PUBLIC	_isfloatnum
_TEXT	SEGMENT
_str$ = 8
_isfloatnum PROC NEAR

; 4013 : 	int efound = 0;
; 4014 : 	int len;
; 4015 : 
; 4016 : 	/*
; 4017 : 	 * Don't recognize floating point numbers unless base is decimal.
; 4018 : 	 * This prevents the ambiguity with "e" for exponent or "e" for
; 4019 : 	 * a hex digit.
; 4020 : 	 */
; 4021 : 	if (XV_BASE != 10)

  0af80	a1 00 00 00 00	 mov	 eax, DWORD PTR _xup
  0af85	56		 push	 esi
  0af86	57		 push	 edi
  0af87	33 ff		 xor	 edi, edi
  0af89	83 78 0c 0a	 cmp	 DWORD PTR [eax+12], 10	; 0000000aH
  0af8d	74 05		 je	 SHORT $L60642
$L60652:
  0af8f	5f		 pop	 edi

; 4022 : 		return(0);

  0af90	33 c0		 xor	 eax, eax
  0af92	5e		 pop	 esi

; 4039 : }

  0af93	c3		 ret	 0
$L60642:

; 4023 : 
; 4024 : 	for (len = *str++; len; len--) {

  0af94	8b 54 24 0c	 mov	 edx, DWORD PTR _str$[esp+4]
  0af98	33 c9		 xor	 ecx, ecx
  0af9a	8a 0a		 mov	 cl, BYTE PTR [edx]
  0af9c	42		 inc	 edx
  0af9d	8b f1		 mov	 esi, ecx
  0af9f	85 f6		 test	 esi, esi
  0afa1	74 24		 je	 SHORT $L60645
$L60643:

; 4025 : 		switch (*str++) {

  0afa3	33 c9		 xor	 ecx, ecx
  0afa5	8a 0a		 mov	 cl, BYTE PTR [edx]
  0afa7	42		 inc	 edx
  0afa8	83 e9 2b	 sub	 ecx, 43			; 0000002bH
  0afab	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0afae	77 df		 ja	 SHORT $L60652
  0afb0	33 c0		 xor	 eax, eax
  0afb2	8a 81 00 00 00
	00		 mov	 al, BYTE PTR $L63054[ecx]
  0afb8	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L63055[eax*4]
$L60651:

; 4026 : 		case '0':  case '1':  case '2':  case '3':  case '4':
; 4027 : 		case '5':  case '6':  case '7':  case '8':  case '9':
; 4028 : 		case '+':  case '-':  case '.':
; 4029 : 			break;
; 4030 : 		case 'e':
; 4031 : 		case 'E':
; 4032 : 			efound = 1;

  0afbf	bf 01 00 00 00	 mov	 edi, 1
$L60644:

; 4023 : 
; 4024 : 	for (len = *str++; len; len--) {

  0afc4	4e		 dec	 esi
  0afc5	75 dc		 jne	 SHORT $L60643
$L60645:

; 4033 : 			break;
; 4034 : 		default:
; 4035 : 			return(0);
; 4036 : 		}
; 4037 : 	}
; 4038 : 	return(efound);

  0afc7	8b c7		 mov	 eax, edi
  0afc9	5f		 pop	 edi
  0afca	5e		 pop	 esi

; 4039 : }

  0afcb	c3		 ret	 0
$L63055:
  0afcc	00 00 00 00	 DD	 $L60644
  0afd0	00 00 00 00	 DD	 $L60651
  0afd4	00 00 00 00	 DD	 $L60652
$L63054:
  0afd8	00		 DB	 0
  0afd9	02		 DB	 2
  0afda	00		 DB	 0
  0afdb	00		 DB	 0
  0afdc	02		 DB	 2
  0afdd	00		 DB	 0
  0afde	00		 DB	 0
  0afdf	00		 DB	 0
  0afe0	00		 DB	 0
  0afe1	00		 DB	 0
  0afe2	00		 DB	 0
  0afe3	00		 DB	 0
  0afe4	00		 DB	 0
  0afe5	00		 DB	 0
  0afe6	00		 DB	 0
  0afe7	02		 DB	 2
  0afe8	02		 DB	 2
  0afe9	02		 DB	 2
  0afea	02		 DB	 2
  0afeb	02		 DB	 2
  0afec	02		 DB	 2
  0afed	02		 DB	 2
  0afee	02		 DB	 2
  0afef	02		 DB	 2
  0aff0	02		 DB	 2
  0aff1	02		 DB	 2
  0aff2	01		 DB	 1
  0aff3	02		 DB	 2
  0aff4	02		 DB	 2
  0aff5	02		 DB	 2
  0aff6	02		 DB	 2
  0aff7	02		 DB	 2
  0aff8	02		 DB	 2
  0aff9	02		 DB	 2
  0affa	02		 DB	 2
  0affb	02		 DB	 2
  0affc	02		 DB	 2
  0affd	02		 DB	 2
  0affe	02		 DB	 2
  0afff	02		 DB	 2
  0b000	02		 DB	 2
  0b001	02		 DB	 2
  0b002	02		 DB	 2
  0b003	02		 DB	 2
  0b004	02		 DB	 2
  0b005	02		 DB	 2
  0b006	02		 DB	 2
  0b007	02		 DB	 2
  0b008	02		 DB	 2
  0b009	02		 DB	 2
  0b00a	02		 DB	 2
  0b00b	02		 DB	 2
  0b00c	02		 DB	 2
  0b00d	02		 DB	 2
  0b00e	02		 DB	 2
  0b00f	02		 DB	 2
  0b010	02		 DB	 2
  0b011	02		 DB	 2
  0b012	01		 DB	 1
_isfloatnum ENDP
_TEXT	ENDS
END
